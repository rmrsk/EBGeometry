<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EBGeometry: Dcel Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EBGeometry
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Dcel Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace containing various double-connected edge list (DCEL) functionality.  
<a href="namespaceDcel.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceDcel_1_1Parser"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDcel_1_1Parser.html">Parser</a></td></tr>
<tr class="memdesc:namespaceDcel_1_1Parser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace which encapsulates possible file parsers for building DCEL meshes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1EdgeIteratorT.html">EdgeIteratorT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class which can iterate through edges and vertices around a DCEL polygon face.  <a href="classDcel_1_1EdgeIteratorT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1EdgeT.html">EdgeT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class which represents a half-edge in a double-edge connected list (DCEL).  <a href="classDcel_1_1EdgeT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1FaceT.html">FaceT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class which represents a polygon face in a double-edge connected list (DCEL).  <a href="classDcel_1_1FaceT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1MeshT.html">MeshT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh class which stores a full DCEL mesh (with signed distance functions)  <a href="classDcel_1_1MeshT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Polygon2D.html">Polygon2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for embedding a DCEL polygon face into 2D.  <a href="classDcel_1_1Polygon2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1VertexT.html">VertexT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class which represents a vertex node in a double-edge connected list (DCEL).  <a href="classDcel_1_1VertexT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a16b519937528a1a2f50054e41e6e3d9c"><td class="memTemplParams" colspan="2"><a id="a16b519937528a1a2f50054e41e6e3d9c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a16b519937528a1a2f50054e41e6e3d9c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDcel.html#a16b519937528a1a2f50054e41e6e3d9c">PrimitiveList</a> = std::vector&lt; std::shared_ptr&lt; const EBGeometry::Dcel::FaceT&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a16b519937528a1a2f50054e41e6e3d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for vector of primitives. <br /></td></tr>
<tr class="separator:a16b519937528a1a2f50054e41e6e3d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a40f67c7ec704c949871bb20810073e36"><td class="memTemplParams" colspan="2">template&lt;class T , class BV &gt; </td></tr>
<tr class="memitem:a40f67c7ec704c949871bb20810073e36"><td class="memTemplItemLeft" align="right" valign="top">EBGeometry::BVH::BVConstructorT&lt; EBGeometry::Dcel::FaceT&lt; T &gt;, BV &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDcel.html#a40f67c7ec704c949871bb20810073e36">defaultBVConstructor</a></td></tr>
<tr class="memdesc:a40f67c7ec704c949871bb20810073e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounding volume constructor for a DCEL face.  <a href="namespaceDcel.html#a40f67c7ec704c949871bb20810073e36">More...</a><br /></td></tr>
<tr class="separator:a40f67c7ec704c949871bb20810073e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ac140ca7f8cc44e7a7fbe584e26d8c"><td class="memTemplParams" colspan="2">template&lt;class T , class BV , size_t K&gt; </td></tr>
<tr class="memitem:a35ac140ca7f8cc44e7a7fbe584e26d8c"><td class="memTemplItemLeft" align="right" valign="top">EBGeometry::BVH::StopFunctionT&lt; T, EBGeometry::Dcel::FaceT&lt; T &gt;, BV, K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDcel.html#a35ac140ca7f8cc44e7a7fbe584e26d8c">defaultStopFunction</a></td></tr>
<tr class="memdesc:a35ac140ca7f8cc44e7a7fbe584e26d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default stop function. This function terminates the division process if a <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality.">BVH</a> node has only one primitive.  <a href="namespaceDcel.html#a35ac140ca7f8cc44e7a7fbe584e26d8c">More...</a><br /></td></tr>
<tr class="separator:a35ac140ca7f8cc44e7a7fbe584e26d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49de2802787c5c9a25d95572f20b326"><td class="memTemplParams" colspan="2">template&lt;class T , size_t K&gt; </td></tr>
<tr class="memitem:aa49de2802787c5c9a25d95572f20b326"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDcel.html#aa49de2802787c5c9a25d95572f20b326">validChunks</a></td></tr>
<tr class="memdesc:aa49de2802787c5c9a25d95572f20b326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which checks that all chunks are valid (i.e., contain at least one primitive.  <a href="namespaceDcel.html#aa49de2802787c5c9a25d95572f20b326">More...</a><br /></td></tr>
<tr class="separator:aa49de2802787c5c9a25d95572f20b326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31df12a614d7c38ca7f2b031213a59f7"><td class="memTemplParams" colspan="2">template&lt;class T , size_t K&gt; </td></tr>
<tr class="memitem:a31df12a614d7c38ca7f2b031213a59f7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDcel.html#a31df12a614d7c38ca7f2b031213a59f7">equalCounts</a></td></tr>
<tr class="memdesc:a31df12a614d7c38ca7f2b031213a59f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for partitioning an input list into K almost-equal-sized chunks.  <a href="namespaceDcel.html#a31df12a614d7c38ca7f2b031213a59f7">More...</a><br /></td></tr>
<tr class="separator:a31df12a614d7c38ca7f2b031213a59f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5613435b6c3b3ccee6616c01bcc0a8d8"><td class="memTemplParams" colspan="2">template&lt;class T , class BV , size_t K&gt; </td></tr>
<tr class="memitem:a5613435b6c3b3ccee6616c01bcc0a8d8"><td class="memTemplItemLeft" align="right" valign="top">EBGeometry::BVH::PartitionerT&lt; EBGeometry::Dcel::FaceT&lt; T &gt;, BV, K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDcel.html#a5613435b6c3b3ccee6616c01bcc0a8d8">chunkPartitioner</a></td></tr>
<tr class="memdesc:a5613435b6c3b3ccee6616c01bcc0a8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitioner function for subdividing into K sub-volumes with approximately the same number of primitives.  <a href="namespaceDcel.html#a5613435b6c3b3ccee6616c01bcc0a8d8">More...</a><br /></td></tr>
<tr class="separator:a5613435b6c3b3ccee6616c01bcc0a8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1f231f1a8aa751c6bbf8192149e07a"><td class="memTemplParams" colspan="2">template&lt;class T , class BV , size_t K&gt; </td></tr>
<tr class="memitem:a3e1f231f1a8aa751c6bbf8192149e07a"><td class="memTemplItemLeft" align="right" valign="top">EBGeometry::BVH::PartitionerT&lt; EBGeometry::Dcel::FaceT&lt; T &gt;, BV, K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDcel.html#a3e1f231f1a8aa751c6bbf8192149e07a">bvPartitioner</a></td></tr>
<tr class="memdesc:a3e1f231f1a8aa751c6bbf8192149e07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitioner function for subdividing into K sub-volumes with approximately the same number of primitives.  <a href="namespaceDcel.html#a3e1f231f1a8aa751c6bbf8192149e07a">More...</a><br /></td></tr>
<tr class="separator:a3e1f231f1a8aa751c6bbf8192149e07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64f98d30787c28369069696ef135459"><td class="memTemplParams" colspan="2">template&lt;class T , class BV , size_t K&gt; </td></tr>
<tr class="memitem:aa64f98d30787c28369069696ef135459"><td class="memTemplItemLeft" align="right" valign="top">EBGeometry::BVH::PartitionerT&lt; EBGeometry::Dcel::FaceT&lt; T &gt;, BV, K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDcel.html#aa64f98d30787c28369069696ef135459">centroidPartitioner</a></td></tr>
<tr class="memdesc:aa64f98d30787c28369069696ef135459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitioner function for subdividing into K sub-volumes, partitioning on the primitive centroid midpoint(s).  <a href="namespaceDcel.html#aa64f98d30787c28369069696ef135459">More...</a><br /></td></tr>
<tr class="separator:aa64f98d30787c28369069696ef135459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5a5e045fea199e3f04a77ef160e432"><td class="memTemplParams" colspan="2"><a id="a4d5a5e045fea199e3f04a77ef160e432"></a>
template&lt;class T , class BV , size_t K&gt; </td></tr>
<tr class="memitem:a4d5a5e045fea199e3f04a77ef160e432"><td class="memTemplItemLeft" align="right" valign="top">EBGeometry::BVH::PartitionerT&lt; EBGeometry::Dcel::FaceT&lt; T &gt;, BV, K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDcel.html#a4d5a5e045fea199e3f04a77ef160e432">defaultPartitioner</a> = EBGeometry::Dcel::chunkPartitioner&lt;T, BV, K&gt;</td></tr>
<tr class="memdesc:a4d5a5e045fea199e3f04a77ef160e432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for default partitioner. <br /></td></tr>
<tr class="separator:a4d5a5e045fea199e3f04a77ef160e432"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace containing various double-connected edge list (DCEL) functionality. </p>
</div><h2 class="groupheader">Variable Documentation</h2>
<a id="a3e1f231f1a8aa751c6bbf8192149e07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1f231f1a8aa751c6bbf8192149e07a">&#9670;&nbsp;</a></span>bvPartitioner</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BV , size_t K&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EBGeometry::BVH::PartitionerT&lt;EBGeometry::Dcel::FaceT&lt;T&gt;, BV, K&gt; Dcel::bvPartitioner</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partitioner function for subdividing into K sub-volumes with approximately the same number of primitives. </p>
<p>Basically the same as chunkPartitioner, except that the centroids are based on the bounding volumes' centroids. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_primitives</td><td>List of primitives to partition into sub-bounding volumes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa64f98d30787c28369069696ef135459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64f98d30787c28369069696ef135459">&#9670;&nbsp;</a></span>centroidPartitioner</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BV , size_t K&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EBGeometry::BVH::PartitionerT&lt;EBGeometry::Dcel::FaceT&lt;T&gt;, BV, K&gt; Dcel::centroidPartitioner</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partitioner function for subdividing into K sub-volumes, partitioning on the primitive centroid midpoint(s). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_primitives</td><td>List of primitives to partition into sub-bounding volumes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5613435b6c3b3ccee6616c01bcc0a8d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5613435b6c3b3ccee6616c01bcc0a8d8">&#9670;&nbsp;</a></span>chunkPartitioner</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BV , size_t K&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EBGeometry::BVH::PartitionerT&lt;EBGeometry::Dcel::FaceT&lt;T&gt;, BV, K&gt; Dcel::chunkPartitioner</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">const</span> PrimitiveList&lt;T&gt;&amp; a_primitives) -&gt; std::array&lt;PrimitiveList&lt;T&gt;, K&gt; {</div>
<div class="line">    <a class="code" href="classVec3T.html">Vec3T&lt;T&gt;</a> lo =  <a class="code" href="classVec3T.html#af06b99bd905435060149a61a13f61546">Vec3T&lt;T&gt;::max</a>();</div>
<div class="line">    <a class="code" href="classVec3T.html">Vec3T&lt;T&gt;</a> hi = -<a class="code" href="classVec3T.html#af06b99bd905435060149a61a13f61546">Vec3T&lt;T&gt;::max</a>();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : a_primitives){</div>
<div class="line">      lo = <a class="code" href="EBGeometry__Vec_8hpp.html#a291f01622695ab94c0092c3af0a1f3ca">min</a>(lo, p-&gt;getCentroid());</div>
<div class="line">      hi = <a class="code" href="EBGeometry__Vec_8hpp.html#a71f0bc32c9be501cf01a1b6c715dc0a9">max</a>(hi, p-&gt;getCentroid());</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> splitDir = (hi-lo).maxDir(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    </div>
<div class="line">    PrimitiveList&lt;T&gt; sortedPrimitives(a_primitives);</div>
<div class="line">    </div>
<div class="line">    std::sort(sortedPrimitives.begin(), sortedPrimitives.end(),</div>
<div class="line">          [splitDir](<span class="keyword">const</span> std::shared_ptr&lt;<span class="keyword">const</span> FaceT&lt;T&gt; &gt;&amp; f1,</div>
<div class="line">             <span class="keyword">const</span> std::shared_ptr&lt;<span class="keyword">const</span> FaceT&lt;T&gt; &gt;&amp; f2) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line">        return f1-&gt;getCentroid(splitDir) &lt; f2-&gt;getCentroid(splitDir);</div>
<div class="line">          });</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> EBGeometry::Dcel::equalCounts&lt;T, K&gt;(sortedPrimitives);</div>
<div class="line">  }</div>
</div><!-- fragment -->
<p>Partitioner function for subdividing into K sub-volumes with approximately the same number of primitives. </p>
<p>This partitioner splits along one of the axis coordinates and sorts the primitives along the centroid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_primitives</td><td>List of primitives to partition into sub-bounding volumes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40f67c7ec704c949871bb20810073e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f67c7ec704c949871bb20810073e36">&#9670;&nbsp;</a></span>defaultBVConstructor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EBGeometry::BVH::BVConstructorT&lt;EBGeometry::Dcel::FaceT&lt;T&gt;, BV&gt; Dcel::defaultBVConstructor</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">const</span> std::shared_ptr&lt;const EBGeometry::Dcel::FaceT&lt;T&gt; &gt;&amp; a_primitive) -&gt; BV {</div>
<div class="line">    <span class="keywordflow">return</span> BV(a_primitive-&gt;getAllVertexCoordinates());</div>
<div class="line">  }</div>
</div><!-- fragment -->
<p>Bounding volume constructor for a DCEL face. </p>
<p>With BVHs and DCEL, the object to be bounded is the polygon face (e.g., triangle). We assume that our BV constructor can enclose points, so we return an object that encloses all the vertices of the polygon. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_primitive</td><td>Primitive (facet) to be bounded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bounding volume which encloses the input face. </dd></dl>

</div>
</div>
<a id="a35ac140ca7f8cc44e7a7fbe584e26d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ac140ca7f8cc44e7a7fbe584e26d8c">&#9670;&nbsp;</a></span>defaultStopFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BV , size_t K&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EBGeometry::BVH::StopFunctionT&lt;T, EBGeometry::Dcel::FaceT&lt;T&gt;, BV, K&gt; Dcel::defaultStopFunction</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">const</span> <a class="code" href="classBVH_1_1NodeT.html">BVH::NodeT&lt;T, EBGeometry::Dcel::FaceT&lt;T&gt;</a>, BV, K&gt;&amp; a_node) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line">    <span class="keywordflow">return</span> (a_node.getPrimitives()).size() &lt; K;</div>
<div class="line">  }</div>
</div><!-- fragment -->
<p>Default stop function. This function terminates the division process if a <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality.">BVH</a> node has only one primitive. </p>
<p>In this function, <a class="el" href="classBVH_1_1NodeT.html" title="Forward declare the BVH node since it is needed for the polymorphic lambdas.">BVH::NodeT</a>&lt;T, FaceT&lt;T&gt;, <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality.">BVH</a> &gt; is a <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality.">BVH</a> node. The interpretation of the parameters are: T is the precision, FaceT&lt;T&gt; is the primitive type in the <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality.">BVH</a> tree, and BV is the bounding volume type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_node</td><td>Bounding volume hierarchy node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the bounding volume shouldn't be split more and false otherwise. </dd></dl>

</div>
</div>
<a id="a31df12a614d7c38ca7f2b031213a59f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31df12a614d7c38ca7f2b031213a59f7">&#9670;&nbsp;</a></span>equalCounts</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t K&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dcel::equalCounts</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">const</span> PrimitiveList&lt;T&gt;&amp; a_primitives) -&gt; std::array&lt;PrimitiveList&lt;T&gt;, K&gt; {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code" href="EBGeometry__Vec_8hpp.html#aa7f7e15df344c873d1a27b30f77d0831">length</a> = a_primitives.size() / K;</div>
<div class="line">    <span class="keywordtype">int</span> remain = a_primitives.size() % K;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> begin  = 0;</div>
<div class="line">    <span class="keywordtype">int</span> end    = 0;</div>
<div class="line"> </div>
<div class="line">    std::array&lt;PrimitiveList&lt;T&gt;, K&gt; chunks;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 0; k &lt; K; k++){</div>
<div class="line">      end += (remain &gt; 0) ? <a class="code" href="EBGeometry__Vec_8hpp.html#aa7f7e15df344c873d1a27b30f77d0831">length</a> + 1 : <a class="code" href="EBGeometry__Vec_8hpp.html#aa7f7e15df344c873d1a27b30f77d0831">length</a>; remain--;</div>
<div class="line"> </div>
<div class="line">      chunks[k] = PrimitiveList&lt;T&gt;(a_primitives.begin() + begin, a_primitives.begin() + end);</div>
<div class="line"> </div>
<div class="line">      begin = end;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> chunks;        </div>
<div class="line">  }</div>
</div><!-- fragment -->
<p>Function for partitioning an input list into K almost-equal-sized chunks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_primitives</td><td>Primitives to be partitioned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa49de2802787c5c9a25d95572f20b326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49de2802787c5c9a25d95572f20b326">&#9670;&nbsp;</a></span>validChunks</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t K&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dcel::validChunks</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">const</span> std::array&lt;PrimitiveList&lt;T&gt;, K&gt;&amp; a_chunks) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; chunk : a_chunks){</div>
<div class="line">      <span class="keywordflow">if</span>(chunk.empty()) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
</div><!-- fragment -->
<p>Function which checks that all chunks are valid (i.e., contain at least one primitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_chunks</td><td>Chunks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aclassVec3T_html"><div class="ttname"><a href="classVec3T.html">Vec3T</a></div><div class="ttdoc">Three-dimensional vector class with arithmetic operators.</div><div class="ttdef"><b>Definition:</b> EBGeometry_Vec.hpp:220</div></div>
<div class="ttc" id="aclassBVH_1_1NodeT_html"><div class="ttname"><a href="classBVH_1_1NodeT.html">BVH::NodeT</a></div><div class="ttdoc">Forward declare the BVH node since it is needed for the polymorphic lambdas.</div><div class="ttdef"><b>Definition:</b> EBGeometry_BVH.hpp:36</div></div>
<div class="ttc" id="aEBGeometry__Vec_8hpp_html_aa7f7e15df344c873d1a27b30f77d0831"><div class="ttname"><a href="EBGeometry__Vec_8hpp.html#aa7f7e15df344c873d1a27b30f77d0831">length</a></div><div class="ttdeci">T length(const Vec3T&lt; T &gt; &amp;v) noexcept</div><div class="ttdoc">Length function.</div><div class="ttdef"><b>Definition:</b> EBGeometry_VecImplem.hpp:499</div></div>
<div class="ttc" id="aEBGeometry__Vec_8hpp_html_a71f0bc32c9be501cf01a1b6c715dc0a9"><div class="ttname"><a href="EBGeometry__Vec_8hpp.html#a71f0bc32c9be501cf01a1b6c715dc0a9">max</a></div><div class="ttdeci">Vec3T&lt; T &gt; max(const Vec3T&lt; T &gt; &amp;u, const Vec3T&lt; T &gt; &amp;v) noexcept</div><div class="ttdoc">Maximum function. Returns new vector with component-wise minimums.</div><div class="ttdef"><b>Definition:</b> EBGeometry_VecImplem.hpp:485</div></div>
<div class="ttc" id="aclassVec3T_html_af06b99bd905435060149a61a13f61546"><div class="ttname"><a href="classVec3T.html#af06b99bd905435060149a61a13f61546">Vec3T::max</a></div><div class="ttdeci">static constexpr Vec3T&lt; T &gt; max() noexcept</div><div class="ttdoc">Return a vector with maximum representable components.</div><div class="ttdef"><b>Definition:</b> EBGeometry_VecImplem.hpp:232</div></div>
<div class="ttc" id="aEBGeometry__Vec_8hpp_html_a291f01622695ab94c0092c3af0a1f3ca"><div class="ttname"><a href="EBGeometry__Vec_8hpp.html#a291f01622695ab94c0092c3af0a1f3ca">min</a></div><div class="ttdeci">Vec3T&lt; T &gt; min(const Vec3T&lt; T &gt; &amp;u, const Vec3T&lt; T &gt; &amp;v) noexcept</div><div class="ttdoc">Minimum function. Returns new vector with component-wise minimums.</div><div class="ttdef"><b>Definition:</b> EBGeometry_VecImplem.hpp:477</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
