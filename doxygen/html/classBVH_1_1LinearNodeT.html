<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EBGeometry: BVH::LinearNodeT&lt; T, P, BV, K &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EBGeometry
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceBVH.html">BVH</a></li><li class="navelem"><a class="el" href="classBVH_1_1LinearNodeT.html">LinearNodeT</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classBVH_1_1LinearNodeT-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BVH::LinearNodeT&lt; T, P, BV, K &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Forward declare linear node class.  
 <a href="classBVH_1_1LinearNodeT.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="EBGeometry__BVH_8hpp_source.html">EBGeometry_BVH.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a073e87d51d44b4cc243c8f90690247a6"><td class="memItemLeft" align="right" valign="top"><a id="a073e87d51d44b4cc243c8f90690247a6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#a073e87d51d44b4cc243c8f90690247a6">Vec3</a> = <a class="el" href="classVec3T.html">Vec3T</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a073e87d51d44b4cc243c8f90690247a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for vector type. <br /></td></tr>
<tr class="separator:a073e87d51d44b4cc243c8f90690247a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad38f1888fbd8512b749e6b78557729c4"><td class="memItemLeft" align="right" valign="top"><a id="ad38f1888fbd8512b749e6b78557729c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#ad38f1888fbd8512b749e6b78557729c4">LinearNodeT</a> () noexcept</td></tr>
<tr class="memdesc:ad38f1888fbd8512b749e6b78557729c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:ad38f1888fbd8512b749e6b78557729c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426a5b934f659d46be43e608a70f357c"><td class="memItemLeft" align="right" valign="top"><a id="a426a5b934f659d46be43e608a70f357c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#a426a5b934f659d46be43e608a70f357c">~LinearNodeT</a> ()</td></tr>
<tr class="memdesc:a426a5b934f659d46be43e608a70f357c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a426a5b934f659d46be43e608a70f357c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e3dd1c74bf9e66ed692130b49c2e0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#a03e3dd1c74bf9e66ed692130b49c2e0f">setBoundingVolume</a> (const BV &amp;a_boundingVolume) noexcept</td></tr>
<tr class="memdesc:a03e3dd1c74bf9e66ed692130b49c2e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bounding volume.  <a href="classBVH_1_1LinearNodeT.html#a03e3dd1c74bf9e66ed692130b49c2e0f">More...</a><br /></td></tr>
<tr class="separator:a03e3dd1c74bf9e66ed692130b49c2e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdaf7f92d0fce2cc85d4f83dd80bced0"><td class="memItemLeft" align="right" valign="top"><a id="abdaf7f92d0fce2cc85d4f83dd80bced0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#abdaf7f92d0fce2cc85d4f83dd80bced0">setPrimitivesOffset</a> (const size_t a_primitivesOffset) noexcept</td></tr>
<tr class="memdesc:abdaf7f92d0fce2cc85d4f83dd80bced0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the offset into the primitives array. <br /></td></tr>
<tr class="separator:abdaf7f92d0fce2cc85d4f83dd80bced0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0246e43510fbb92c08e966af346f87c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#a0246e43510fbb92c08e966af346f87c6">setNumPrimitives</a> (const size_t a_numPrimitives) noexcept</td></tr>
<tr class="memdesc:a0246e43510fbb92c08e966af346f87c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set number of primitives.  <a href="classBVH_1_1LinearNodeT.html#a0246e43510fbb92c08e966af346f87c6">More...</a><br /></td></tr>
<tr class="separator:a0246e43510fbb92c08e966af346f87c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdc4afa4b52b8592bb19b5da29a4352"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#a1bdc4afa4b52b8592bb19b5da29a4352">setChildOffset</a> (const size_t a_childOffset, const size_t a_whichChild) noexcept</td></tr>
<tr class="memdesc:a1bdc4afa4b52b8592bb19b5da29a4352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the child offsets.  <a href="classBVH_1_1LinearNodeT.html#a1bdc4afa4b52b8592bb19b5da29a4352">More...</a><br /></td></tr>
<tr class="separator:a1bdc4afa4b52b8592bb19b5da29a4352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f103d7e451c1fa8a8e38d703bc33ae"><td class="memItemLeft" align="right" valign="top"><a id="ad3f103d7e451c1fa8a8e38d703bc33ae"></a>
const BV &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#ad3f103d7e451c1fa8a8e38d703bc33ae">getBoundingVolume</a> () const noexcept</td></tr>
<tr class="memdesc:ad3f103d7e451c1fa8a8e38d703bc33ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node bounding volume. return m_boundingVolume. <br /></td></tr>
<tr class="separator:ad3f103d7e451c1fa8a8e38d703bc33ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85800f732d9bd4270687566b1fd5ab02"><td class="memItemLeft" align="right" valign="top">const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#a85800f732d9bd4270687566b1fd5ab02">getPrimitivesOffset</a> () const noexcept</td></tr>
<tr class="memdesc:a85800f732d9bd4270687566b1fd5ab02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the primitives offset.  <a href="classBVH_1_1LinearNodeT.html#a85800f732d9bd4270687566b1fd5ab02">More...</a><br /></td></tr>
<tr class="separator:a85800f732d9bd4270687566b1fd5ab02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63620bbfffac7a7f9f684d0a756f9d2"><td class="memItemLeft" align="right" valign="top">const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#aa63620bbfffac7a7f9f684d0a756f9d2">getNumPrimitives</a> () const noexcept</td></tr>
<tr class="memdesc:aa63620bbfffac7a7f9f684d0a756f9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of primitives.  <a href="classBVH_1_1LinearNodeT.html#aa63620bbfffac7a7f9f684d0a756f9d2">More...</a><br /></td></tr>
<tr class="separator:aa63620bbfffac7a7f9f684d0a756f9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbe9c48acab8a33e2c1b8befd63f37d"><td class="memItemLeft" align="right" valign="top">const std::array&lt; size_t, K &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#a9cbe9c48acab8a33e2c1b8befd63f37d">getChildOffsets</a> () const noexcept</td></tr>
<tr class="memdesc:a9cbe9c48acab8a33e2c1b8befd63f37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the child offsets.  <a href="classBVH_1_1LinearNodeT.html#a9cbe9c48acab8a33e2c1b8befd63f37d">More...</a><br /></td></tr>
<tr class="separator:a9cbe9c48acab8a33e2c1b8befd63f37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba361834e3d013725a92ec4b45633584"><td class="memItemLeft" align="right" valign="top"><a id="aba361834e3d013725a92ec4b45633584"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#aba361834e3d013725a92ec4b45633584">isLeaf</a> () const noexcept</td></tr>
<tr class="memdesc:aba361834e3d013725a92ec4b45633584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is leaf or not. <br /></td></tr>
<tr class="separator:aba361834e3d013725a92ec4b45633584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf5b1c514a20754d527b17e1c664630"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#a2bf5b1c514a20754d527b17e1c664630">getDistanceToBoundingVolume</a> (const <a class="el" href="classBVH_1_1LinearNodeT.html#a073e87d51d44b4cc243c8f90690247a6">Vec3</a> &amp;a_point) const noexcept</td></tr>
<tr class="memdesc:a2bf5b1c514a20754d527b17e1c664630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distance from a 3D point to the bounding volume.  <a href="classBVH_1_1LinearNodeT.html#a2bf5b1c514a20754d527b17e1c664630">More...</a><br /></td></tr>
<tr class="separator:a2bf5b1c514a20754d527b17e1c664630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4a6a8ef0ff7858f6b95b92501e8bc3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#a4a4a6a8ef0ff7858f6b95b92501e8bc3">getDistances</a> (const <a class="el" href="classBVH_1_1LinearNodeT.html#a073e87d51d44b4cc243c8f90690247a6">Vec3</a> &amp;a_point, const std::vector&lt; std::shared_ptr&lt; const P &gt;&gt; &amp;a_primitives) const noexcept</td></tr>
<tr class="memdesc:a4a4a6a8ef0ff7858f6b95b92501e8bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute signed distance to primitives.  <a href="classBVH_1_1LinearNodeT.html#a4a4a6a8ef0ff7858f6b95b92501e8bc3">More...</a><br /></td></tr>
<tr class="separator:a4a4a6a8ef0ff7858f6b95b92501e8bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:acef96b811ea69cd649fda35da082b361"><td class="memItemLeft" align="right" valign="top"><a id="acef96b811ea69cd649fda35da082b361"></a>
BV&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#acef96b811ea69cd649fda35da082b361">m_boundingVolume</a></td></tr>
<tr class="memdesc:acef96b811ea69cd649fda35da082b361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounding volume. <br /></td></tr>
<tr class="separator:acef96b811ea69cd649fda35da082b361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649815b1fd49f9d390ed0a1f196aca25"><td class="memItemLeft" align="right" valign="top"><a id="a649815b1fd49f9d390ed0a1f196aca25"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#a649815b1fd49f9d390ed0a1f196aca25">m_primitivesOffset</a></td></tr>
<tr class="memdesc:a649815b1fd49f9d390ed0a1f196aca25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset into primitives array. <br /></td></tr>
<tr class="separator:a649815b1fd49f9d390ed0a1f196aca25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15aa928c6838a112b9bf1f2fda9a4e9"><td class="memItemLeft" align="right" valign="top"><a id="ad15aa928c6838a112b9bf1f2fda9a4e9"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#ad15aa928c6838a112b9bf1f2fda9a4e9">m_numPrimitives</a></td></tr>
<tr class="memdesc:ad15aa928c6838a112b9bf1f2fda9a4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of primitives. <br /></td></tr>
<tr class="separator:ad15aa928c6838a112b9bf1f2fda9a4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57a40743fdb239d496f8396030c83a9"><td class="memItemLeft" align="right" valign="top"><a id="ae57a40743fdb239d496f8396030c83a9"></a>
std::array&lt; size_t, K &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1LinearNodeT.html#ae57a40743fdb239d496f8396030c83a9">m_childOffsets</a></td></tr>
<tr class="memdesc:ae57a40743fdb239d496f8396030c83a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset to child nodes. <br /></td></tr>
<tr class="separator:ae57a40743fdb239d496f8396030c83a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class P, class BV, size_t K&gt;<br />
class BVH::LinearNodeT&lt; T, P, BV, K &gt;</h3>

<p>Forward declare linear node class. </p>
<p>Node type for linearized (flattened) <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume hierarchy (BVH) functionality.">BVH</a>. This will be constructed from the other (conventional) <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume hierarchy (BVH) functionality.">BVH</a> type.</p>
<p>T is the precision used in the <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume hierarchy (BVH) functionality.">BVH</a> computations, P is the enclosing primitive and BV is the bounding volume used in the <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume hierarchy (BVH) functionality.">BVH</a>. K is the tree degree.</p>
<p>T is the precision for Vec3, P is the primitive type you want to enclose, BV is the bounding volume you use for it.</p>
<dl class="section note"><dt>Note</dt><dd>P MUST supply function signedDistance(...) BV must supply a function getDistance (had this been C++20, we would have use concepts to enforce this). Note that LinearNode is the result of a flattened <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume hierarchy (BVH) functionality.">BVH</a> hierarchy where nodes are stored with depth-first ordering for improved cache-location in the downward traversal.</dd>
<dd>
This class exists so that we can fit the nodes with a smaller memory footprint. The standard <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume hierarchy (BVH) functionality.">BVH</a> node (<a class="el" href="classBVH_1_1NodeT.html" title="Forward declare the BVH node since it is needed for the polymorphic lambdas.">NodeT</a>) is very useful when building the tree but less useful when traversing it since it stores references to the primitives in the node itself. It will span multiple cache lines. This node exists so that we can fit all the <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume hierarchy (BVH) functionality.">BVH</a> info onto fewer cache lines. The number of cache lines will depend on the tree degree, precision, and bounding volume that is chosen.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>There's a minor optimization that can be made to the memory alignment, which is as follows: For a leaf node we never really need the m_childOffsets array, and for a regular node we never really need the m_primitivesOffset member. Moreover, m_childOffsets could be made into a K-1 sized array because we happen to know that the linearized hierarchy will store the first child node immediately after the regular node. We could shave off 16 bytes of storage, which would mean that a double-precision binary tree only takes up one word of CPU memory. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9cbe9c48acab8a33e2c1b8befd63f37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbe9c48acab8a33e2c1b8befd63f37d">&#9670;&nbsp;</a></span>getChildOffsets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , size_t K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt;size_t, K&gt;&amp; <a class="el" href="classBVH_1_1LinearNodeT.html">BVH::LinearNodeT</a>&lt; T, P, BV, K &gt;::getChildOffsets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the child offsets. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_childOffsets </dd></dl>

</div>
</div>
<a id="a4a4a6a8ef0ff7858f6b95b92501e8bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4a6a8ef0ff7858f6b95b92501e8bc3">&#9670;&nbsp;</a></span>getDistances()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , size_t K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="classBVH_1_1LinearNodeT.html">BVH::LinearNodeT</a>&lt; T, P, BV, K &gt;::getDistances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1LinearNodeT.html#a073e87d51d44b4cc243c8f90690247a6">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>a_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const P &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_primitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute signed distance to primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_point</td><td>Point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_primitives</td><td>List of primitives </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only call if this is a leaf node. </dd></dl>

</div>
</div>
<a id="a2bf5b1c514a20754d527b17e1c664630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf5b1c514a20754d527b17e1c664630">&#9670;&nbsp;</a></span>getDistanceToBoundingVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , size_t K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classBVH_1_1LinearNodeT.html">BVH::LinearNodeT</a>&lt; T, P, BV, K &gt;::getDistanceToBoundingVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1LinearNodeT.html#a073e87d51d44b4cc243c8f90690247a6">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>a_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the distance from a 3D point to the bounding volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_point</td><td>3D point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns distance to bounding volume. A zero distance implies that the input point is inside the bounding volume. </dd></dl>

</div>
</div>
<a id="aa63620bbfffac7a7f9f684d0a756f9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63620bbfffac7a7f9f684d0a756f9d2">&#9670;&nbsp;</a></span>getNumPrimitives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , size_t K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t&amp; <a class="el" href="classBVH_1_1LinearNodeT.html">BVH::LinearNodeT</a>&lt; T, P, BV, K &gt;::getNumPrimitives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of primitives. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_numPrimitives </dd></dl>

</div>
</div>
<a id="a85800f732d9bd4270687566b1fd5ab02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85800f732d9bd4270687566b1fd5ab02">&#9670;&nbsp;</a></span>getPrimitivesOffset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , size_t K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t&amp; <a class="el" href="classBVH_1_1LinearNodeT.html">BVH::LinearNodeT</a>&lt; T, P, BV, K &gt;::getPrimitivesOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the primitives offset. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_primitivesOffset </dd></dl>

</div>
</div>
<a id="a03e3dd1c74bf9e66ed692130b49c2e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e3dd1c74bf9e66ed692130b49c2e0f">&#9670;&nbsp;</a></span>setBoundingVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , size_t K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBVH_1_1LinearNodeT.html">BVH::LinearNodeT</a>&lt; T, P, BV, K &gt;::setBoundingVolume </td>
          <td>(</td>
          <td class="paramtype">const BV &amp;&#160;</td>
          <td class="paramname"><em>a_boundingVolume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the bounding volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_boundingVolume</td><td>Bounding volume for this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bdc4afa4b52b8592bb19b5da29a4352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdc4afa4b52b8592bb19b5da29a4352">&#9670;&nbsp;</a></span>setChildOffset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , size_t K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBVH_1_1LinearNodeT.html">BVH::LinearNodeT</a>&lt; T, P, BV, K &gt;::setChildOffset </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a_childOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a_whichChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the child offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_childOffset</td><td>Offset in node array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_whichChild</td><td>Child index in m_childrenOffsets. Must be [0,K-1] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0246e43510fbb92c08e966af346f87c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0246e43510fbb92c08e966af346f87c6">&#9670;&nbsp;</a></span>setNumPrimitives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , size_t K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBVH_1_1LinearNodeT.html">BVH::LinearNodeT</a>&lt; T, P, BV, K &gt;::setNumPrimitives </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a_numPrimitives</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set number of primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_numPrimitives</td><td>Number of primitives. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/EBGeometry/EBGeometry/Source/<a class="el" href="EBGeometry__BVH_8hpp_source.html">EBGeometry_BVH.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
