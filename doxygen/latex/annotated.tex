\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{classBoundingVolumes_1_1AABBT}{Bounding\+Volumes\+::\+AABBT$<$ T $>$}} \\*Axis-\/aligned bounding box as bounding volume }{\pageref{classBoundingVolumes_1_1AABBT}}{}
\item\contentsline{section}{\mbox{\hyperlink{classAnnularIF}{Annular\+IF$<$ T $>$}} \\*Annular implicit function function. Creates a shell out of the implicit function }{\pageref{classAnnularIF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBlurIF}{Blur\+IF$<$ T $>$}} \\*Blurred/interpolated implicit function -\/ can be used for smoothing }{\pageref{classBlurIF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBoundingVolumes_1_1BoundingSphereT}{Bounding\+Volumes\+::\+Bounding\+Sphere\+T$<$ T $>$}} \\*Class which encloses a set of points using a bounding sphere }{\pageref{classBoundingVolumes_1_1BoundingSphereT}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBoxSDF}{Box\+SDF$<$ T $>$}} \\*Signed distance field for an axis-\/aligned box }{\pageref{classBoxSDF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classCapsuleSDF}{Capsule\+SDF$<$ T $>$}} \\*Capsulate/pill SDF. Basically a cylinder with spherical endcaps, oriented along the specified axis }{\pageref{classCapsuleSDF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classComplementIF}{Complement\+IF$<$ T $>$}} \\*Complemented implicit function }{\pageref{classComplementIF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classConeSDF}{Cone\+SDF$<$ T $>$}} \\*Signed distance field for an finite cone. Oriented along +z }{\pageref{classConeSDF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classCylinderSDF}{Cylinder\+SDF$<$ T $>$}} \\*Signed distance field for a cylinder }{\pageref{classCylinderSDF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classDifferenceIF}{Difference\+IF$<$ T $>$}} \\*CSG difference. Computes C = A-\/B }{\pageref{classDifferenceIF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classDCEL_1_1EdgeIteratorT}{DCEL\+::\+Edge\+Iterator\+T$<$ T $>$}} \\*Class which makes it easier to iterate through \mbox{\hyperlink{namespaceDCEL}{DCEL}} edges }{\pageref{classDCEL_1_1EdgeIteratorT}}{}
\item\contentsline{section}{\mbox{\hyperlink{classDCEL_1_1EdgeT}{DCEL\+::\+Edge\+T$<$ T $>$}} \\*Class which represents a half-\/edge in a double-\/edge connected list (\mbox{\hyperlink{namespaceDCEL}{DCEL}}) }{\pageref{classDCEL_1_1EdgeT}}{}
\item\contentsline{section}{\mbox{\hyperlink{classDCEL_1_1FaceT}{DCEL\+::\+Face\+T$<$ T $>$}} \\*Class which represents a polygon face in a double-\/edge connected list (\mbox{\hyperlink{namespaceDCEL}{DCEL}}) }{\pageref{classDCEL_1_1FaceT}}{}
\item\contentsline{section}{\mbox{\hyperlink{classFastCompactMeshSDF}{Fast\+Compact\+Mesh\+SDF$<$ T, BV, K $>$}} \\*Signed distance function for a \mbox{\hyperlink{namespaceDCEL}{DCEL}} mesh. This class uses the compact \mbox{\hyperlink{namespaceBVH}{BVH}} representation }{\pageref{classFastCompactMeshSDF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classFastMeshSDF}{Fast\+Mesh\+SDF$<$ T, BV, K $>$}} \\*Signed distance function for a \mbox{\hyperlink{namespaceDCEL}{DCEL}} mesh. This class uses the full \mbox{\hyperlink{namespaceBVH}{BVH}} representation }{\pageref{classFastMeshSDF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classFastSmoothUnionIF}{Fast\+Smooth\+Union\+IF$<$ T, P, BV, K $>$}} \\*Implicit function smoothed union using BVHs }{\pageref{classFastSmoothUnionIF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classFastUnionIF}{Fast\+Union\+IF$<$ T, P, BV, K $>$}} \\*Implicit function union using BVHs }{\pageref{classFastUnionIF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classImplicitFunction}{Implicit\+Function$<$ T $>$}} \\*Abstract representation of an implicit function function (not necessarily signed distance) }{\pageref{classImplicitFunction}}{}
\item\contentsline{section}{\mbox{\hyperlink{classInfiniteConeSDF}{Infinite\+Cone\+SDF$<$ T $>$}} \\*Signed distance field for an infinite cone. Oriented along +z }{\pageref{classInfiniteConeSDF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classInfiniteCylinderSDF}{Infinite\+Cylinder\+SDF$<$ T $>$}} \\*Inifinitely long cylinder class. Oriented along the y-\/axis }{\pageref{classInfiniteCylinderSDF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classIntersectionIF}{Intersection\+IF$<$ T $>$}} \\*CSG intersection. Computes the maximum value of all input primitives }{\pageref{classIntersectionIF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBVH_1_1LinearBVH}{BVH\+::\+Linear\+BVH$<$ T, P, BV, K $>$}} \\*Forward declare linear \mbox{\hyperlink{namespaceBVH}{BVH}} class }{\pageref{classBVH_1_1LinearBVH}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBVH_1_1LinearNodeT}{BVH\+::\+Linear\+Node\+T$<$ T, P, BV, K $>$}} \\*Forward declare linear node class }{\pageref{classBVH_1_1LinearNodeT}}{}
\item\contentsline{section}{\mbox{\hyperlink{classMeshSDF}{Mesh\+SDF$<$ T $>$}} \\*Signed distance function for a \mbox{\hyperlink{namespaceDCEL}{DCEL}} mesh. Does not use BVHs }{\pageref{classMeshSDF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classDCEL_1_1MeshT}{DCEL\+::\+Mesh\+T$<$ T $>$}} \\*Mesh class which stores a full \mbox{\hyperlink{namespaceDCEL}{DCEL}} mesh (with signed distance functions) }{\pageref{classDCEL_1_1MeshT}}{}
\item\contentsline{section}{\mbox{\hyperlink{classMollifyIF}{Mollify\+IF$<$ T $>$}} \\*Mollified implicit function }{\pageref{classMollifyIF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBVH_1_1NodeT}{BVH\+::\+Node\+T$<$ T, P, BV, K $>$}} \\*Forward declare the \mbox{\hyperlink{namespaceBVH}{BVH}} node since it is needed for the polymorphic lambdas }{\pageref{classBVH_1_1NodeT}}{}
\item\contentsline{section}{\mbox{\hyperlink{classOffsetIF}{Offset\+IF$<$ T $>$}} \\*Offset implicit function. Offsets the implicit function using the input value }{\pageref{classOffsetIF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classPlaneSDF}{Plane\+SDF$<$ T $>$}} \\*Signed distance function for a plane }{\pageref{classPlaneSDF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classParser_1_1PLY}{Parser\+::\+PLY$<$ T $>$}} \\*Class for reading Stanford \mbox{\hyperlink{classParser_1_1PLY}{PLY}} files }{\pageref{classParser_1_1PLY}}{}
\item\contentsline{section}{\mbox{\hyperlink{classPolygon2D}{Polygon2\+D$<$ T $>$}} \\*Class for embedding a polygon face into 2D }{\pageref{classPolygon2D}}{}
\item\contentsline{section}{\mbox{\hyperlink{classRotateIF}{Rotate\+IF$<$ T $>$}} \\*Rotated implicit function. Rotates an implicit function about an axis }{\pageref{classRotateIF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classScaleIF}{Scale\+IF$<$ T $>$}} \\*Scaled implicit function }{\pageref{classScaleIF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classSignedDistanceFunction}{Signed\+Distance\+Function$<$ T $>$}} \\*Abstract representation of a signed distance function }{\pageref{classSignedDistanceFunction}}{}
\item\contentsline{section}{\mbox{\hyperlink{classSmoothIntersectionIF}{Smooth\+Intersection\+IF$<$ T $>$}} \\*Smooth intersection }{\pageref{classSmoothIntersectionIF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classSmoothUnionIF}{Smooth\+Union\+IF$<$ T $>$}} \\*Smooth CSG union. Computes the minimum value of all input primitives }{\pageref{classSmoothUnionIF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classSphereSDF}{Sphere\+SDF$<$ T $>$}} \\*Signed distance field for sphere }{\pageref{classSphereSDF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classParser_1_1STL}{Parser\+::\+STL$<$ T $>$}} \\*Class for reading \mbox{\hyperlink{classParser_1_1STL}{STL}} files }{\pageref{classParser_1_1STL}}{}
\item\contentsline{section}{\mbox{\hyperlink{classTorusSDF}{Torus\+SDF$<$ T $>$}} \\*Signed distance field for a torus }{\pageref{classTorusSDF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classTranslateIF}{Translate\+IF$<$ T $>$}} \\*Translated implicit function }{\pageref{classTranslateIF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classUnionIF}{Union\+IF$<$ T $>$}} \\*CSG union. Computes the minimum value of all input primitives }{\pageref{classUnionIF}}{}
\item\contentsline{section}{\mbox{\hyperlink{classVec2T}{Vec2\+T$<$ T $>$}} \\*Two-\/dimensional vector class with arithmetic operators }{\pageref{classVec2T}}{}
\item\contentsline{section}{\mbox{\hyperlink{classVec3T}{Vec3\+T$<$ T $>$}} \\*Three-\/dimensional vector class with arithmetic operators }{\pageref{classVec3T}}{}
\item\contentsline{section}{\mbox{\hyperlink{classDCEL_1_1VertexT}{DCEL\+::\+Vertex\+T$<$ T $>$}} \\*Class which represents a vertex node in a double-\/edge connected list (\mbox{\hyperlink{namespaceDCEL}{DCEL}}) }{\pageref{classDCEL_1_1VertexT}}{}
\end{DoxyCompactList}
