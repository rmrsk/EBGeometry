%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Introduction}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{EBGeometry}
\date{Sep 14, 2022}
\release{1.0}
\author{Robert Marskar}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
This is the user documentation for EBGeometry, a small C++ package for computing signed distance fields from surface tesselations and analytic shapes.
Although EBGeometry is a self\sphinxhyphen{}contained package, it is was originally written for usage with embedded boundary (EB) and immersed boundary (IB) codes.

\sphinxAtStartPar
EBGeometry does provide the \sphinxstyleemphasis{discrete geometry generation}, i.e. the generation of cut\sphinxhyphen{}cells from a geometry.
It only takes care of the \sphinxstyleemphasis{geometry representation}, i.e. the creation of complex geometries as numerically efficient signed distance fields.

\begin{sphinxadmonition}{important}{Important:}
\sphinxAtStartPar
The EBGeometry source code is found \sphinxhref{https://github.com/rmrsk/EBGeometry}{here}.
A separate Doxygen\sphinxhyphen{}generated API of EBGeometry is \sphinxhref{doxygen/html/index.html}{available here}.
\end{sphinxadmonition}




\chapter{Introduction}
\label{\detokenize{index:introduction}}
\sphinxstepscope
\phantomsection\label{\detokenize{Introduction:chap-introduction}}
\sphinxAtStartPar
EBGeometry is a comparatively compact code for computing signed distance functions to watertight and orientable surface grids.
Originally, it was written to be used with embedded\sphinxhyphen{}boundary (EB) codes like Chombo or AMReX.


\section{Requirements}
\label{\detokenize{Introduction:requirements}}\label{\detokenize{Introduction::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
A C++ compiler which supports C++14.

\end{itemize}


\section{Quickstart}
\label{\detokenize{Introduction:quickstart}}
\sphinxAtStartPar
To obtained EBGeometry, clone the code from \sphinxhref{https://github.com/rmrsk/EBGeometry}{github}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git clone git@github.com:rmrsk/EBGeometry.git
\end{sphinxVerbatim}

\sphinxAtStartPar
EBGeometry is a header\sphinxhyphen{}only library and is comparatively simple to set up and use.
To use it, make \sphinxcode{\sphinxupquote{EBGeometry.hpp}} (stored at the top level) visible to your code and include it.

\sphinxAtStartPar
To compile the examples, navigate to the examples folder.
Examples that begin by \sphinxstyleemphasis{EBGeometry\_} are pure \sphinxcode{\sphinxupquote{EBGeometry}} examples.
Other examples that begin with e.g. \sphinxcode{\sphinxupquote{AMReX\_}} or \sphinxcode{\sphinxupquote{Chombo3\_}} are application code examples.
These examples require the user to install additional third\sphinxhyphen{}party software.

\sphinxAtStartPar
To run the EBGeometry examples, navigate to e.g. \sphinxcode{\sphinxupquote{Examples/EBGeometry\_DCEL}} and compile and run the application code as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
g++ \PYGZhy{}O3 \PYGZhy{}std\PYG{o}{=}c++14 main.cpp
./a.out porsche.ply
\end{sphinxVerbatim}

\sphinxAtStartPar
This will read \sphinxcode{\sphinxupquote{porsche.ply}} (stored under \sphinxcode{\sphinxupquote{Examples/PLY}}) and create a signed distance function from it.


\section{Features}
\label{\detokenize{Introduction:features}}
\sphinxAtStartPar
The basic features of EBGeometry are as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Representation of water\sphinxhyphen{}tight surface grids as signed distance fields.
EBGeometry uses a doubly\sphinxhyphen{}connected edge list (DCEL) representation of the mesh.

\item {} 
\sphinxAtStartPar
Various analytic distance functions.

\item {} 
\sphinxAtStartPar
Bounding volume hierarchies (BVHs) for use as acceleration structures.
The BVHs can be represented in full or compact (i.e., linearized) forms.

\item {} 
\sphinxAtStartPar
Use of metaprogramming, which exists e.g. in order to permit higher\sphinxhyphen{}order trees and flexibility in BVH partitioning.

\item {} 
\sphinxAtStartPar
Examples of how to couple EBGeometry to AMReX and Chombo.

\end{itemize}


\chapter{Concepts}
\label{\detokenize{index:concepts}}
\sphinxstepscope


\section{Signed distance fields}
\label{\detokenize{Concepts:signed-distance-fields}}\label{\detokenize{Concepts:chap-concepts}}\label{\detokenize{Concepts::doc}}
\sphinxAtStartPar
The signed distance function is defined as a function \(S: \mathbb{R}^3 \rightarrow \mathbb{R}\), and returns the \sphinxstyleemphasis{signed distance} to the object.
The signed distance function has the additional property:
\begin{equation}\label{equation:Concepts:Eikonal}
\begin{split}\left|\nabla S(\mathbf{x})\right| = 1 \quad\textrm{everywhere}.\end{split}
\end{equation}
\sphinxAtStartPar
Note that the normal vector is always
\begin{equation*}
\begin{split}\mathbf{n} = \nabla S\left(\mathbf{x}\right).\end{split}
\end{equation*}
\sphinxAtStartPar
In EBGeometry we use the following convention:
\begin{equation*}
\begin{split}S(\mathbf{x}) =
\begin{cases}
> 0, & \textrm{for points outside the object}, \\
< 0, & \textrm{for points inside the object},
\end{cases}\end{split}
\end{equation*}
\sphinxAtStartPar
which means that the normal vector \(\mathbf{n}\) points away from the object.

\sphinxAtStartPar
Signed distance functions are also \sphinxstyleemphasis{implicit functions} (but the reverse statement is not true).
For example, the signed distance function for a sphere with center \(\mathbf{x}_0\) and radius \(R\) can be written
\begin{equation*}
\begin{split}S_{\textrm{sph}}\left(\mathbf{x}\right) = \left|\mathbf{x} - \mathbf{x}_0\right| - R.\end{split}
\end{equation*}
\sphinxAtStartPar
An example of an implicit function for the same sphere is
\begin{equation*}
\begin{split}I_{\textrm{sph}}\left(\mathbf{x}\right) = \left|\mathbf{x} - \mathbf{x}_0\right|^2 - R^2.\end{split}
\end{equation*}
\sphinxAtStartPar
An important difference between these is the Eikonal property in Eq. \ref{equation:Concepts:Eikonal}, ensuring that the signed distance function always returns the exact distance to the object.


\section{Transformations}
\label{\detokenize{Concepts:transformations}}
\sphinxAtStartPar
Signed distance functions retain the Eikonal property for the following set of transformations:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Rotations.

\item {} 
\sphinxAtStartPar
Translations.

\end{itemize}


\section{Unions}
\label{\detokenize{Concepts:unions}}
\sphinxAtStartPar
Unions of signed distance fields are also signed distance fields \sphinxstyleemphasis{provided that the objects do not intersect or touch}.
For overlapping objects the signed distance function is not well\sphinxhyphen{}defined (since the interior and exterior are not well\sphinxhyphen{}defined).

\sphinxAtStartPar
For non\sphinxhyphen{}overlapping objects represented as signed distance fields \(\left(S_1\left(\mathbf{x}\right), S_2\left(\mathbf{x}\right), \ldots\right)\), the composite signed distance field is
\begin{equation*}
\begin{split}S\left(\mathbf{x}\right) = S_k\left(\mathbf{x}\right),\end{split}
\end{equation*}
\sphinxAtStartPar
where \(k\) is index of the closest object (which is found by evaluating \(\left|S_i\left(\mathbf{x}\right)\right|\).

\sphinxstepscope


\section{DCEL mesh structure}
\label{\detokenize{DCEL:dcel-mesh-structure}}\label{\detokenize{DCEL:chap-dcel}}\label{\detokenize{DCEL::doc}}

\subsection{Basic concept}
\label{\detokenize{DCEL:basic-concept}}
\sphinxAtStartPar
EBGeometry uses a doubly\sphinxhyphen{}connected edge list (DCEL) structure for storing surface meshes.
The DCEL structures consist of the following objects:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Planar polygons (facets).

\item {} 
\sphinxAtStartPar
Half\sphinxhyphen{}edges.

\item {} 
\sphinxAtStartPar
Vertices.

\end{itemize}

\sphinxAtStartPar
As shown in \hyperref[\detokenize{DCEL:fig-dcel}]{Fig.\@ \ref{\detokenize{DCEL:fig-dcel}}}, the half\sphinxhyphen{}edge is the most important data structure.
Half\sphinxhyphen{}edges circulate the inside of the facet, with pointer\sphinxhyphen{}access to the previous and next half\sphinxhyphen{}edge.
A half\sphinxhyphen{}edge also stores a reference to it’s starting vertex, as well as a reference to it’s pair\sphinxhyphen{}edge.
From the DCEL structure we can easily obtain all edges or vertices belonging to a single facet, and also “jump” to a neighboring facet by fetching the pair edge.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=480\sphinxpxdimen]{{DCEL}.png}
\caption{DCEL mesh structure. Each half\sphinxhyphen{}edge stores references to previous/next half\sphinxhyphen{}edges, the pair edge, and the starting vertex.
Vertices store a coordinate as well as a reference to one of the outgoing half\sphinxhyphen{}edges.}\label{\detokenize{DCEL:id2}}\label{\detokenize{DCEL:fig-dcel}}\end{figure}

\sphinxAtStartPar
In EBGeometry the half\sphinxhyphen{}edge data structure is implemented in it’s own namespace \sphinxcode{\sphinxupquote{EBGeometry::Dcel}}.
This is a comparatively standard implementation of the DCEL structure, supplemented by functions that permit signed distance computations to various features on such a mesh.

\begin{sphinxadmonition}{important}{Important:}
\sphinxAtStartPar
A signed distance field requires a \sphinxstyleemphasis{watertight and orientable} surface mesh.
If the surface mesh consists of holes or flipped facets, the signed distance function does not exist.
\end{sphinxadmonition}


\subsection{Signed distance}
\label{\detokenize{DCEL:signed-distance}}
\sphinxAtStartPar
When computing the signed distance function, the closest point on the surface mesh can be one of the vertices, (half\sphinxhyphen{}) edges, or faces, see \hyperref[\detokenize{DCEL:fig-polygonprojection}]{Fig.\@ \ref{\detokenize{DCEL:fig-polygonprojection}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=240\sphinxpxdimen]{{PolygonProjection}.png}
\caption{Possible closest\sphinxhyphen{}feature cases after projecting a point \(\mathbf{x}\) to the plane of a polygon face.}\label{\detokenize{DCEL:id3}}\label{\detokenize{DCEL:fig-polygonprojection}}\end{figure}

\sphinxAtStartPar
It is therefore necessary to distinguish between three cases:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Facet/Polygon face}.

\sphinxAtStartPar
When computing the distance from a point \(\mathbf{x}\) to the polygon face we first determine if the projection of \(\mathbf{x}\) to the face’s plane lies inside or outside the face.
This is more involved than one might think, and it is done by first computing the two\sphinxhyphen{}dimensional projection of the polygon face, ignoring one of the coordinates.
Next, we determine, using 2D algorithms, if the projected point lies inside the embedded 2D representation of the polygon face.
Various algorithms for this are available, such as computing the winding number, the crossing number, or the subtended angle between the projected point and the 2D polygon.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
EBGeometry uses the crossing number algorithm by default.
\end{sphinxadmonition}

\sphinxAtStartPar
If the point projects to the inside of the face, the signed distance is just \(d = \mathbf{n}_f\cdot\left(\mathbf{x} - \mathbf{x}_f\right)\) where \(\mathbf{n}_f\) is the face normal and \(\mathbf{x}_f\) is a point on the face plane (e.g., a vertex).
If the point projects to \sphinxstyleemphasis{outside} the polygon face, the closest feature is either an edge or a vertex.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Edge}.

\sphinxAtStartPar
When computing the signed distance to an edge, the edge is parametrized as \(\mathbf{e}(t) = \mathbf{x}_0 + \left(\mathbf{x}_1 - \mathbf{x}_0\right)t\), where \(\mathbf{x}_0\) and \(\mathbf{x}_1\) are the starting and ending vertex coordinates.
The point \(\mathbf{x}\) is projected to this line, and if the projection yields \(t^\prime \in [0,1]\) then the edge is the closest point.
In that case the signed distance is the projected distance and the sign is given by the sign of \(\mathbf{n}_e\cdot\left(\mathbf{x} - \mathbf{x}_0\right)\) where \(\mathbf{n}_e\) is the pseudonormal vector of the edge.
Otherwise, the closest point is one of the vertices.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Vertex}.

\sphinxAtStartPar
If the closest point is a vertex then the signed distance is simply \(\mathbf{n}_v\cdot\left(\mathbf{x}-\mathbf{x}_v\right)\) where \(\mathbf{n}_v\) is the vertex pseudonormal and \(\mathbf{x}_v\) is the vertex position.

\end{enumerate}


\subsection{Normal vectors}
\label{\detokenize{DCEL:normal-vectors}}\label{\detokenize{DCEL:chap-normaldcel}}
\sphinxAtStartPar
The normal vectors for edges \(\mathbf{n}_e\) and vertices \(\mathbf{n}_v\) are, unlike the facet normal, not uniquely defined.
For both edges and vertices we use the pseudonormals from {[}\hyperlink{cite.ZZReferences:id2}{1}{]}:
\begin{equation*}
\begin{split}\mathbf{n}_{e} = \frac{1}{2}\left(\mathbf{n}_{f} + \mathbf{n}_{f^\prime}\right).\end{split}
\end{equation*}
\sphinxAtStartPar
where \(f\) and \(f^\prime\) are the two faces connecting the edge.
The vertex pseudonormal are given by
\begin{equation*}
\begin{split}\mathbf{n}_{v} = \frac{\sum_i\alpha_i\mathbf{n}_{f_i}}{\left|\sum_i\alpha_i\right|},\end{split}
\end{equation*}
\sphinxAtStartPar
where the sum runs over all faces which share \(v\) as a vertex, and where \(\alpha_i\) is the subtended angle of the face \(f_i\), see \hyperref[\detokenize{DCEL:fig-pseudonormal}]{Fig.\@ \ref{\detokenize{DCEL:fig-pseudonormal}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=240\sphinxpxdimen]{{Pseudonormal}.png}
\caption{Edge and vertex pseudonormals.}\label{\detokenize{DCEL:id4}}\label{\detokenize{DCEL:fig-pseudonormal}}\end{figure}

\sphinxstepscope


\section{Bounding volume hierarchies}
\label{\detokenize{BVH:bounding-volume-hierarchies}}\label{\detokenize{BVH:chap-bvh}}\label{\detokenize{BVH::doc}}

\subsection{Basic concept}
\label{\detokenize{BVH:basic-concept}}
\sphinxAtStartPar
Bounding Volume Hierarchies (BVHs) are comparatively simple data structures that can accelerate closest\sphinxhyphen{}point searches by orders of magnitude.
BVHs are tree structures where the regular nodes are bounding volumes that enclose all geometric primitives (e.g. polygon faces) further down in the hierarchy.
This means that every node in a BVH is associated with a \sphinxstyleemphasis{bounding volume}.
The bounding volume can, in principle, be any type of volume.
Moreover, there are two types of nodes in a BVH:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Regular nodes.} These do not contain any of the primitives/objects.
They are also called interior nodes, and store references to their child nodes.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Leaf nodes.} These lie at the bottom of the BVH tree and each of them contain a subset of the geometric primitives.

\end{itemize}

\sphinxAtStartPar
\hyperref[\detokenize{BVH:fig-trianglesbvh}]{Fig.\@ \ref{\detokenize{BVH:fig-trianglesbvh}}} shows a concept of BVH partitioning of a set of triangles.
Here, \(P\) is a regular node whose bounding volume encloses all geometric primitives in it’s subtree.
It’s bounding volume, an axis\sphinxhyphen{}aligned bounding box or AABB for short, is illustrated by a dashed rectangle.
The interior node \(P\) stores references to the leaf nodes \(L\) and \(R\).
As shown in \hyperref[\detokenize{BVH:fig-trianglesbvh}]{Fig.\@ \ref{\detokenize{BVH:fig-trianglesbvh}}}, \(L\) contains 5 triangles enclosed by another AABB.
The other child node \(R\) contains 6 triangles that are also enclosed by an AABB.
Note that the bounding volume for \(P\) encloses the bounding volumes of \(L\) and \(R\) and that the bounding volumes for \(L\) and \(R\) contain a small overlap.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=480\sphinxpxdimen]{{TrianglesBVH}.png}
\caption{Example of BVH partitioning for enclosing triangles. The regular node \(P\) contains two leaf nodes \(L\) and \(R\) which contain the primitives (triangles).}\label{\detokenize{BVH:id1}}\label{\detokenize{BVH:fig-trianglesbvh}}\end{figure}

\sphinxAtStartPar
There is no fundamental limitation to what type of primitives/objects can be enclosed in BVHs, which makes BVHs useful beyond triangulated data sets.
For example, analytic signed distance functions can also be embedded in BVHs, provided that we can construct a bounding volume that encloses the object.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
EBGeometry limited to binary trees, but supports \(k\) \sphinxhyphen{}ary trees where each regular node has \(k\) children nodes.
\end{sphinxadmonition}


\subsection{Construction}
\label{\detokenize{BVH:construction}}
\sphinxAtStartPar
BVHs have extremely flexible rules regarding their construction.
For example, the child nodes \(L\) and \(R\) in \hyperref[\detokenize{BVH:fig-trianglesbvh}]{Fig.\@ \ref{\detokenize{BVH:fig-trianglesbvh}}} could be partitioned in any number of ways, with the only requirement being that each child node gets at least one triangle.

\sphinxAtStartPar
Although the rules for BVH construction are highly flexible, performant BVHs are completely reliant on having balanced trees with the following heuristic properties:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Tight bounding volumes} that enclose the primitives as tightly as possible.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Minimal overlap} between the bounding volumes.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Balanced}, in the sense that the tree depth does not vary greatly through the tree, and there is approximately the same number of primitives in each leaf node.

\end{itemize}

\sphinxAtStartPar
Construction of a BVH is usually done recursively, from top to bottom (so\sphinxhyphen{}called top\sphinxhyphen{}down construction).
Alternative construction methods also exist, but are not used in EBGeometry.
In this case one can represent the BVH construction of a \(k\) \sphinxhyphen{}ary tree is done through a single function:
\begin{equation}\label{equation:BVH:Partition}
\begin{split}\textrm{Partition}\left(\vec{O}\right): \vec{O} \rightarrow \left(\vec{O}_1, \vec{O}_2, \ldots, \vec{O}_k\right),\end{split}
\end{equation}
\sphinxAtStartPar
where \(\vec{O}\) is an input a list of objects/primitives, which is \sphinxstyleemphasis{partitioned} into \(k\) new list of primitives.
Note that the lists \(\vec{O}_i\) do not contain duplicates, there is a unique set of primitives associated in each new leaf node.
Top\sphinxhyphen{}down construction can thus be illustrated as a recursive procedure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
topDownConstruction(Objects):
   partitionedObjects = Partition(Objects)

   forall p in partitionedObjects:
      child = insertChildNode(newObjects)

      if(enoughPrimitives(child)):
         child.topDownConstruction(child.objects)
\end{sphinxVerbatim}

\sphinxAtStartPar
In practice, the above procedure is supplemented by more sophisticated criteria for terminating the recursion, as well as routines for creating the bounding volumes around the newly inserted nodes.
EBGeometry provides these by letting the top\sphinxhyphen{}down construction calls take polymorphic lambdas as arguments for partitioning, termination, and bounding volume construction.


\subsection{Signed distance function}
\label{\detokenize{BVH:signed-distance-function}}
\sphinxAtStartPar
When computing the signed distance function to objects embedded in a BVH, one takes advantage of the hierarchical embedding of the primitives.
Consider the case in \hyperref[\detokenize{BVH:fig-treepruning}]{Fig.\@ \ref{\detokenize{BVH:fig-treepruning}}}, where the goal of the BVH traversal is to minimize the number of branches and nodes that are visited.
For the traversal algorithm we consider the following steps:
\begin{itemize}
\item {} 
\sphinxAtStartPar
When descending from node \(P\) we determine that we first investigate the left subtree (node \(A\)) since its bounding volume is closer than the bounding volumes for the other subtree.
The other subtree will is investigated after we have recursed to the bottom of the \(A\) subtree.

\item {} 
\sphinxAtStartPar
Since \(A\) is a leaf node, we find the signed distance from \(\mathbf{x}\) to the primitives in \(A\).
This requires us to iterate over all the triangles in \(A\).

\item {} 
\sphinxAtStartPar
When moving back to \(P\), we find that the distance to the primitives in \(A\) is shorter than the distance from \(\mathbf{x}\) to the bounding volume that encloses nodes \(B\) and \(C\).
This immediately permits us to prune the entire subtree containing \(B\) and \(C\).

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=480\sphinxpxdimen]{{TreePruning}.png}
\caption{Example of BVH tree pruning.}\label{\detokenize{BVH:id2}}\label{\detokenize{BVH:fig-treepruning}}\end{figure}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Note that all BVH traversal algorithms become inefficient when the primitives are all at approximately the same distance from the query point.
For example, it is necessary to traverse almost the entire tree when one tries to compute the signed distance at the origin of a tessellated sphere.
\end{sphinxadmonition}


\chapter{Implementation}
\label{\detokenize{index:implementation}}
\sphinxstepscope


\section{Overview}
\label{\detokenize{Implementation:overview}}\label{\detokenize{Implementation:chap-implementation}}\label{\detokenize{Implementation::doc}}
\sphinxAtStartPar
Here, we consider the basic EBGeometry API.
EBGeometry is a header\sphinxhyphen{}only library, implemented under it’s own namespace \sphinxcode{\sphinxupquote{EBGeometry}}.
Various major components, like BVHs and DCEL, are implemented under namespaces \sphinxcode{\sphinxupquote{EBGeometry::BVH}} and \sphinxcode{\sphinxupquote{EBGeometry::DCEL}}.
Below, we consider a brief introduction to the API and implementation details of EBGeometry.

\sphinxstepscope


\section{Vector types}
\label{\detokenize{ImplemVec:vector-types}}\label{\detokenize{ImplemVec:chap-vector}}\label{\detokenize{ImplemVec::doc}}
\sphinxAtStartPar
EBGeometry runs it’s own vector types \sphinxcode{\sphinxupquote{Vec2T}} and \sphinxcode{\sphinxupquote{Vec3T}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Vec2T}} is a two\sphinxhyphen{}dimensional Cartesian vector.
It is templated as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n}{EBGeometry} \PYG{p}{\PYGZob{}}
   \PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
   \PYG{k}{class} \PYG{n+nc}{Vec2T} \PYG{p}{\PYGZob{}}
   \PYG{k}{public}\PYG{o}{:}
      \PYG{n}{T} \PYG{n}{x}\PYG{p}{;} \PYG{c+c1}{// First component.}
      \PYG{n}{T} \PYG{n}{y}\PYG{p}{;} \PYG{c+c1}{// Second component.}
   \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Most of EBGeometry is written as three\sphinxhyphen{}dimensional code, but \sphinxcode{\sphinxupquote{Vec2T}} is needed for DCEL functionality when determining if a point projects onto the interior or exterior of a planar polygon, see {\hyperref[\detokenize{DCEL:chap-dcel}]{\sphinxcrossref{\DUrole{std,std-ref}{DCEL mesh structure}}}}.
\sphinxcode{\sphinxupquote{Vec2T}} has “most” common arithmetic operators like the dot product, length, multiplication operators and so on.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Vec3T}} is a three\sphinxhyphen{}dimensional Cartesian vector type with precision \sphinxcode{\sphinxupquote{T}}.
It is templated as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n}{EBGeometry} \PYG{p}{\PYGZob{}}
   \PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
   \PYG{k}{class} \PYG{n+nc}{Vec3T} \PYG{p}{\PYGZob{}}
   \PYG{k}{public}\PYG{o}{:}
      \PYG{n}{T}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{n}{x}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Like \sphinxcode{\sphinxupquote{Vec2T}}, \sphinxcode{\sphinxupquote{Vec3T}} has numerous routines for performing most vector\sphinxhyphen{}related operations like addition, subtraction, dot products and so on.

\sphinxstepscope


\section{Bounding volume hierarchy}
\label{\detokenize{ImplemBVH:bounding-volume-hierarchy}}\label{\detokenize{ImplemBVH:chap-implembvh}}\label{\detokenize{ImplemBVH::doc}}
\sphinxAtStartPar
The BVH functionality is encapsulated in the namespace \sphinxcode{\sphinxupquote{EBGeometry::BVH}}.
For the full API, see \sphinxhref{doxygen/html/namespaceBVH.html}{the doxygen API}.
There are two types of BVHs supported.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Direct BVHs} where the nodes are stored in build order and contain references to their children, and the leaf holds primitives.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Compact BVHs} where the nodes are stored in depth\sphinxhyphen{}first order and contain index offsets to children and primitives.

\end{itemize}

\sphinxAtStartPar
The direct BVH is encapsulated by a class

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{P}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BV}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{K}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{NodeT}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The above template parameters are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{T}} Floating\sphinxhyphen{}point precision.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P}} Primitive type to be partitioned.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BV}} Bounding volume type.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{K}} BVH degree. \sphinxcode{\sphinxupquote{K=2}} will yield a binary tree, \sphinxcode{\sphinxupquote{K=3}} yields a tertiary tree and so on.

\end{itemize}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NodeT}} describes regular and leaf nodes in the BVH, and has member functions for setting primitives, bounding volumes, and so on.
Importantly, \sphinxcode{\sphinxupquote{NodeT}} is the BVH builder node, i.e. it is the class through which we recursively build the BVH, see {\hyperref[\detokenize{ImplemBVH:chap-bvhconstruction}]{\sphinxcrossref{\DUrole{std,std-ref}{Construction}}}}.
The compact BVH is discussed below in {\hyperref[\detokenize{ImplemBVH:chap-linearbvh}]{\sphinxcrossref{\DUrole{std,std-ref}{Compact form}}}}.


\subsection{Template constraints}
\label{\detokenize{ImplemBVH:template-constraints}}
\sphinxAtStartPar
The template parameter \sphinxcode{\sphinxupquote{T}} must be a valid C++ floating\sphinxhyphen{}point type (e.g. \sphinxcode{\sphinxupquote{float}} or \sphinxcode{\sphinxupquote{double}}) and the tree degree must be \(K \geq 2\).
The primitive type \sphinxcode{\sphinxupquote{P}} must have the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A signed distance function \sphinxcode{\sphinxupquote{T P::signedDistance(const Vec3\& x) const}}.

\end{itemize}

\sphinxAtStartPar
The bounding volume type \sphinxcode{\sphinxupquote{BV}} must obey the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A default constructor \sphinxcode{\sphinxupquote{BV()}}.

\item {} 
\sphinxAtStartPar
A constructor \sphinxcode{\sphinxupquote{BV(const std::vector\textless{}BV\textgreater{}\&)}} which constructs a bounding volume guaranteed to enclose other bounding volumes.

\item {} 
\sphinxAtStartPar
A function \sphinxcode{\sphinxupquote{T getDistance(const Vec3T\textless{}T\textgreater{}\& x) const}} which returns a positive distance if point \sphinxcode{\sphinxupquote{x}} is outside the bounding volume and zero if \sphinxcode{\sphinxupquote{x}} is inside the bounding volume.

\end{itemize}


\subsection{Signed distance}
\label{\detokenize{ImplemBVH:signed-distance}}
\sphinxAtStartPar
For getting the signed distance, \sphinxcode{\sphinxupquote{NodeT}} has provide the following functions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kr}{inline} \PYG{n}{T}
\PYG{n+nf}{signedDistance}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}point}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept} \PYG{k}{override}\PYG{p}{;}

\PYG{k+kr}{inline} \PYG{n}{T}
\PYG{n+nf}{signedDistance}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}point}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Prune} \PYG{n}{a\PYGZus{}pruning}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first version simply calls the other version with a stack\sphinxhyphen{}based pruning algorithm for the tree traversal.


\subsection{Template constraints}
\label{\detokenize{ImplemBVH:chap-bvhconstraints}}\label{\detokenize{ImplemBVH:id1}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The primitive type \sphinxcode{\sphinxupquote{P}} must have the following function:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{T signedDistance(const Vec3T\textless{}T\textgreater{}\& x)}}, which returns the signed distance to the primitive.

\end{itemize}

\item {} 
\sphinxAtStartPar
The bounding volume type \sphinxcode{\sphinxupquote{BV}} must have the following functions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{T getDistance(const Vec3T\textless{}T\textgreater{}\& x)}} which returns the distance from the point \sphinxcode{\sphinxupquote{x}} to the bounding volume.
Note that if \sphinxcode{\sphinxupquote{x}} lies within the bounding volume, the function should return a value of zero.

\item {} 
\sphinxAtStartPar
A constructor \sphinxcode{\sphinxupquote{BV(const std::vector\textless{}BV\textgreater{}\& a\_otherBVs)}} that permit creation of a bounding volume that encloses other bounding volumes of the same type.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{K}} should be greater or equal to 2.

\item {} 
\sphinxAtStartPar
Currently, we do not support variable\sphinxhyphen{}sized trees (i.e., mixing branching ratios).

\end{itemize}

\sphinxAtStartPar
Note that the above constraints apply only to the BVH itself.
Partitioning functions (which are, in principle, supplied by the user) may impose extra constraints.

\begin{sphinxadmonition}{important}{Important:}
\sphinxAtStartPar
EBGeometry’s BVH implementations fulfill their own template requirements on the primitive type \sphinxcode{\sphinxupquote{P}}.
This means that objects that are themselves described by BVHs (such as triangulations) can be embedded in another BVH, permitting BVH\sphinxhyphen{}of\sphinxhyphen{}BVH type of scenes.
\end{sphinxadmonition}


\subsection{Bounding volumes}
\label{\detokenize{ImplemBVH:bounding-volumes}}
\sphinxAtStartPar
EBGeometry supports the following bounding volumes, which are defined in \sphinxcode{\sphinxupquote{EBGeometry\_BoundingVolumes.hpp\textasciigrave{}}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{BoundingSphere}, templated as \sphinxcode{\sphinxupquote{EBGeometry::BoundingVolumes::BoundingSphereT\textless{}T\textgreater{}}} and describes a bounding sphere.
Various constructors are available.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Axis\sphinxhyphen{}aligned bounding box}, or AABB for short.
This is templated as \sphinxcode{\sphinxupquote{EBGeometry::BoundingVolumes::AABBT\textless{}T\textgreater{}}}.

\end{itemize}

\sphinxAtStartPar
For full API details, see \sphinxhref{doxygen/html/namespaceBoundingVolumes.html}{the doxygen API}.


\subsection{Construction}
\label{\detokenize{ImplemBVH:construction}}\label{\detokenize{ImplemBVH:chap-bvhconstruction}}
\sphinxAtStartPar
Constructing a BVH is done by
\begin{itemize}
\item {} 
\sphinxAtStartPar
Creating a root node and providing it with the geometric primitives.

\item {} 
\sphinxAtStartPar
Partitioning the BVH by providing a partitioning function.

\end{itemize}

\sphinxAtStartPar
The first step is usually a matter of simply constructing the root node using the following constructor:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{P}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BV}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{K}\PYG{o}{\PYGZgt{}}
\PYG{n}{NodeT}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}primitives}\PYG{p}{)}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
That is, the constructor takes a list of primitives to be put in the node.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n}{T}    \PYG{o}{=} \PYG{k+kt}{float}\PYG{p}{;}
\PYG{k}{using} \PYG{n}{Node} \PYG{o}{=} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BVH}\PYG{o}{:}\PYG{o}{:}\PYG{n}{NodeT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{;}

\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{MyPrimitives}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{primitives}\PYG{p}{;}

\PYG{k}{auto} \PYG{n}{root} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{make\PYGZus{}shared}\PYG{o}{\PYGZlt{}}\PYG{n}{Node}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{primitives}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The second step is to recursively build the BVH, which is done through the function

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{P}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BV}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{K}\PYG{o}{\PYGZgt{}}
\PYG{k}{using} \PYG{n}{StopFunctionT} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{function}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{p}{(}\PYG{k}{const} \PYG{n}{NodeT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{P}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}node}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{p}{;}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{P}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BV}\PYG{o}{\PYGZgt{}}
\PYG{k}{using} \PYG{n}{BVConstructorT} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{function}\PYG{o}{\PYGZlt{}}\PYG{n}{BV}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}primitive}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{p}{;}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{P}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{K}\PYG{o}{\PYGZgt{}}
\PYG{k}{using} \PYG{n}{PartitionerT} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{function}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{array}\PYG{o}{\PYGZlt{}}\PYG{n}{PrimitiveListT}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{k}{const} \PYG{n}{PrimitiveListT}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}primitives}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{p}{;}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{P}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BV}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{K}\PYG{o}{\PYGZgt{}}
\PYG{n}{NodeT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{P}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{topDownSortAndPartitionPrimitives}\PYG{p}{(}\PYG{k}{const} \PYG{n}{BVConstructorT}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{p}{,} \PYG{n}{BV}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
                                                      \PYG{k}{const} \PYG{n}{PartitionerT}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
                                                      \PYG{k}{const} \PYG{n}{StopFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{P}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Although seemingly complicated, the input arguments are simply polymorphic functions of the type indicated above, and have the following responsibilities:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{StopFunctionT}} simply takes a \sphinxcode{\sphinxupquote{NodeT}} as input argument and determines if the node should be partitioned further.
A basic implementation which terminates the recursion when the leaf node has reached the minimum number of primitives is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BVH}\PYG{o}{:}\PYG{o}{:}\PYG{n}{StopFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{P}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}} \PYG{n}{stopFunc} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const} \PYG{n}{NodeT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{P}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}node}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kt}{bool} \PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{n}{a\PYGZus{}node}\PYG{p}{.}\PYG{n}{getNumPrimitives}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{K}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will terminate the partitioning when the node has less than \sphinxcode{\sphinxupquote{K}} primitives (in which case it \sphinxstyleemphasis{can’t} be partitioned further).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BVConstructorT}} takes a single primitive (or strictly speaking a pointer to the primitive) and returns a bounding volume that encloses it.
For example, if the primitives \sphinxcode{\sphinxupquote{P}} are signed distance function spheres (see {\hyperref[\detokenize{ImplemSDF:chap-analyticsdf}]{\sphinxcrossref{\DUrole{std,std-ref}{Analytic functions}}}}), the BV constructor can be implemented
with AABB bounding volumes as;

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n}{T}      \PYG{o}{=} \PYG{k+kt}{float}\PYG{p}{;}
\PYG{k}{using} \PYG{n}{Vec3}   \PYG{o}{=} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
\PYG{k}{using} \PYG{n}{AABB}   \PYG{o}{=} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BoundingVolumes}\PYG{o}{:}\PYG{o}{:}\PYG{n}{AABBT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
\PYG{k}{using} \PYG{n}{Sphere} \PYG{o}{=} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SphereSDF}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{;}

\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BVH}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BVConstructor}\PYG{o}{\PYGZlt{}}\PYG{n}{SDF}\PYG{p}{,} \PYG{n}{AABB}\PYG{o}{\PYGZgt{}} \PYG{n}{bvConstructor} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{SDF}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}sdf}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{const} \PYG{n}{Sphere}\PYG{o}{\PYGZam{}} \PYG{n}{sph} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{Sphere}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{o}{*}\PYG{n}{a\PYGZus{}sdf}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{const} \PYG{n}{Vec3}\PYG{o}{\PYGZam{}} \PYG{n}{sphereCenter} \PYG{o}{=} \PYG{n}{sph}\PYG{p}{.}\PYG{n}{getCenter}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}}    \PYG{n}{sphereRadius} \PYG{o}{=} \PYG{n}{sph}\PYG{p}{.}\PYG{n}{getRadius}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{const} \PYG{n}{Vec3}  \PYG{n}{lo} \PYG{o}{=} \PYG{n}{sphereCenter} \PYG{o}{\PYGZhy{}} \PYG{n}{r}\PYG{o}{*}\PYG{n}{Vec3}\PYG{o}{:}\PYG{o}{:}\PYG{n}{one}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{const} \PYG{n}{Vec3}  \PYG{n}{hi} \PYG{o}{=} \PYG{n}{sphereCenter} \PYG{o}{+} \PYG{n}{r}\PYG{o}{*}\PYG{n}{Vec3}\PYG{o}{:}\PYG{o}{:}\PYG{n}{one}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{return} \PYG{n+nf}{AABB}\PYG{p}{(}\PYG{n}{lo}\PYG{p}{,} \PYG{n}{hi}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PartitionerT}} is the partitioner function when splitting a leaf node into \sphinxcode{\sphinxupquote{K}} new leaves.
The function takes an list of primitives which it partitions into \sphinxcode{\sphinxupquote{K}} new list of primitives, i.e. it encapsulates Eq. \ref{equation:BVH:Partition}.
As an example, we include a partitioner that is provided for integrating BVH and DCEL functionality.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BV}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{K}\PYG{o}{\PYGZgt{}}
\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BVH}\PYG{o}{:}\PYG{o}{:}\PYG{n}{PartitionerT}\PYG{o}{\PYGZlt{}}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FaceT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}} \PYG{n}{chunkPartitioner} \PYG{o}{=}
\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const} \PYG{n}{PrimitiveList}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}primitives}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{array}\PYG{o}{\PYGZlt{}}\PYG{n}{PrimitiveList}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}} \PYG{p}{\PYGZob{}}
  \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{n}{lo} \PYG{o}{=} \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{n}{hi} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k}{const} \PYG{k}{auto}\PYG{o}{\PYGZam{}} \PYG{n+nl}{p} \PYG{p}{:} \PYG{n}{a\PYGZus{}primitives}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{lo} \PYG{o}{=} \PYG{n}{min}\PYG{p}{(}\PYG{n}{lo}\PYG{p}{,} \PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getCentroid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{hi} \PYG{o}{=} \PYG{n}{max}\PYG{p}{(}\PYG{n}{hi}\PYG{p}{,} \PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getCentroid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k}{const} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{splitDir} \PYG{o}{=} \PYG{p}{(}\PYG{n}{hi} \PYG{o}{\PYGZhy{}} \PYG{n}{lo}\PYG{p}{)}\PYG{p}{.}\PYG{n}{maxDir}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}

  \PYG{c+c1}{// Sort the primitives along the above coordinate direction.}
  \PYG{n}{PrimitiveList}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{n}{sortedPrimitives}\PYG{p}{(}\PYG{n}{a\PYGZus{}primitives}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{sort}\PYG{p}{(}
    \PYG{n}{sortedPrimitives}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sortedPrimitives}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{[}\PYG{n}{splitDir}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{FaceT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{f1}\PYG{p}{,} \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{FaceT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{f2}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kt}{bool} \PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{f1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getCentroid}\PYG{p}{(}\PYG{n}{splitDir}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{f2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getCentroid}\PYG{p}{(}\PYG{n}{splitDir}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{return} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{equalCounts}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sortedPrimitives}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the above, we are taking a list of DCEL facets in the input argument (\sphinxcode{\sphinxupquote{PrimitiveList\textless{}T\textgreater{}}} expands to \sphinxcode{\sphinxupquote{std::vector\textless{}std::shared\_ptr\textless{}const FaceT\textless{}T\textgreater{} \textgreater{}}}).
We then compute the centroid locations of each facet and figure out along which coordinate axis we partition the objects (called \sphinxcode{\sphinxupquote{splitDir}} above).
The input primitives are then sorted based on the facet centroid locations in the \sphinxcode{\sphinxupquote{splitDir}} direction, and they are partitioned into \sphinxcode{\sphinxupquote{K}} almost\sphinxhyphen{}equal chunks.
These partitions are returned and become primitives in the new leaf nodes.

\sphinxAtStartPar
There is also an example of the same type of partitioning for the BVH\sphinxhyphen{}accelerated union, see \sphinxhref{doxygen/html/classUnionBVH.html}{UnionBVH}

\end{itemize}

\sphinxAtStartPar
In general, users are free to construct their BVHs in their own way if they choose.
For the most part this will include the construction of their own bounding volumes and/or partitioners.


\subsection{Compact form}
\label{\detokenize{ImplemBVH:compact-form}}\label{\detokenize{ImplemBVH:chap-linearbvh}}
\sphinxAtStartPar
In addition to the standard BVH node \sphinxcode{\sphinxupquote{NodeT\textless{}T, P, BV, K\textgreater{}}}, EBGeometry provides a more compact formulation of the BVH hierarchy where the nodes are stored in depth\sphinxhyphen{}first order.
The “linearized” BVH can be automatically constructed from the standard BVH but not vice versa.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=240\sphinxpxdimen]{{CompactBVH}.png}
\caption{Compact BVH representation.
The original BVH is traversed from top\sphinxhyphen{}to\sphinxhyphen{}bottom along the branches and laid out in linear memory.
Each interior node gets a reference (index offset) to their children nodes.}\label{\detokenize{ImplemBVH:id3}}\end{figure}

\sphinxAtStartPar
The rationale for reorganizing the BVH in compact form is it’s tighter memory footprint and depth\sphinxhyphen{}first ordering which allows more efficient traversal downwards in the BVH tree.
To encapsulate the compact BVH we provide two classes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LinearNodeT}} which encapsulates a node, but rather than storing the primitives and pointers to child nodes it stores offsets along the 1D arrays.
Just like \sphinxcode{\sphinxupquote{NodeT}} the class is templated:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{P}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BV}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{K}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{LinearNodeT}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LinearNodeT}} has a smaller memory footprint and should fit in one CPU word in floating\sphinxhyphen{}point precision and two CPU words in double point precision.
The performance benefits of further memory alignment have not been investigated.

\sphinxAtStartPar
Note that \sphinxcode{\sphinxupquote{LinearNodeT}} only stores offsets to child nodes and primitives, which are assumed to be stored (somewhere) as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{LinearNodeT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{P}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{linearNodes}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{P}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{primitives}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Thus, for a given node we can check if it is a leaf node (\sphinxcode{\sphinxupquote{m\_numPrimitives \textgreater{} 0}}) and if it is we can get the children through the \sphinxcode{\sphinxupquote{m\_childOffsets}} array.
Primitives can likewise be obtained; they are stored in the primitives array from index \sphinxcode{\sphinxupquote{m\_primitivesOffset}} to \sphinxcode{\sphinxupquote{m\_primitivesOffset + m\_numPrimities \sphinxhyphen{} 1}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LinearBVH}} which stores the compact BVH \sphinxstyleemphasis{and} primitives as class members.
That is, \sphinxcode{\sphinxupquote{LinearBVH}} contains the nodes and primitives as class members.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{P}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BV}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{K}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{LinearBVH} \PYG{o}{:} \PYG{k}{public} \PYG{n}{SignedDistanceFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}

\PYG{k}{protected}\PYG{o}{:}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{LinearNodeT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{P}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m\PYGZus{}linearNodes}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m\PYGZus{}primitives}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The root node is, of course, found at the front of the \sphinxcode{\sphinxupquote{m\_linearNodes}} vector.
Note that the list of primitives \sphinxcode{\sphinxupquote{m\_primitives}} is stored in the order in which the leaf nodes appear in \sphinxcode{\sphinxupquote{m\_linearNodes}}.

\end{itemize}

\sphinxAtStartPar
Constructing the compact BVH is simply a matter of letting \sphinxcode{\sphinxupquote{NodeT}} aggregate the nodes and primitives into arrays, and return a \sphinxcode{\sphinxupquote{LinearBVH}}.
This is done by calling the \sphinxcode{\sphinxupquote{NodeT}} member function \sphinxcode{\sphinxupquote{flattenTree()}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{P}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BV}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{K}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{NodeT} \PYG{o}{:} \PYG{k}{public} \PYG{n}{SignedDistanceFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}

  \PYG{k+kr}{inline} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{LinearBVH}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{P}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}
  \PYG{n}{flattenTree}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
which returns a pointer to a \sphinxcode{\sphinxupquote{LinearBVH}}.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Assume that we have built the conventional BVH already}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BVH}\PYG{o}{:}\PYG{o}{:}\PYG{n}{NodeT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{P}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{builderBVH}\PYG{p}{;}

\PYG{c+c1}{// Flatten the tree.}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{LinearBVH}\PYG{o}{\PYGZgt{}} \PYG{n}{compactBVH} \PYG{o}{=} \PYG{n}{builderBVH}\PYG{p}{.}\PYG{n}{flattenTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Release the original BVH.}
\PYG{n}{builderBVH} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
When calling \sphinxcode{\sphinxupquote{flattenTree}}, the original BVH tree is \sphinxstyleemphasis{not} destroyed.
To release the memory, deallocate the original BVH tree.
E.g., the set pointer to the root node to \sphinxcode{\sphinxupquote{nullptr}} if using a smart pointer.
\end{sphinxadmonition}

\sphinxAtStartPar
Note that the primitives live in \sphinxcode{\sphinxupquote{LinearBVH}} and not \sphinxcode{\sphinxupquote{LinearNodeT}}, and the signed distance function is therefore implemented in the \sphinxcode{\sphinxupquote{LinearBVH}} member function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{P}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BV}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{K}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{LinearBVH} \PYG{o}{:} \PYG{k}{public} \PYG{n}{SignedDistanceFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}

  \PYG{k+kr}{inline} \PYG{n}{T}
  \PYG{n}{signedDistance}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vec3}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}point}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept} \PYG{k}{override}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Signed distance}
\label{\detokenize{ImplemBVH:id2}}
\sphinxAtStartPar
The signed distance can be obtained from both the full BVH storage and the compact BVH storage.
Replicating the code above, we can do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Assume that we have built the conventional BVH already}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BVH}\PYG{o}{:}\PYG{o}{:}\PYG{n}{NodeT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{P}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{fullBVH}\PYG{p}{;}

\PYG{c+c1}{// Flatten the tree.}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BVH}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LinearBVH}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{P}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{compactBVH} \PYG{o}{=} \PYG{n}{fullBVH}\PYG{p}{.}\PYG{n}{flattenTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// These give the same result.}
\PYG{k}{const} \PYG{n}{T} \PYG{n}{s1} \PYG{o}{=} \PYG{n}{fullBVH}   \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{signedDistance}\PYG{p}{(}\PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{zero}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{const} \PYG{n}{T} \PYG{n}{s2} \PYG{o}{=} \PYG{n}{compactBVH}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{signedDistance}\PYG{p}{(}\PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{zero}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We point out that the compact BVH only supports:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Recursive, unordered traversal through the tree.

\item {} 
\sphinxAtStartPar
Recursive, ordered traversal through the tree.

\item {} 
\sphinxAtStartPar
Stack\sphinxhyphen{}based ordered traversal through the tree.

\end{itemize}

\sphinxAtStartPar
Out of these, the ordered traversals (discussed in {\hyperref[\detokenize{BVH:chap-bvh}]{\sphinxcrossref{\DUrole{std,std-ref}{Bounding volume hierarchies}}}}) are faster.

\sphinxAtStartPar
The compact BVH only supports stack\sphinxhyphen{}based ordered traversal (which tends to be faster).

\sphinxstepscope


\section{DCEL}
\label{\detokenize{ImplemDCEL:dcel}}\label{\detokenize{ImplemDCEL:chap-implemdcel}}\label{\detokenize{ImplemDCEL::doc}}
\sphinxAtStartPar
The DCEL functionality exists under the namespace \sphinxcode{\sphinxupquote{EBGeometry::DCEL}} and contains the following functionality:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Fundamental data types} like vertices, half\sphinxhyphen{}edges, polygons, and entire surface grids.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Signed distance functionality} for the above types.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{File parsers for reading files} into DCEL structures.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{BVH functionality} for putting DCEL grids into bounding volume hierarchies.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The DCEL functionality is \sphinxstyleemphasis{not} restricted to triangles, but supports N\sphinxhyphen{}sided polygons.
\end{sphinxadmonition}


\subsection{Classes}
\label{\detokenize{ImplemDCEL:classes}}
\sphinxAtStartPar
The main DCEL functionality (vertices, edges, faces) is provided by the following classes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Vertices} are implemented as a template \sphinxcode{\sphinxupquote{EBGeometry::DCEL::EdgeT}}

\end{itemize}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{VertexT}
\end{sphinxVerbatim}

\sphinxAtStartPar
The DCEL vertex class stores the vertex position, normal vector, and the outgoing half\sphinxhyphen{}edge from the vertex.
Note that the class has member functions for computing the vertex pseudonormal, see {\hyperref[\detokenize{DCEL:chap-normaldcel}]{\sphinxcrossref{\DUrole{std,std-ref}{Normal vectors}}}}.

\sphinxAtStartPar
The full API is given in the doxygen documentation \sphinxhref{doxygen/html/classDCEL\_1\_1VertexT.html}{here}.
\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Edges} are implemented as a template \sphinxcode{\sphinxupquote{EBGeometry::DCEL::EdgeT}}

\end{itemize}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{EdgeT}
\end{sphinxVerbatim}

\sphinxAtStartPar
The half\sphinxhyphen{}edges store a reference to their face, as well as pointers to the previous edge, next edge, pair edge, and starting vertex.
For performance reasons, the edge also stores the length and inverse length of the edge.

\sphinxAtStartPar
The full API is given in the doxygen documentation \sphinxhref{doxygen/html/classDCEL\_1\_1EdgeT.html}{here}.
\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Faces} are implemented as a template \sphinxcode{\sphinxupquote{EBGeometry::DCEL::FaceT}}

\end{itemize}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{FaceT}
\end{sphinxVerbatim}

\sphinxAtStartPar
For performance reasons, a polygon face stores all it’s half\sphinxhyphen{}edges (to avoid iteration when computing the signed distance).
It also stores:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The normal vector.

\item {} 
\sphinxAtStartPar
A 2D embedding of the polygon face.

\item {} 
\sphinxAtStartPar
Centroid position.

\end{itemize}

\sphinxAtStartPar
The normal vector and 2D embedding of the facet exist because the signed distance computation requires them.
The centroid position exists only because BVH partitioners will use it for partitioning the surface mesh.

\sphinxAtStartPar
The full API is given in the doxygen documentation \sphinxhref{doxygen/html/classDCEL\_1\_1FaceT.html}{here}.
\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Mesh} is implemented as a template \sphinxcode{\sphinxupquote{EBGeometry::DCEL::MeshT}}

\end{itemize}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{MeshT}
\end{sphinxVerbatim}

\sphinxAtStartPar
The Mesh stores all the vertices, half\sphinxhyphen{}edges, and faces.
For example, to obtain all the facets one can call \sphinxcode{\sphinxupquote{EBGeometry::DCEL::MeshT\textless{}T\textgreater{}::getFaces()}} which will return all the DCEL faces of the surface mesh.
Typically, the mesh is not created by the user but automatically created when reading the mesh from an input file.

\sphinxAtStartPar
The full API is given in the doxygen documentation \sphinxhref{doxygen/html/classDCEL\_1\_1MeshT.html}{here}.
\end{quote}

\sphinxAtStartPar
All of the above DCEL classes have member functions of the type:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{T} \PYG{n+nf}{signedDistance}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}point}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept}\PYG{p}{;}
\PYG{n}{T} \PYG{n+nf}{unsignedDistance2}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}point}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Thus, they fulfill the template requirements of the primitive type for the BVH implementation, see {\hyperref[\detokenize{ImplemBVH:chap-bvhconstraints}]{\sphinxcrossref{\DUrole{std,std-ref}{Template constraints}}}}.
See {\hyperref[\detokenize{ImplemDCEL:chap-bvhintegration}]{\sphinxcrossref{\DUrole{std,std-ref}{BVH integration}}}} for details regarding DCEL integration with BVHs.


\subsection{BVH integration}
\label{\detokenize{ImplemDCEL:bvh-integration}}\label{\detokenize{ImplemDCEL:chap-bvhintegration}}
\sphinxAtStartPar
DCEL functionality can easily be embedded in BVHs.
In this case it is the facets that are embedded in the BVHs, and we require that we can create bounding volumes that contain all the vertices in a facet.
Moreover, partitioning functions that partition a set of polygon faces into \sphinxcode{\sphinxupquote{K}} new sets of faces are also required.

\sphinxAtStartPar
EBGeometry provides some simplistic functions that are needed (see {\hyperref[\detokenize{ImplemBVH:chap-bvhconstruction}]{\sphinxcrossref{\DUrole{std,std-ref}{Construction}}}}) when building BVHs for DCEL geometries .

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The functions are defined in \sphinxcode{\sphinxupquote{Source/EBGeometry\_DCEL\_BVH.hpp}}.
\end{sphinxadmonition}

\sphinxAtStartPar
For the bounding volume constructor, we provide a function

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BV}\PYG{o}{\PYGZgt{}}
\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BVH}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BVConstructorT}\PYG{o}{\PYGZlt{}}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FaceT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{BV}\PYG{o}{\PYGZgt{}} \PYG{n}{defaultBVConstructor} \PYG{o}{=}
\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FaceT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}primitive}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{BV} \PYG{p}{\PYGZob{}}
  \PYG{k}{return} \PYG{n}{BV}\PYG{p}{(}\PYG{n}{a\PYGZus{}primitive}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getAllVertexCoordinates}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note the extra template constraint on the bounding volume type \sphinxcode{\sphinxupquote{BV}}, which must be able to construct a bounding volume from a finite point set (in this case the vertex coordinates).

\sphinxAtStartPar
For the stop function we provide a simple function

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BV}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{K}\PYG{o}{\PYGZgt{}}
\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BVH}\PYG{o}{:}\PYG{o}{:}\PYG{n}{StopFunctionT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FaceT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}} \PYG{n}{defaultStopFunction} \PYG{o}{=}
\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const} \PYG{n}{BVH}\PYG{o}{:}\PYG{o}{:}\PYG{n}{NodeT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FaceT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}node}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kt}{bool} \PYG{p}{\PYGZob{}}
  \PYG{k}{return} \PYG{p}{(}\PYG{n}{a\PYGZus{}node}\PYG{p}{.}\PYG{n}{getPrimitives}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{K}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that this simply terminates the leaf partitioning if there are not enough primitives (polygon faces) available, or there are fewer than a pre\sphinxhyphen{}defined number of primitives.

\sphinxAtStartPar
For the partitioning function we include a simple function that partitions the primitives along the longest axis:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BV}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{K}\PYG{o}{\PYGZgt{}}
\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BVH}\PYG{o}{:}\PYG{o}{:}\PYG{n}{PartitionerT}\PYG{o}{\PYGZlt{}}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FaceT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}} \PYG{n}{chunkPartitioner} \PYG{o}{=}
\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const} \PYG{n}{PrimitiveList}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}primitives}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{array}\PYG{o}{\PYGZlt{}}\PYG{n}{PrimitiveList}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}} \PYG{p}{\PYGZob{}}
  \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{n}{lo} \PYG{o}{=} \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{n}{hi} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{for} \PYG{p}{(}\PYG{k}{const} \PYG{k}{auto}\PYG{o}{\PYGZam{}} \PYG{n+nl}{p} \PYG{p}{:} \PYG{n}{a\PYGZus{}primitives}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{lo} \PYG{o}{=} \PYG{n}{min}\PYG{p}{(}\PYG{n}{lo}\PYG{p}{,} \PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getCentroid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{hi} \PYG{o}{=} \PYG{n}{max}\PYG{p}{(}\PYG{n}{hi}\PYG{p}{,} \PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getCentroid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k}{const} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{splitDir} \PYG{o}{=} \PYG{p}{(}\PYG{n}{hi} \PYG{o}{\PYGZhy{}} \PYG{n}{lo}\PYG{p}{)}\PYG{p}{.}\PYG{n}{maxDir}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}

  \PYG{c+c1}{// Sort the primitives along the above coordinate direction.}
  \PYG{n}{PrimitiveList}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{n}{sortedPrimitives}\PYG{p}{(}\PYG{n}{a\PYGZus{}primitives}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{sort}\PYG{p}{(}
    \PYG{n}{sortedPrimitives}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sortedPrimitives}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{[}\PYG{n}{splitDir}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{FaceT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{f1}\PYG{p}{,} \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{FaceT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{f2}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kt}{bool} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{f1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getCentroid}\PYG{p}{(}\PYG{n}{splitDir}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{f2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getCentroid}\PYG{p}{(}\PYG{n}{splitDir}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{return} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{equalCounts}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sortedPrimitives}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
For a list of all DCEL partitioner, see \sphinxcode{\sphinxupquote{Source/EBGeometry\_DCEL\_BVH.hpp}}.


\subsection{Code example}
\label{\detokenize{ImplemDCEL:code-example}}
\sphinxAtStartPar
Constructing a compact BVH representation of polygon mesh is therefore done as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n}{T}    \PYG{o}{=} \PYG{k+kt}{float}\PYG{p}{;}
\PYG{k}{using} \PYG{n}{BV}   \PYG{o}{=} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BoundingVolumes}\PYG{o}{:}\PYG{o}{:}\PYG{n}{AABBT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
\PYG{k}{using} \PYG{n}{Vec3} \PYG{o}{=} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
\PYG{k}{using} \PYG{n}{Face} \PYG{o}{=} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FaceT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{;}

\PYG{k}{constexpr} \PYG{k+kt}{int} \PYG{n}{K} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Read the mesh from file and put it in a DCEL format.}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Mesh}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{mesh} \PYG{o}{=} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Parser}\PYG{o}{:}\PYG{o}{:}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MyFile.stl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Make a BVH node and build the BVH.}
\PYG{k}{auto} \PYG{n}{root} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{make\PYGZus{}shared}\PYG{o}{\PYGZlt{}}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BVH}\PYG{o}{:}\PYG{o}{:}\PYG{n}{NodeT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{Face}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{mesh}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getFaces}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Build the BVH hierarchy}
\PYG{n}{root}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{topDownSortAndPartitionPrimitives}\PYG{p}{(}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{defaultBVConstructor}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{BV}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
                                        \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{spatialSplitPartitioner}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
                                        \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{defaultStopFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Flatten the tree onto a tighter representation. Then delete the old tree.}
\PYG{k}{auto} \PYG{n}{compactBVH} \PYG{o}{=} \PYG{n}{root}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{flattenTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{root} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Signed distance function}
\label{\detokenize{ImplemSDF:signed-distance-function}}\label{\detokenize{ImplemSDF:chap-implemsdf}}\label{\detokenize{ImplemSDF::doc}}
\sphinxAtStartPar
In EBGeometry we have encapsulated the concept of a signed distance function in an abstract class

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* EBGeometry}
\PYG{c+cm}{ * Copyright © 2022 Robert Marskar}
\PYG{c+cm}{ * Please refer to Copyright.txt and LICENSE in the EBGeometry root directory.}
\PYG{c+cm}{ */}

\PYG{c+cm}{/*!}
\PYG{c+cm}{  @file   EBGeometry\PYGZus{}SignedDistanceFunction.hpp}
\PYG{c+cm}{  @brief  Abstract base class for representing a signed distance function.}
\PYG{c+cm}{  @author Robert Marskar}
\PYG{c+cm}{*/}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef EBGeometry\PYGZus{}SignedDistanceFunction}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EBGeometry\PYGZus{}SignedDistanceFunction}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}memory\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}deque\PYGZgt{}}

\PYG{c+c1}{// Our includes}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}EBGeometry\PYGZus{}ImplicitFunction.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}EBGeometry\PYGZus{}NamespaceHeader.hpp\PYGZdq{}}

\PYG{c+cm}{/*!}
\PYG{c+cm}{  @brief Abstract representation of a signed distance function.}
\PYG{c+cm}{  @details Users can put whatever they like in here, e.g. analytic functions,}
\PYG{c+cm}{  DCEL meshes, or DCEL meshes stored in full or compact BVH trees. The}
\PYG{c+cm}{  signedDistance function must be implemented by the user. When computing it,}
\PYG{c+cm}{  the user can apply transformation operators (rotations, scaling, translations)}
\PYG{c+cm}{  by calling transformPoint on the input coordinate.}
\PYG{c+cm}{*/}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{SignedDistanceFunction} \PYG{o}{:} \PYG{k}{public} \PYG{n}{ImplicitFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Disallowed, use the full constructor}
\PYG{c+cm}{  */}
  \PYG{n}{SignedDistanceFunction}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{k}{default}\PYG{p}{;}

  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Destructor (does nothing)}
\PYG{c+cm}{  */}
  \PYG{k}{virtual} \PYG{o}{\PYGZti{}}\PYG{n}{SignedDistanceFunction}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{k}{default}\PYG{p}{;}

  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Implementation of ImplicitFunction::value}
\PYG{c+cm}{    @param[in] a\PYGZus{}point 3D point.}
\PYG{c+cm}{  */}
  \PYG{k}{virtual} \PYG{n}{T}
  \PYG{n+nf}{value}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}point}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept} \PYG{k}{override} \PYG{k}{final}\PYG{p}{;}

  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Signed distance function.}
\PYG{c+cm}{    @param[in] a\PYGZus{}point 3D point.}
\PYG{c+cm}{  */}
  \PYG{k}{virtual} \PYG{n}{T}
  \PYG{n+nf}{signedDistance}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}point}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Signed distance normal vector.}
\PYG{c+cm}{    @details Computed using finite differences with step a\PYGZus{}delta}
\PYG{c+cm}{    @param[in] a\PYGZus{}point 3D point}
\PYG{c+cm}{    @param[in] a\PYGZus{}delta Finite difference step}
\PYG{c+cm}{  */}
  \PYG{k+kr}{inline} \PYG{k}{virtual} \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}
  \PYG{n}{normal}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}point}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}delta}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}EBGeometry\PYGZus{}NamespaceFooter.hpp\PYGZdq{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}EBGeometry\PYGZus{}SignedDistanceFunctionImplem.hpp\PYGZdq{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}

\sphinxAtStartPar
We point out that the BVH and DCEL classes are fundamentally also signed distance functions, and they also inherit from \sphinxcode{\sphinxupquote{SignedDistanceFunction}}.
The \sphinxcode{\sphinxupquote{SignedDistanceFunction}} class also exists so that we have a common entry point for performing distance field manipulations like rotations and translations.

\sphinxAtStartPar
When implementing the \sphinxcode{\sphinxupquote{signedDistance}} function, one can transform the input point by first calling \sphinxcode{\sphinxupquote{transformPoint}}.
The functions \sphinxcode{\sphinxupquote{translate}} and \sphinxcode{\sphinxupquote{rotate}} will translate or rotate the object.
It is also possible to \sphinxstyleemphasis{scale} an object, but this is not simply a coordinate transform so it is implemented as a separate signed distance function.
For example, in order to rotate a DCEL mesh (without using the BVH accelerator) we can implement the following signed distance function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{MySignedDistanceFunction} \PYG{o}{:} \PYG{k}{public} \PYG{n}{SignedDistanceFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
   \PYG{n}{T} \PYG{n}{signedDistance}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}point}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept} \PYG{k}{override} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{m\PYGZus{}mesh}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{signedDistance}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{transformPoint}\PYG{p}{(}\PYG{n}{a\PYGZus{}point}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

\PYG{k}{protected}\PYG{o}{:}
   \PYG{c+c1}{// DCEL mesh object, must be constructed externally and}
   \PYG{c+c1}{// supplied to MyDistanceFunction (e.g. through the constructor).}
   \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Dcel}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MeshT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{m\PYGZus{}mesh}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Alternatively, using a BVH structure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{P}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BV}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{K}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{MySignedDistanceFunction} \PYG{o}{:} \PYG{k}{public} \PYG{n}{SignedDistanceFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
   \PYG{n}{T} \PYG{n}{signedDistance}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}point}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept} \PYG{k}{override} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{m\PYGZus{}bvh}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{signedDistance}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{transformPoint}\PYG{p}{(}\PYG{n}{a\PYGZus{}point}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

\PYG{k}{protected}\PYG{o}{:}
   \PYG{c+c1}{// BVH object, must be constructed externally}
   \PYG{c+c1}{// and supplied to MyDistanceFunction (e.g. through the constructor).}
   \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BVH}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LinearBVH}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{P}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{m\PYGZus{}bvh}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Normal vector}
\label{\detokenize{ImplemSDF:normal-vector}}
\sphinxAtStartPar
The normal vector of \sphinxcode{\sphinxupquote{EBGeometry::SignedDistanceFunction\textless{}T\textgreater{}}} is computed using centered finite differences:
\begin{equation*}
\begin{split}n_i\left(\mathbf{x}\right) = \frac{1}{2\Delta}\left[S\left(\mathbf{x} + \Delta\mathbf{\hat{i}}\right) - S\left(\mathbf{x} - \Delta\mathbf{\hat{i}}\right)\right],\end{split}
\end{equation*}
\sphinxAtStartPar
where \(i\) is a coordinate direction and \(\Delta > 0\).
This is done for each component, and the normalized vector is then returned.


\subsection{Transformations}
\label{\detokenize{ImplemSDF:transformations}}
\sphinxAtStartPar
The following transformations are possible:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Translation, which defines the operation \(\mathbf{x}^\prime = \mathbf{x} - \mathbf{t}\) where \(\mathbf{t}\) is a translation vector.

\item {} 
\sphinxAtStartPar
Rotation, which defines the operation \(\mathbf{x}^\prime = R\left(\mathbf{x}, \theta, a\right)\) where \(\mathbf{x}\) is rotated an angle \(\theta\) around the coordinate axis \(a\).

\end{itemize}

\sphinxAtStartPar
Transformations are applied sequentially.
The APIs are as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{translate}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}translation}\PYG{p}{)} \PYG{k}{noexcept}\PYG{p}{;}  \PYG{c+c1}{// a\PYGZus{}translation are Cartesian translations vector}
\PYG{k+kt}{void} \PYG{n+nf}{rotate}\PYG{p}{(}\PYG{k}{const} \PYG{n}{T} \PYG{n}{a\PYGZus{}angle}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}axis}\PYG{p}{)} \PYG{k}{noexcept}\PYG{p}{;} \PYG{c+c1}{// a\PYGZus{}angle in degrees, and a\PYGZus{}axis being the Cartesian axis}
\end{sphinxVerbatim}

\sphinxAtStartPar
E.g. the following code will first translate, then 90 degrees about the \(x\)\sphinxhyphen{}axis.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MySignedDistanceFunction}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{float}\PYG{o}{\PYGZgt{}} \PYG{n}{sdf}\PYG{p}{;}

\PYG{n}{sdf}\PYG{o}{.}\PYG{n}{translate}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sdf}\PYG{o}{.}\PYG{n}{rotate}\PYG{p}{(}\PYG{l+m+mi}{90}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that if the transformations are to be applied, the implementation of \sphinxcode{\sphinxupquote{signedDistance(...)}} must transform the input point, as shown in the examples above.


\subsection{Rounding}
\label{\detokenize{ImplemSDF:rounding}}
\sphinxAtStartPar
Distance functions can be rounded by displacing the SDF by a specified distance.
For example, given a distance functions \(S\left(\mathbf{x}\right)\), the rounded distance functions is
\begin{equation*}
\begin{split}S_r\left(\mathbf{x}\right) = S\left(\mathbf{x}\right) - r,\end{split}
\end{equation*}
\sphinxAtStartPar
where \(r\) is some rounding radius.
Note that the rounding does not preserve the volume of the original SDF, so subsequent \sphinxstyleemphasis{scaling} of the object is usually necessary.

\sphinxAtStartPar
The rounded SDF is implemented in \sphinxcode{\sphinxupquote{Source/EBGeometry\_AnalyticDistanceFunctions.hpp}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{RoundedSDF} \PYG{o}{:} \PYG{k}{public} \PYG{n}{SignedDistanceFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Disallowed weak construction}
\PYG{c+cm}{  */}
  \PYG{n}{RoundedSDF}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{k}{delete}\PYG{p}{;}

  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Rounded SDF. Rounds the input SDF}
\PYG{c+cm}{    @param[in] a\PYGZus{}sdf  Input signed distance function.}
\PYG{c+cm}{    @param[in] a\PYGZus{}curv Rounding radius.}
\PYG{c+cm}{  */}
  \PYG{n}{RoundedSDF}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{SignedDistanceFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}sdf}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T} \PYG{n}{a\PYGZus{}curv}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{m\PYGZus{}sdf}  \PYG{o}{=} \PYG{n}{a\PYGZus{}sdf}\PYG{p}{;}
    \PYG{n}{m\PYGZus{}curv} \PYG{o}{=} \PYG{n}{a\PYGZus{}curv}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Destructor}
\PYG{c+cm}{  */}
  \PYG{k}{virtual} \PYG{o}{\PYGZti{}}\PYG{n}{RoundedSDF}\PYG{p}{(}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Signed distance field.}
\PYG{c+cm}{  */}
  \PYG{k}{virtual} \PYG{n}{T}
  \PYG{n}{signedDistance}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}point}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept} \PYG{k}{override}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{m\PYGZus{}sdf}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{signedDistance}\PYG{p}{(}\PYG{n}{a\PYGZus{}point}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{m\PYGZus{}curv}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

\PYG{k}{protected}\PYG{o}{:}
  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Original signed distance function}
\PYG{c+cm}{  */}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{SignedDistanceFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m\PYGZus{}sdf}\PYG{p}{;}

  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Rounding radius}
\PYG{c+cm}{  */}
  \PYG{n}{T} \PYG{n}{m\PYGZus{}curv}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
To use it, simply pass an SDF into the constructor and use the new distance function.


\subsection{Scaling}
\label{\detokenize{ImplemSDF:scaling}}
\sphinxAtStartPar
Scaling of distance functions are possible through the transformation
\begin{equation*}
\begin{split}S_c\left(\mathbf{x}\right) = c S\left(\frac{\mathbf{x}}{c}\right),\end{split}
\end{equation*}
\sphinxAtStartPar
where \(c\) is a scaling factor.
We point out that anisotropic stretching does not preserve the distance field.

\sphinxAtStartPar
The rounded SDF is implemented in \sphinxcode{\sphinxupquote{Source/EBGeometry\_AnalyticDistanceFunctions.hpp}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  @brief Scaled signed distance function.
*/
template \PYGZlt{}class T\PYGZgt{}
class ScaledSDF : public SignedDistanceFunction\PYGZlt{}T\PYGZgt{}
\PYGZob{}
public:
  /*!
    @brief Disallowed weak construction
  */
  ScaledSDF() = delete;

  /*!
    @brief Scaled SDF.
    @param[in] a\PYGZus{}sdf   Input signed distance function.
    @param[in] a\PYGZus{}scale Scaling factor.
  */
  ScaledSDF(const std::shared\PYGZus{}ptr\PYGZlt{}SignedDistanceFunction\PYGZlt{}T\PYGZgt{}\PYGZgt{} a\PYGZus{}sdf, const T a\PYGZus{}scale)
  \PYGZob{}
    m\PYGZus{}sdf   = a\PYGZus{}sdf;
    m\PYGZus{}scale = a\PYGZus{}scale;
  \PYGZcb{}

  /*!
    @brief Destructor
  */
  virtual \PYGZti{}ScaledSDF()
  \PYGZob{}\PYGZcb{}

  /*!
    @brief Signed distance field.
    @param[in] a\PYGZus{}point Input point.
  */
  virtual T
  signedDistance(const Vec3T\PYGZlt{}T\PYGZgt{}\PYGZam{} a\PYGZus{}point) const noexcept override
  \PYGZob{}
    return (m\PYGZus{}sdf\PYGZhy{}\PYGZgt{}signedDistance(a\PYGZus{}point / m\PYGZus{}scale)) * m\PYGZus{}scale;
  \PYGZcb{}

protected:
  /*!
    @brief Original signed distance function
  */
  std::shared\PYGZus{}ptr\PYGZlt{}const SignedDistanceFunction\PYGZlt{}T\PYGZgt{}\PYGZgt{} m\PYGZus{}sdf;

  /*!
    @brief Scaling factor.
\end{sphinxVerbatim}


\subsection{Analytic functions}
\label{\detokenize{ImplemSDF:analytic-functions}}\label{\detokenize{ImplemSDF:chap-analyticsdf}}
\sphinxAtStartPar
Above, we have shown how users can supply a DCEL or BVH structure to implement \sphinxcode{\sphinxupquote{SignedDistanceFunction}}.
In addition, the file \sphinxcode{\sphinxupquote{Source/EBGeometry\_AnalyticSignedDistanceFunctions.hpp}} defines various other analytic shapes such as:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Sphere}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{SphereSDF} \PYG{o}{:} \PYG{k}{public} \PYG{n}{SignedDistanceFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Box}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{BoxSDF} \PYG{o}{:} \PYG{k}{public} \PYG{n}{SignedDistanceFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Torus}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{TorusSDF} \PYG{o}{:} \PYG{k}{public} \PYG{n}{SignedDistanceFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Capped cylinder}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{CylinderSDF} \PYG{o}{:} \PYG{k}{public} \PYG{n}{SignedDistanceFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Infinite cylinder}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{InfiniteCylinderSDF} \PYG{o}{:} \PYG{k}{public} \PYG{n}{SignedDistanceFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Capsule/rounded cylinder}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{CapsuleSDF} \PYG{o}{:} \PYG{k}{public} \PYG{n}{SignedDistanceFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Infinite cone}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{InfiniteConeSDF} \PYG{o}{:} \PYG{k}{public} \PYG{n}{SignedDistanceFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cone}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{ConeSDF} \PYG{o}{:} \PYG{k}{public} \PYG{n}{SignedDistanceFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\end{itemize}

\sphinxstepscope


\section{Unions}
\label{\detokenize{ImplemUnion:unions}}\label{\detokenize{ImplemUnion:chap-union}}\label{\detokenize{ImplemUnion::doc}}
\sphinxAtStartPar
As discussed in {\hyperref[\detokenize{Concepts:chap-concepts}]{\sphinxcrossref{\DUrole{std,std-ref}{Signed distance fields}}}}, a union of signed distance fields can be created provided that the objects do not touch or overlap.
EBGeometry provides two implementations:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Standard union} where one looks through every primitive in the union.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{BVH\sphinxhyphen{}enabled union} where bounding volume hierarchies are used to find the closest object.

\end{itemize}


\subsection{Standard union}
\label{\detokenize{ImplemUnion:standard-union}}
\sphinxAtStartPar
The standard union is template as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Union} \PYG{o}{:} \PYG{k}{public} \PYG{n}{ImplicitFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{c+c1}{// Regular CSG union only requires implicit functions.}
  \PYG{k}{static\PYGZus{}assert}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{is\PYGZus{}base\PYGZus{}of}\PYG{o}{\PYGZlt{}}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ImplicitFunction}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{value}\PYG{p}{)}\PYG{p}{;}

  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Disallowed, use the full constructor}
\PYG{c+cm}{  */}
  \PYG{n}{Union}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{k}{delete}\PYG{p}{;}

  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Full constructor. Computes the CSG union}
\PYG{c+cm}{    @param[in] a\PYGZus{}primitives List of primitives}
\PYG{c+cm}{    @param[in] a\PYGZus{}flipSign   Hook for turning inside to outside}
\PYG{c+cm}{  */}
  \PYG{n}{Union}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}primitives}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{a\PYGZus{}flipSign}\PYG{p}{)}\PYG{p}{;}

  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Destructor (does nothing)}
\PYG{c+cm}{  */}
  \PYG{k}{virtual} \PYG{o}{\PYGZti{}}\PYG{n}{Union}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{k}{default}\PYG{p}{;}

  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Value function}
\PYG{c+cm}{    @param[in] a\PYGZus{}point 3D point.}
\PYG{c+cm}{  */}
  \PYG{n}{T}
  \PYG{n+nf}{value}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}point}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept} \PYG{k}{override}\PYG{p}{;}

\PYG{k}{protected}\PYG{o}{:}
  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief List of primitives}
\PYG{c+cm}{  */}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m\PYGZus{}primitives}\PYG{p}{;}

  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Hook for turning inside to outside}
\PYG{c+cm}{  */}
  \PYG{k+kt}{bool} \PYG{n}{m\PYGZus{}flipSign}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}EBGeometry\PYGZus{}NamespaceFooter.hpp\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that \sphinxcode{\sphinxupquote{EBGeometry::Union}} inherits from \sphinxcode{\sphinxupquote{EBGeometry::SignedDistanceFunction}} and thus provides a \sphinxcode{\sphinxupquote{signedDistance(...)}} function.
The implementation of the standard union is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Union}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Union}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}primitives}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{a\PYGZus{}flipSign}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{for} \PYG{p}{(}\PYG{k}{const} \PYG{k}{auto}\PYG{o}{\PYGZam{}} \PYG{n+nl}{prim} \PYG{p}{:} \PYG{n}{a\PYGZus{}primitives}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{m\PYGZus{}primitives}\PYG{p}{.}\PYG{n}{emplace\PYGZus{}back}\PYG{p}{(}\PYG{n}{prim}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{n}{m\PYGZus{}flipSign} \PYG{o}{=} \PYG{n}{a\PYGZus{}flipSign}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{P}\PYG{o}{\PYGZgt{}}
\PYG{n}{T}
\PYG{n}{Union}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{value}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}point}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept}
\PYG{p}{\PYGZob{}}
  \PYG{n}{T} \PYG{n}{ret} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{numeric\PYGZus{}limits}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{infinity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{for} \PYG{p}{(}\PYG{k}{const} \PYG{k}{auto}\PYG{o}{\PYGZam{}} \PYG{n+nl}{prim} \PYG{p}{:} \PYG{n}{m\PYGZus{}primitives}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{ret} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{min}\PYG{p}{(}\PYG{n}{ret}\PYG{p}{,} \PYG{n}{prim}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{value}\PYG{p}{(}\PYG{n}{a\PYGZus{}point}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{n}{T} \PYG{n}{sign} \PYG{o}{=} \PYG{p}{(}\PYG{n}{m\PYGZus{}flipSign}\PYG{p}{)} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0} \PYG{o}{:} \PYG{l+m+mf}{1.0}\PYG{p}{;}

  \PYG{k}{return} \PYG{n}{sign} \PYG{o}{*} \PYG{n}{ret}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}EBGeometry\PYGZus{}NamespaceFooter.hpp\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
That is, it iterates through \sphinxstyleemphasis{all} the objects in order to find the signed distance.


\subsection{BVH\sphinxhyphen{}enabled union}
\label{\detokenize{ImplemUnion:bvh-enabled-union}}
\sphinxAtStartPar
The BVH\sphinxhyphen{}enabled union is implemented by \sphinxcode{\sphinxupquote{EBGeometry::UnionBVH}} as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
*/
template \PYGZlt{}class T, class P, class BV, size\PYGZus{}t K\PYGZgt{}
class UnionBVH : public ImplicitFunction\PYGZlt{}T\PYGZgt{}
\PYGZob{}
public:
  static\PYGZus{}assert(std::is\PYGZus{}base\PYGZus{}of\PYGZlt{}EBGeometry::SignedDistanceFunction\PYGZlt{}T\PYGZgt{}, P\PYGZgt{}::value);

  using BVConstructor = EBGeometry::BVH::BVConstructorT\PYGZlt{}P, BV\PYGZgt{};

  /*!
    @brief Disallowed, use the full constructor
  */
  UnionBVH() = delete;

  /*!
    @brief Full constructor.
    @param[in] a\PYGZus{}distanceFunctions Signed distance functions.
    @param[in] a\PYGZus{}flipSign          Hook for turning inside to outside
    @param[in] a\PYGZus{}bvConstructor     Bounding volume constructor.
  */
  UnionBVH(const std::vector\PYGZlt{}std::shared\PYGZus{}ptr\PYGZlt{}P\PYGZgt{}\PYGZgt{}\PYGZam{} a\PYGZus{}distanceFunctions,
           const bool                             a\PYGZus{}flipSign,
           const BVConstructor\PYGZam{}                   a\PYGZus{}bvConstructor);

  /*!
    @brief Destructor (does nothing)
  */
  virtual \PYGZti{}UnionBVH() = default;

  /*!
    @brief Value function
    @param[in] a\PYGZus{}point 3D point.
  */
  T
  value(const Vec3T\PYGZlt{}T\PYGZgt{}\PYGZam{} a\PYGZus{}point) const noexcept override;

  /*!
    @brief Get the bounding volume
  */
  const BV\PYGZam{}
  getBoundingVolume() const noexcept;

protected:
  /*!
    @brief Root node for linearized BVH tree
  */
  std::shared\PYGZus{}ptr\PYGZlt{}EBGeometry::BVH::LinearBVH\PYGZlt{}T, P, BV, K\PYGZgt{}\PYGZgt{} m\PYGZus{}rootNode;

  /*!
    @brief Hook for turning inside to outside
  */
  bool m\PYGZus{}flipSign;

  /*!
    @brief Build BVH tree for the input objects. User must supply a partitioner
    and a BV constructor for the SDF objects.
    @param[in] a\PYGZus{}bvConstructor Constructor for building a bounding volume that
    encloses an object.
  */
  inline void
  buildTree(const std::vector\PYGZlt{}std::shared\PYGZus{}ptr\PYGZlt{}P\PYGZgt{}\PYGZgt{}\PYGZam{} a\PYGZus{}distanceFunctions, const BVConstructor\PYGZam{} a\PYGZus{}bvConstructor) noexcept;
\PYGZcb{};

\PYGZsh{}include \PYGZdq{}EBGeometry\PYGZus{}NamespaceFooter.hpp\PYGZdq{}

\PYGZsh{}include \PYGZdq{}EBGeometry\PYGZus{}UnionBVHImplem.hpp\PYGZdq{}

\PYGZsh{}endif
\end{sphinxVerbatim}

\sphinxAtStartPar
As always, the template parameter \sphinxcode{\sphinxupquote{T}} indicates the precision, \sphinxcode{\sphinxupquote{BV}} the bounding volume type and \sphinxcode{\sphinxupquote{K}} the tree degree.
\sphinxcode{\sphinxupquote{UnionBVH}} takes a bounding volume constructor in addition to the list of primitives, see {\hyperref[\detokenize{ImplemBVH:chap-bvhconstruction}]{\sphinxcrossref{\DUrole{std,std-ref}{Construction}}}}.

\sphinxAtStartPar
Internally, \sphinxcode{\sphinxupquote{UnionBVH}} defines its own partitioning function which is identical to the implementation for DCEL meshes (see {\hyperref[\detokenize{ImplemDCEL:chap-bvhintegration}]{\sphinxcrossref{\DUrole{std,std-ref}{BVH integration}}}}), with the exception that the partitioning is based on the centroids of the bounding volumes rather than the centroid of the primitives.
After partitioning the primitives, the original BVH tree is flattened onto the compact representation.

\sphinxAtStartPar
The implementation of the signed distance function for the BVH\sphinxhyphen{}enabled union is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{c+c1}{// distance but there is still a CSG union, and the BVH is still a useful thing.}
  \PYG{c+c1}{// So, we can\PYGZsq{}t use LinearNode::signedDistanceFunction because it returns the}
  \PYG{c+c1}{// closest object and not the object with the smallest value function.}
  \PYG{c+c1}{//}
  \PYG{c+c1}{// Fortunately, when I wrote the LinearNode accelerator I wrote it such that we can determine}
  \PYG{c+c1}{// how to update the \PYGZdq{}shortest\PYGZdq{} distance using externally supplied criteria.}
  \PYG{c+c1}{// So, we just update this as f = min(f1,f2,f3) etc, and prune nodes accordingly.}
  \PYG{c+c1}{// The criteria for that are below...}
\end{sphinxVerbatim}

\sphinxAtStartPar
That is, it relies on pruning from the BVH functionality for finding the signed distance to the closest object.

\sphinxstepscope


\section{Reading data}
\label{\detokenize{Parsers:reading-data}}\label{\detokenize{Parsers:chap-parsers}}\label{\detokenize{Parsers::doc}}
\sphinxAtStartPar
Routines for parsing surface files from grids into EBGeometry’s DCEL grids are given in the namespace \sphinxcode{\sphinxupquote{EBGeometry::Parser}}.
The source code is implemented in \sphinxcode{\sphinxupquote{Source/EBGeometry\_Parser.hpp}}.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
EBGeometry is currently limited to reading STL files and reconstructing DCEL grids from those.
However, it is a simple matter to also reconstructor DCEL grids from triangle soups read using third\sphinxhyphen{}party codes (see {\hyperref[\detokenize{Parsers:chap-thirdpartyparser}]{\sphinxcrossref{\DUrole{std,std-ref}{Using third\sphinxhyphen{}party sources}}}}).
\end{sphinxadmonition}


\subsection{Reading STL files}
\label{\detokenize{Parsers:reading-stl-files}}
\sphinxAtStartPar
EBGeometry supports a native parser for binary and ASCII STL files.
To read an STL file, one will use one of the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kr}{inline} \PYG{k}{static} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Mesh}\PYG{o}{\PYGZgt{}}
\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Parser}\PYG{o}{:}\PYG{o}{:}\PYG{n}{STL}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{readSingle}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}filename}\PYG{p}{)} \PYG{k}{noexcept}\PYG{p}{;}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kr}{inline} \PYG{k}{static} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Mesh}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}
\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Parser}\PYG{o}{:}\PYG{o}{:}\PYG{n}{STL}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{readMulti}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}filename}\PYG{p}{)} \PYG{k}{noexcept}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The difference between these two is that \sphinxcode{\sphinxupquote{readSingle}} only reads a single STL \sphinxstyleemphasis{solid} while \sphinxcode{\sphinxupquote{readMulti}} will read all STL solids defined in the input file.

\sphinxAtStartPar
Alternatively, one can use \sphinxcode{\sphinxupquote{Parser::read}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kr}{inline} \PYG{k}{static} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MeshT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}
\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Parser}\PYG{o}{:}\PYG{o}{:}\PYG{n}{read}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}filename}\PYG{p}{)} \PYG{k}{noexcept}\PYG{p}{;}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kr}{inline} \PYG{k}{static} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MeshT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}
\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Parser}\PYG{o}{:}\PYG{o}{:}\PYG{n}{read}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}files}\PYG{p}{)} \PYG{k}{noexcept}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{a\_filename}} and \sphinxcode{\sphinxupquote{a\_files}} must be STL files.


\subsection{From soups to DCEL}
\label{\detokenize{Parsers:from-soups-to-dcel}}\label{\detokenize{Parsers:chap-polysoups}}
\sphinxAtStartPar
EBGeometry supports the creation of DCEL grids from polygon soups.
A triangle soup is represented as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{vertices}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{size\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{faces}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here, \sphinxcode{\sphinxupquote{vertices}} contains the \(x,y,z\) coordinates of each vertex, while each entry \sphinxcode{\sphinxupquote{faces}} contains a list of vertices for the face.

\sphinxAtStartPar
To turn this into a DCEL mesh, one should call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kr}{inline} \PYG{k}{static} \PYG{k+kt}{void}
\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Parser}\PYG{o}{:}\PYG{o}{:}\PYG{n}{compress}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}vertices}\PYG{p}{,}
                             \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{size\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}  \PYG{n}{a\PYGZus{}facets}\PYG{p}{)} \PYG{k}{noexcept}\PYG{p}{;}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kr}{inline} \PYG{k}{static} \PYG{k+kt}{void}
\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Parser}\PYG{o}{:}\PYG{o}{:}\PYG{n}{soupToDCEL}\PYG{p}{(}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MeshT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}              \PYG{n}{a\PYGZus{}mesh}\PYG{p}{,}
                               \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}vertices}\PYG{p}{,}
                               \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{size\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}  \PYG{n}{a\PYGZus{}facets}\PYG{p}{)} \PYG{k}{noexcept}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{compress}} function will discard duplicate vertices from the soup, while the \sphinxcode{\sphinxupquote{soupToDCEL}} will simply turn the remaining polygon soup into a DCEL mesh.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soupToDCEL}} will issue plenty of warnings if the polygon soup is not watertight and orientable.
\end{sphinxadmonition}


\subsection{Using third\sphinxhyphen{}party sources}
\label{\detokenize{Parsers:using-third-party-sources}}\label{\detokenize{Parsers:chap-thirdpartyparser}}
\sphinxAtStartPar
By design, EBGeometry does not include much functionality for parsing files into polygon soups.
There are many open source third\sphinxhyphen{}party codes for achieving this (and we have tested several of them):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/nmwsharp/happly}{happly} or \sphinxhref{https://github.com/vilya/miniply}{miniply} for Stanford PLY files.

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/sreiter/stl\_reader}{stl\_reader} for STL files.

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/tinyobjloader/tinyobjloader}{tinyobjloader} for OBJ files.

\end{enumerate}

\sphinxAtStartPar
In almost every case, the above codes can be read into polygon soups, and one can then turn the soup into a DCEL mesh as described in {\hyperref[\detokenize{Parsers:chap-polysoups}]{\sphinxcrossref{\DUrole{std,std-ref}{From soups to DCEL}}}}.


\chapter{Guided examples}
\label{\detokenize{index:guided-examples}}
\sphinxstepscope


\section{Overview}
\label{\detokenize{Examples:overview}}\label{\detokenize{Examples:chap-examples}}\label{\detokenize{Examples::doc}}
\sphinxAtStartPar
Below, we consider a few examples that show how to use EBGeometry.
All the examples are located in the examples folder.
For instructions on how to compile and run the examples, refer to the README file in the example folder.

\sphinxstepscope


\section{Basic example}
\label{\detokenize{Example_Basic:basic-example}}\label{\detokenize{Example_Basic:chap-examplestl}}\label{\detokenize{Example_Basic::doc}}
\sphinxAtStartPar
This example is given in \sphinxcode{\sphinxupquote{Examples/EBGeometry\_DCEL/main.cpp}} and shows the following steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
How to read an STL file into a DCEL mesh.

\item {} 
\sphinxAtStartPar
How to partition and flatten a BVH tree.

\item {} 
\sphinxAtStartPar
How to call the signed distance function and provide a performance comparison between SDF representations.

\end{enumerate}

\sphinxAtStartPar
We will focus on the following parts of the code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n}{T}    \PYG{o}{=} \PYG{k+kt}{float}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{c+c1}{// we convert it to a full BVH tree representation. Then we flatten that tree.}
  \PYG{k}{const} \PYG{k}{auto} \PYG{n}{dcelSDF} \PYG{o}{=} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Parser}\PYG{o}{:}\PYG{o}{:}\PYG{n}{readIntoDCEL}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{file}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{const} \PYG{k}{auto} \PYG{n}{bvhSDF}  \PYG{o}{=} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{buildFullBVH}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{dcelSDF}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{const} \PYG{k}{auto} \PYG{n}{linSDF}  \PYG{o}{=} \PYG{n}{bvhSDF}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{flattenTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{c+c1}{// Sample some random points around the object.}
  \PYG{k}{constexpr} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{Nsamp} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;}

  \PYG{k}{const} \PYG{n}{Vec3} \PYG{n}{lo}    \PYG{o}{=} \PYG{n}{bvhSDF}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getBoundingVolume}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{getLowCorner}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{const} \PYG{n}{Vec3} \PYG{n}{hi}    \PYG{o}{=} \PYG{n}{bvhSDF}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getBoundingVolume}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{getHighCorner}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{mt19937\PYGZus{}64} \PYG{n}{rng}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{size\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{chrono}\PYG{o}{:}\PYG{o}{:}\PYG{n}{system\PYGZus{}clock}\PYG{o}{:}\PYG{o}{:}\PYG{n}{now}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{time\PYGZus{}since\PYGZus{}epoch}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{if} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{bvhSum} \PYG{o}{\PYGZhy{}} \PYG{n}{dcelSum}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{numeric\PYGZus{}limits}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{epsilon}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
\end{sphinxVerbatim}


\subsection{Reading the surface mesh}
\label{\detokenize{Example_Basic:reading-the-surface-mesh}}
\sphinxAtStartPar
The first block of code parses an STL file (here called \sphinxstyleemphasis{file}) and returns a DCEL mesh description of the STL file.
We point out that the parser will issue errors if the STL file is not watertight and orientable.


\subsection{Constructing the BVH}
\label{\detokenize{Example_Basic:constructing-the-bvh}}
\sphinxAtStartPar
The second block of code, which begins with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{c+c1}{// Sample some random points around the object.}
\end{sphinxVerbatim}

\sphinxAtStartPar
creates a BVH root node and provides it with all the DCEL faces.
The next block of code

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{k}{constexpr} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{Nsamp} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;}

  \PYG{k}{const} \PYG{n}{Vec3} \PYG{n}{lo}    \PYG{o}{=} \PYG{n}{bvhSDF}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getBoundingVolume}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{getLowCorner}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{const} \PYG{n}{Vec3} \PYG{n}{hi}    \PYG{o}{=} \PYG{n}{bvhSDF}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getBoundingVolume}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{getHighCorner}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
partitions the BVH using pre\sphinxhyphen{}defined partitioning functions (see {\hyperref[\detokenize{ImplemDCEL:chap-bvhintegration}]{\sphinxcrossref{\DUrole{std,std-ref}{BVH integration}}}} for details).

\sphinxAtStartPar
Finally, the BVH tree is flattened by

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}


\subsection{Summary}
\label{\detokenize{Example_Basic:summary}}
\sphinxAtStartPar
Note that all the objects \sphinxcode{\sphinxupquote{directSDF}}, \sphinxcode{\sphinxupquote{bvhSDF}}, and \sphinxcode{\sphinxupquote{linSDF}} represent precisely the same distance field.
The objects differ in how they compute it:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{directSDF}} will iterate through all faces in the mesh.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bvhSDF}} uses \sphinxstyleemphasis{full BVH tree representation}, pruning branches during the tree traversal.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{linSDF}} uses \sphinxstyleemphasis{compact BVH tree representation}, also pruning branches during the tree traversal.

\end{itemize}

\sphinxAtStartPar
All the above functions give the same result, but with different performance metrics.

\sphinxstepscope


\section{Unions}
\label{\detokenize{Example_Union:unions}}\label{\detokenize{Example_Union:chap-exampleunion}}\label{\detokenize{Example_Union::doc}}
\sphinxAtStartPar
This example is given in \sphinxcode{\sphinxupquote{Examples/EBGeometry\_Union/main.cpp}} and shows the following steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The creation of scene composed of an array of spheres.

\item {} 
\sphinxAtStartPar
Instantiation of a standard union for the signed distance (see {\hyperref[\detokenize{ImplemUnion:chap-union}]{\sphinxcrossref{\DUrole{std,std-ref}{Unions}}}}).

\item {} 
\sphinxAtStartPar
Instantiation of a BVH\sphinxhyphen{}enabled union for the signed distance (see {\hyperref[\detokenize{ImplemUnion:chap-union}]{\sphinxcrossref{\DUrole{std,std-ref}{Unions}}}}).

\end{enumerate}

\sphinxAtStartPar
We focus on the following parts of the code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}
  \PYG{k}{constexpr} \PYG{k+kt}{int} \PYG{n}{K} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

  \PYG{c+c1}{// Make a sphere array consisting of about M\PYGZca{}3 spheres. We assume}
  \PYG{c+c1}{// that the domain is x,y,z \PYGZbs{}in [\PYGZhy{}1,1] and set the number of spheres}
  \PYG{c+c1}{// and their radii.}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Sphere}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{spheres}\PYG{p}{;}

  \PYG{k}{constexpr} \PYG{n}{T}   \PYG{n}{radius} \PYG{o}{=} \PYG{l+m+mf}{0.02}\PYG{p}{;}
  \PYG{k}{constexpr} \PYG{k+kt}{int} \PYG{n}{M}      \PYG{o}{=} \PYG{l+m+mi}{40}\PYG{p}{;}
  \PYG{k}{constexpr} \PYG{k+kt}{int} \PYG{n}{Nsamp}  \PYG{o}{=} \PYG{l+m+mi}{1000}\PYG{p}{;}
  \PYG{k}{constexpr} \PYG{n}{T}   \PYG{n}{delta}  \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{2.0} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{M} \PYG{o}{*} \PYG{n}{radius}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{n}{M} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{if} \PYG{p}{(}\PYG{n}{delta} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error: \PYGZsq{}delta \PYGZlt{} 0.0\PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}

    \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{else} \PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{delta = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{delta} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{M}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{M}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{M}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{k}{const} \PYG{n}{T} \PYG{n}{x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{n}{i} \PYG{o}{*} \PYG{p}{(}\PYG{n}{delta} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{radius}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{radius}\PYG{p}{;}
        \PYG{k}{const} \PYG{n}{T} \PYG{n}{y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{n}{j} \PYG{o}{*} \PYG{p}{(}\PYG{n}{delta} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{radius}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{radius}\PYG{p}{;}
        \PYG{k}{const} \PYG{n}{T} \PYG{n}{z} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{n}{k} \PYG{o}{*} \PYG{p}{(}\PYG{n}{delta} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{radius}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{radius}\PYG{p}{;}

        \PYG{n}{Vec3} \PYG{n+nf}{center}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}

        \PYG{n}{spheres}\PYG{p}{.}\PYG{n}{emplace\PYGZus{}back}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{make\PYGZus{}shared}\PYG{o}{\PYGZlt{}}\PYG{n}{Sphere}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{center}\PYG{p}{,} \PYG{n}{radius}\PYG{p}{,} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}

  \PYG{c+c1}{// Make a standard union of these spheres. This is the union object which}
  \PYG{c+c1}{// iterates through each and every object in the scene.}
  \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Union}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{Sphere}\PYG{o}{\PYGZgt{}} \PYG{n}{slowUnion}\PYG{p}{(}\PYG{n}{spheres}\PYG{p}{,} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
  \PYG{c+c1}{// Make a fast union. To do this we must have the SDF objects (our vector of}
  \PYG{c+c1}{// spheres) as well as a way for enclosing these objects. We need to define}
\end{sphinxVerbatim}


\subsection{Creating the spheres}
\label{\detokenize{Example_Union:creating-the-spheres}}
\sphinxAtStartPar
In the first block of code we are defining one million spheres that lie on a three\sphinxhyphen{}dimensional lattice, where each sphere has a radius of one:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{k}{constexpr} \PYG{k+kt}{int} \PYG{n}{K} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

  \PYG{c+c1}{// Make a sphere array consisting of about M\PYGZca{}3 spheres. We assume}
  \PYG{c+c1}{// that the domain is x,y,z \PYGZbs{}in [\PYGZhy{}1,1] and set the number of spheres}
  \PYG{c+c1}{// and their radii.}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Sphere}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{spheres}\PYG{p}{;}

  \PYG{k}{constexpr} \PYG{n}{T}   \PYG{n}{radius} \PYG{o}{=} \PYG{l+m+mf}{0.02}\PYG{p}{;}
  \PYG{k}{constexpr} \PYG{k+kt}{int} \PYG{n}{M}      \PYG{o}{=} \PYG{l+m+mi}{40}\PYG{p}{;}
  \PYG{k}{constexpr} \PYG{k+kt}{int} \PYG{n}{Nsamp}  \PYG{o}{=} \PYG{l+m+mi}{1000}\PYG{p}{;}
  \PYG{k}{constexpr} \PYG{n}{T}   \PYG{n}{delta}  \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{2.0} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{M} \PYG{o}{*} \PYG{n}{radius}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{n}{M} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{if} \PYG{p}{(}\PYG{n}{delta} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error: \PYGZsq{}delta \PYGZlt{} 0.0\PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}

    \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{else} \PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{delta = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{delta} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Creating standard union}
\label{\detokenize{Example_Union:creating-standard-union}}
\sphinxAtStartPar
In the second block of code we are simply creating a standard signed distance function union:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{M}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
For implementation details regarding the standard union, see {\hyperref[\detokenize{ImplemUnion:chap-union}]{\sphinxcrossref{\DUrole{std,std-ref}{Unions}}}}.


\subsection{Creating BVH\sphinxhyphen{}enabled union}
\label{\detokenize{Example_Union:creating-bvh-enabled-union}}
\sphinxAtStartPar
In the third block of code we create a BVH\sphinxhyphen{}enabled union.
To do so, we must first provide a function which can create bounding volumes around each object:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
        \PYG{k}{const} \PYG{n}{T} \PYG{n}{z} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{n}{k} \PYG{o}{*} \PYG{p}{(}\PYG{n}{delta} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{radius}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{radius}\PYG{p}{;}

        \PYG{n}{Vec3} \PYG{n+nf}{center}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}

        \PYG{n}{spheres}\PYG{p}{.}\PYG{n}{emplace\PYGZus{}back}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{make\PYGZus{}shared}\PYG{o}{\PYGZlt{}}\PYG{n}{Sphere}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{center}\PYG{p}{,} \PYG{n}{radius}\PYG{p}{,} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}

  \PYG{c+c1}{// Make a standard union of these spheres. This is the union object which}
  \PYG{c+c1}{// iterates through each and every object in the scene.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here, we use axis\sphinxhyphen{}aligned boxes but we could also have used other types of bounding volumes.


\subsection{Typical output}
\label{\detokenize{Example_Union:typical-output}}
\sphinxAtStartPar
The above example shows two methods of creating unions.
When running the example the typical output is something like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Partitioning spheres
Computing distance with slow union
Computing distance with fast union
Distance and time using standard union = \PYGZhy{}1, which took 26.7353 ms
Distance and time using optimize union = \PYGZhy{}1, which took 0.003527 ms
Speedup = 7580.19
\end{sphinxVerbatim}

\sphinxAtStartPar
where we note that the optimized union was about 7500 times faster than the “standard” union.

\sphinxstepscope


\section{Integration with AMReX}
\label{\detokenize{Example_AMReX:integration-with-amrex}}\label{\detokenize{Example_AMReX::doc}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
This example requires you to install \sphinxhref{https://github.com/AMReX-Codes/amrex}{AMReX}
\end{sphinxadmonition}

\sphinxAtStartPar
This example is given in \sphinxcode{\sphinxupquote{Examples/AMReX\_DCEL/main.cpp}} and shows how to expose EBGeometry’s DCEL and BVH functionality to AMReX.

\sphinxAtStartPar
We will focus on the following parts of the code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* EBGeometry}
\PYG{c+cm}{ * Copyright © 2022 Robert Marskar}
\PYG{c+cm}{ * Please refer to Copyright.txt and LICENSE in the EBGeometry root directory.}
\PYG{c+cm}{ */}

\PYG{c+c1}{// AMReX includes}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}AMReX.H\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}AMReX\PYGZus{}EB2.H\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}AMReX\PYGZus{}EB2\PYGZus{}IF.H\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}AMReX\PYGZus{}ParmParse.H\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}AMReX\PYGZus{}PlotFileUtil.H\PYGZgt{}}

\PYG{c+c1}{// Our include}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}../../EBGeometry.hpp\PYGZdq{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{amrex}\PYG{p}{;}

\PYG{c+cm}{/*!}
\PYG{c+cm}{  @brief This is an AMReX\PYGZhy{}capable version of the EBGeometry BVH accelerator. It}
\PYG{c+cm}{  is templated as T, BV, K which indicate the EBGeometry precision, bounding}
\PYG{c+cm}{  volume, and tree degree.}
\PYG{c+cm}{*/}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BV}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{K}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{AMReXSDF}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Full constructor.}
\PYG{c+cm}{    @param[in] a\PYGZus{}filename File name. Must be an STL file.}
\PYG{c+cm}{  */}
  \PYG{n}{AMReXSDF}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}filename}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{m\PYGZus{}rootNode} \PYG{o}{=} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Parser}\PYG{o}{:}\PYG{o}{:}\PYG{n}{readIntoLinearBVH}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{a\PYGZus{}filename}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Copy constructor.}
\PYG{c+cm}{    @param[in] a\PYGZus{}other Other SDF.}
\PYG{c+cm}{  */}
  \PYG{n}{AMReXSDF}\PYG{p}{(}\PYG{k}{const} \PYG{n}{AMReXSDF}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}other}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{m\PYGZus{}rootNode} \PYG{o}{=} \PYG{n}{a\PYGZus{}other}\PYG{p}{.}\PYG{n}{m\PYGZus{}rootNode}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief AMReX\PYGZsq{}s implicit function definition.}
\PYG{c+cm}{  */}
  \PYG{n}{Real} \PYG{k}{operator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{n}{Real} \PYG{n}{x}\PYG{p}{,} \PYG{n}{Real} \PYG{n}{y}\PYG{p}{,} \PYG{n}{Real} \PYG{n}{z}\PYG{p}{)}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{using} \PYG{n}{Vec3} \PYG{o}{=} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{;}

    \PYG{k}{return} \PYG{n}{m\PYGZus{}rootNode}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{signedDistance}\PYG{p}{(}\PYG{n}{m\PYGZus{}rootNode}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{transformPoint}\PYG{p}{(}\PYG{n}{Vec3}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}\PYG{p}{;}

  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Also an AMReX implicit function implementation}
\PYG{c+cm}{  */}
  \PYG{k+kr}{inline} \PYG{n}{Real}
  \PYG{n+nf}{operator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealArray}\PYG{o}{\PYGZam{}} \PYG{n}{p}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{k}{operator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

\PYG{k}{protected}\PYG{o}{:}
  \PYG{c+cm}{/*!}
\PYG{c+cm}{    @brief Root node of the linearized BVH hierarchy.}
\PYG{c+cm}{  */}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BVH}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LinearBVH}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FaceT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m\PYGZus{}rootNode}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int}
\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Initialize}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{argv}\PYG{p}{)}\PYG{p}{;}

  \PYG{k+kt}{int} \PYG{n}{n\PYGZus{}cell}        \PYG{o}{=} \PYG{l+m+mi}{128}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{max\PYGZus{}grid\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{32}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{which\PYGZus{}geom}    \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{filename}\PYG{p}{;}

  \PYG{c+c1}{// read parameters}
  \PYG{n}{ParmParse} \PYG{n}{pp}\PYG{p}{;}
  \PYG{n}{pp}\PYG{p}{.}\PYG{n}{query}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{n\PYGZus{}cell}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{n\PYGZus{}cell}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{pp}\PYG{p}{.}\PYG{n}{query}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max\PYGZus{}grid\PYGZus{}size}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{max\PYGZus{}grid\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{pp}\PYG{p}{.}\PYG{n}{query}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{which\PYGZus{}geom}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{which\PYGZus{}geom}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{Geometry} \PYG{n}{geom}\PYG{p}{;}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{RealBox} \PYG{n}{rb}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{which\PYGZus{}geom} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// Airfoil case}
      \PYG{n}{rb}       \PYG{o}{=} \PYG{n}{RealBox}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{75}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{400}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{125}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../Resources/airfoil.stl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{which\PYGZus{}geom} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// Sphere case}
      \PYG{n}{rb}       \PYG{o}{=} \PYG{n}{RealBox}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{400}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{400}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{400}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{400}\PYG{p}{,} \PYG{l+m+mi}{400}\PYG{p}{,} \PYG{l+m+mi}{400}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../Resources/sphere.stl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{which\PYGZus{}geom} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// Dodecahedron}
      \PYG{n}{rb}       \PYG{o}{=} \PYG{n}{RealBox}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../Resources/dodecahedron.stl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{which\PYGZus{}geom} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// Horse}
      \PYG{n}{rb}       \PYG{o}{=} \PYG{n}{RealBox}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.12}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.12}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.12}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{0.12}\PYG{p}{,} \PYG{l+m+mf}{0.12}\PYG{p}{,} \PYG{l+m+mf}{0.12}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../Resources/horse.stl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{which\PYGZus{}geom} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// Car}
      \PYG{c+c1}{//	    rb = RealBox(\PYGZob{}\PYGZhy{}20,\PYGZhy{}20,\PYGZhy{}20\PYGZcb{}, \PYGZob{}20,20,20\PYGZcb{}); // Doesn\PYGZsq{}t work.}
      \PYG{n}{rb}       \PYG{o}{=} \PYG{n}{RealBox}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Works.}
      \PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../Resources/porsche.stl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{which\PYGZus{}geom} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// Orion}
      \PYG{n}{rb}       \PYG{o}{=} \PYG{n}{RealBox}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../Resources/orion.stl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{which\PYGZus{}geom} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// Armadillo}
      \PYG{n}{rb}       \PYG{o}{=} \PYG{n}{RealBox}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{75}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{125}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../Resources/armadillo.stl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{Array}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,} \PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}} \PYG{n}{is\PYGZus{}periodic}\PYG{p}{\PYGZob{}}\PYG{n+nb}{false}\PYG{p}{,} \PYG{n+nb}{false}\PYG{p}{,} \PYG{n+nb}{false}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{n}{Geometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Setup}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{rb}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{is\PYGZus{}periodic}\PYG{p}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Box} \PYG{n}{domain}\PYG{p}{(}\PYG{n}{IntVect}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{IntVect}\PYG{p}{(}\PYG{n}{n\PYGZus{}cell} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{geom}\PYG{p}{.}\PYG{n}{define}\PYG{p}{(}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{c+c1}{// Create our signed distance function. K is the tree degree while T is the}
  \PYG{c+c1}{// EBGeometry precision.}
  \PYG{k}{constexpr} \PYG{k+kt}{int} \PYG{n}{K} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

  \PYG{k}{using} \PYG{n}{T}    \PYG{o}{=} \PYG{k+kt}{float}\PYG{p}{;}
  \PYG{k}{using} \PYG{n}{Vec3} \PYG{o}{=} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
  \PYG{k}{using} \PYG{n}{BV}   \PYG{o}{=} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BoundingVolumes}\PYG{o}{:}\PYG{o}{:}\PYG{n}{AABBT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{;}

  \PYG{n}{AMReXSDF}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}} \PYG{n}{sdf}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{auto} \PYG{n}{gshop} \PYG{o}{=} \PYG{n}{EB2}\PYG{o}{:}\PYG{o}{:}\PYG{n}{makeShop}\PYG{p}{(}\PYG{n}{sdf}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{EB2}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Build}\PYG{p}{(}\PYG{n}{gshop}\PYG{p}{,} \PYG{n}{geom}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

  \PYG{c+c1}{// Put some data}
  \PYG{n}{MultiFab} \PYG{n}{mf}\PYG{p}{;}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{BoxArray} \PYG{n}{boxArray}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{.}\PYG{n}{Domain}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{boxArray}\PYG{p}{.}\PYG{n}{maxSize}\PYG{p}{(}\PYG{n}{max\PYGZus{}grid\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{DistributionMapping} \PYG{n}{dm}\PYG{p}{\PYGZob{}}\PYG{n}{boxArray}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{unique\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{EBFArrayBoxFactory}\PYG{o}{\PYGZgt{}} \PYG{n}{factory} \PYG{o}{=}
      \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{makeEBFabFactory}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{boxArray}\PYG{p}{,} \PYG{n}{dm}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{EBSupport}\PYG{o}{:}\PYG{o}{:}\PYG{n}{full}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{mf}\PYG{p}{.}\PYG{n}{define}\PYG{p}{(}\PYG{n}{boxArray}\PYG{p}{,} \PYG{n}{dm}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{MFInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{*}\PYG{n}{factory}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{mf}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{n}{EB\PYGZus{}WriteSingleLevelPlotfile}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rho}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{geom}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Finalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Constructing the BVH}
\label{\detokenize{Example_AMReX:constructing-the-bvh}}
\sphinxAtStartPar
When constructing the signed distance function we use the DCEL and BVH functionality directly in the constructor.
Note that we are performing the following steps:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Using the STL parser for creating a DCEL mesh.

\item {} 
\sphinxAtStartPar
Constructing a BVH for the DCEL faces.

\item {} 
\sphinxAtStartPar
Flattening the BVH tree for performance.

\end{itemize}


\subsection{Exposing signed distance functions}
\label{\detokenize{Example_AMReX:exposing-signed-distance-functions}}
\sphinxAtStartPar
Next, we expose the signed distance function to AMReX by implementing the functions

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Real} \PYG{k}{operator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{n}{Real} \PYG{n}{x}\PYG{p}{,} \PYG{n}{Real} \PYG{n}{y}\PYG{p}{,} \PYG{n}{Real} \PYG{n}{z}\PYG{p}{)}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the AMReX \sphinxcode{\sphinxupquote{DECL}} macros expand to \sphinxcode{\sphinxupquote{(Real x, Real y)}} in 2D, but here we assume that the user has compiled for 3D.

\sphinxstepscope


\section{Integration with Chombo3}
\label{\detokenize{Example_Chombo3:integration-with-chombo3}}\label{\detokenize{Example_Chombo3::doc}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
This example requires you to install \sphinxhref{https://github.com/applied-numerical-algorithms-group-lbnl/Chombo\_3.2}{Chombo3}.
\end{sphinxadmonition}

\sphinxAtStartPar
This example is given in \sphinxcode{\sphinxupquote{Examples/Chombo\_DCEL/main.cpp}} and shows how to expose EBGeometry’s DCEL and BVH functionality to Chombo3.

\sphinxAtStartPar
We will focus on the following parts of the code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Chombo includes}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}EBISLayout.H\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}DisjointBoxLayout.H\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}BaseIF.H\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}GeometryShop.H\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}ParmParse.H\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}EBIndexSpace.H\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}BRMeshRefine.H\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}EBCellFactory.H\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}EBLevelDataOps.H\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}EBAMRIO.H\PYGZdq{}}

\PYG{c+c1}{// Our includes}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}EBGeometry.hpp\PYGZdq{}}

\PYG{c+c1}{// Binding for exposing EBGeometry\PYGZsq{}s signed distance functions to Chombo}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BV}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{K}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{ChomboSDF} \PYG{o}{:} \PYG{k}{public} \PYG{n}{BaseIF}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{n}{ChomboSDF}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{k}{delete}\PYG{p}{;}

  \PYG{n}{ChomboSDF}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}filename}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{m\PYGZus{}rootNode} \PYG{o}{=} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Parser}\PYG{o}{:}\PYG{o}{:}\PYG{n}{readIntoLinearBVH}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{a\PYGZus{}filename}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{n}{ChomboSDF}\PYG{p}{(}\PYG{k}{const} \PYG{n}{ChomboSDF}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}other}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{m\PYGZus{}rootNode} \PYG{o}{=} \PYG{n}{a\PYGZus{}other}\PYG{p}{.}\PYG{n}{m\PYGZus{}rootNode}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{n}{Real}
  \PYG{n}{value}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}point}\PYG{p}{)} \PYG{k}{const} \PYG{k}{override} \PYG{k}{final}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{using} \PYG{n}{Vec3} \PYG{o}{=} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Vec3T}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if CH\PYGZus{}SPACEDIM == 2}
    \PYG{n}{Vec3} \PYG{n+nf}{p}\PYG{p}{(}\PYG{n}{a\PYGZus{}point}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{a\PYGZus{}point}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
    \PYG{n}{Vec3} \PYG{n+nf}{p}\PYG{p}{(}\PYG{n}{a\PYGZus{}point}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{a\PYGZus{}point}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{a\PYGZus{}point}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

    \PYG{k}{return} \PYG{n+nf}{Real}\PYG{p}{(}\PYG{n}{m\PYGZus{}rootNode}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{signedDistance}\PYG{p}{(}\PYG{n}{m\PYGZus{}rootNode}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{transformPoint}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{n}{BaseIF}\PYG{o}{*}
  \PYG{n}{newImplicitFunction}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{BaseIF}\PYG{o}{*}\PYG{p}{)}\PYG{p}{(}\PYG{k}{new} \PYG{n}{ChomboSDF}\PYG{p}{(}\PYG{o}{*}\PYG{k}{this}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

\PYG{k}{protected}\PYG{o}{:}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BVH}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LinearBVH}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DCEL}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FaceT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m\PYGZus{}rootNode}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int}
\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{constexpr} \PYG{k+kt}{int} \PYG{n}{K} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

  \PYG{k}{using} \PYG{n}{T}  \PYG{o}{=} \PYG{k+kt}{float}\PYG{p}{;}
  \PYG{k}{using} \PYG{n}{BV} \PYG{o}{=} \PYG{n}{EBGeometry}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BoundingVolumes}\PYG{o}{:}\PYG{o}{:}\PYG{n}{AABBT}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef CH\PYGZus{}MPI}
  \PYG{n}{MPI\PYGZus{}Init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{argc}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{argv}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

  \PYG{c+c1}{// Parse input file}
  \PYG{k+kt}{char}\PYG{o}{*}     \PYG{n}{inFile} \PYG{o}{=} \PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
  \PYG{n}{ParmParse} \PYG{n}{pp}\PYG{p}{(}\PYG{n}{argc} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{argv} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n}{inFile}\PYG{p}{)}\PYG{p}{;}

  \PYG{k+kt}{int} \PYG{n}{nCells}    \PYG{o}{=} \PYG{l+m+mi}{128}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{whichGeom} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{gridSize}  \PYG{o}{=} \PYG{l+m+mi}{16}\PYG{p}{;}
  \PYG{n}{pp}\PYG{p}{.}\PYG{n}{query}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{which\PYGZus{}geom}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{whichGeom}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{pp}\PYG{p}{.}\PYG{n}{query}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{n\PYGZus{}cells}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{nCells}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{pp}\PYG{p}{.}\PYG{n}{query}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{grid\PYGZus{}size}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{gridSize}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{RealVect}    \PYG{n}{loCorner}\PYG{p}{;}
  \PYG{n}{RealVect}    \PYG{n}{hiCorner}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{filename}\PYG{p}{;}

  \PYG{k}{if} \PYG{p}{(}\PYG{n}{whichGeom} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// Airfoil}
    \PYG{n}{loCorner} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{50} \PYG{o}{*} \PYG{n}{RealVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{;}
    \PYG{n}{hiCorner} \PYG{o}{=} \PYG{l+m+mi}{250} \PYG{o}{*} \PYG{n}{RealVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{;}

    \PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../Resources/airfoil.stl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{whichGeom} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// Sphere}
    \PYG{n}{loCorner} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{400} \PYG{o}{*} \PYG{n}{RealVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{;}
    \PYG{n}{hiCorner} \PYG{o}{=} \PYG{l+m+mi}{400} \PYG{o}{*} \PYG{n}{RealVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{;}

    \PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../Resources/sphere.stl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{whichGeom} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// Dodecahedron}
    \PYG{n}{loCorner} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{RealVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{;}
    \PYG{n}{hiCorner} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{RealVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{;}

    \PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../Resources/dodecahedron.stl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{whichGeom} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// Horse}
    \PYG{n}{loCorner} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.12} \PYG{o}{*} \PYG{n}{RealVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{;}
    \PYG{n}{hiCorner} \PYG{o}{=} \PYG{l+m+mf}{0.12} \PYG{o}{*} \PYG{n}{RealVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{;}

    \PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../Resources/horse.stl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{whichGeom} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// Porsche}
    \PYG{n}{loCorner} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10} \PYG{o}{*} \PYG{n}{RealVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{;}
    \PYG{n}{hiCorner} \PYG{o}{=} \PYG{l+m+mi}{10} \PYG{o}{*} \PYG{n}{RealVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{;}

    \PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../Resources/porsche.stl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{whichGeom} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// Orion}
    \PYG{n}{loCorner} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10} \PYG{o}{*} \PYG{n}{RealVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{;}
    \PYG{n}{hiCorner} \PYG{o}{=} \PYG{l+m+mi}{10} \PYG{o}{*} \PYG{n}{RealVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{;}

    \PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../Resources/orion.stl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{whichGeom} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// Armadillo}
    \PYG{n}{loCorner} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{125} \PYG{o}{*} \PYG{n}{RealVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{;}
    \PYG{n}{hiCorner} \PYG{o}{=} \PYG{l+m+mi}{125} \PYG{o}{*} \PYG{n}{RealVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{;}

    \PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../Resources/armadillo.stl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k}{auto} \PYG{n}{impFunc} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{BaseIF}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{k}{new} \PYG{n}{ChomboSDF}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{BV}\PYG{p}{,} \PYG{n}{K}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

  \PYG{c+c1}{// Set up the Chombo EB geometry.}
  \PYG{n}{ProblemDomain} \PYG{n}{domain}\PYG{p}{(}\PYG{n}{IntVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Zero}\PYG{p}{,} \PYG{p}{(}\PYG{n}{nCells} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{IntVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{const} \PYG{n}{Real}    \PYG{n}{dx} \PYG{o}{=} \PYG{p}{(}\PYG{n}{hiCorner}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{loCorner}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{nCells}\PYG{p}{;}
  \PYG{p}{;}

  \PYG{n}{GeometryShop}  \PYG{n}{workshop}\PYG{p}{(}\PYG{o}{*}\PYG{n}{impFunc}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{dx} \PYG{o}{*} \PYG{n}{RealVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Zero}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{EBIndexSpace}\PYG{o}{*} \PYG{n}{ebisPtr} \PYG{o}{=} \PYG{n}{Chombo\PYGZus{}EBIS}\PYG{o}{:}\PYG{o}{:}\PYG{n}{instance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{ebisPtr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{define}\PYG{p}{(}\PYG{n}{domain}\PYG{p}{,} \PYG{n}{loCorner}\PYG{p}{,} \PYG{n}{dx}\PYG{p}{,} \PYG{n}{workshop}\PYG{p}{,} \PYG{n}{gridSize}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

  \PYG{c+c1}{// Set up the grids}
  \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{procs}\PYG{p}{;}
  \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Box}\PYG{o}{\PYGZgt{}} \PYG{n}{boxes}\PYG{p}{;}
  \PYG{n}{domainSplit}\PYG{p}{(}\PYG{n}{domain}\PYG{p}{,} \PYG{n}{boxes}\PYG{p}{,} \PYG{n}{gridSize}\PYG{p}{,} \PYG{n}{gridSize}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{mortonOrdering}\PYG{p}{(}\PYG{n}{boxes}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{LoadBalance}\PYG{p}{(}\PYG{n}{procs}\PYG{p}{,} \PYG{n}{boxes}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{DisjointBoxLayout} \PYG{n}{dbl}\PYG{p}{(}\PYG{n}{boxes}\PYG{p}{,} \PYG{n}{procs}\PYG{p}{)}\PYG{p}{;}

  \PYG{c+c1}{// Fill the EBIS layout}
  \PYG{n}{EBISLayout} \PYG{n}{ebisl}\PYG{p}{;}
  \PYG{n}{ebisPtr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{fillEBISLayout}\PYG{p}{(}\PYG{n}{ebisl}\PYG{p}{,} \PYG{n}{dbl}\PYG{p}{,} \PYG{n}{domain}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

  \PYG{c+c1}{// Allocate some data that we can output}
  \PYG{n}{LevelData}\PYG{o}{\PYGZlt{}}\PYG{n}{EBCellFAB}\PYG{o}{\PYGZgt{}} \PYG{n}{data}\PYG{p}{(}\PYG{n}{dbl}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{IntVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Zero}\PYG{p}{,} \PYG{n}{EBCellFactory}\PYG{p}{(}\PYG{n}{ebisl}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit}\PYG{p}{(}\PYG{n}{dbl}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{EBCellFAB}\PYG{o}{\PYGZam{}} \PYG{n}{fab} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{fab}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{const} \PYG{n}{Box} \PYG{n}{region} \PYG{o}{=} \PYG{n}{fab}\PYG{p}{.}\PYG{n}{getRegion}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{n}{BoxIterator} \PYG{n}{bit}\PYG{p}{(}\PYG{n}{region}\PYG{p}{)}\PYG{p}{;} \PYG{n}{bit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{bit}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{n}{IntVect} \PYG{n}{iv} \PYG{o}{=} \PYG{n}{bit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

      \PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{pos}        \PYG{o}{=} \PYG{n}{loCorner} \PYG{o}{+} \PYG{p}{(}\PYG{n}{iv} \PYG{o}{+} \PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{RealVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{)} \PYG{o}{*} \PYG{n}{dx}\PYG{p}{;}
      \PYG{n}{fab}\PYG{p}{.}\PYG{n}{getFArrayBox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{n}{iv}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{=} \PYG{n}{impFunc}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{value}\PYG{p}{(}\PYG{n}{pos}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}

  \PYG{c+c1}{// Write to HDF5}
  \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{LevelData}\PYG{o}{\PYGZlt{}}\PYG{n}{EBCellFAB}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{o}{\PYGZgt{}} \PYG{n}{amrData}\PYG{p}{;}
  \PYG{n}{amrData}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{data}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{writeEBAMRname}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{amrData}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{example.hdf5}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef CH\PYGZus{}MPI}
  \PYG{n}{MPI\PYGZus{}Finalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Constructing the BVH}
\label{\detokenize{Example_Chombo3:constructing-the-bvh}}
\sphinxAtStartPar
When constructing the signed distance function we use the DCEL and BVH functionality directly in the constructor.
Note that we are performing the following steps:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Using the STL parser for creating a DCEL mesh.

\item {} 
\sphinxAtStartPar
Constructing a BVH for the DCEL faces.

\item {} 
\sphinxAtStartPar
Flattening the BVH tree for performance.

\end{itemize}


\subsection{Exposing signed distance functions}
\label{\detokenize{Example_Chombo3:exposing-signed-distance-functions}}
\sphinxAtStartPar
Next, we expose the signed distance function to Chombo3 by implementing the functions

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Real}
\PYG{n+nf}{value}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}point}\PYG{p}{)} \PYG{k}{const} \PYG{k}{override} \PYG{k}{final}
\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if CH\PYGZus{}SPACEDIM == 2}
  \PYG{n}{Vec3} \PYG{n}{p}\PYG{p}{(}\PYG{n}{a\PYGZus{}point}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{a\PYGZus{}point}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
  \PYG{n}{Vec3} \PYG{n}{p}\PYG{p}{(}\PYG{n}{a\PYGZus{}point}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{a\PYGZus{}point}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{a\PYGZus{}point}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

  \PYG{k}{return} \PYG{n}{Real}\PYG{p}{(}\PYG{n}{m\PYGZus{}rootNode}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{signedDistance}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that because Chombo3 can be compiled in either 2D or 3D, we put a Chombo preprocessor flag \sphinxcode{\sphinxupquote{CH\_SPACEDIM}} in order to translate the Chombo \sphinxcode{\sphinxupquote{RealVect}} to EBGeometry’s inherent 3D vector structure.


\chapter{References}
\label{\detokenize{index:references}}
\sphinxstepscope


\section{References}
\label{\detokenize{ZZReferences:references}}\label{\detokenize{ZZReferences::doc}}
\begin{sphinxthebibliography}{1}
\bibitem[1]{ZZReferences:id2}
\sphinxAtStartPar
J.A. Baerentzen and H. Aanaes. Signed distance computation using the angle weighted pseudonormal. \sphinxstyleemphasis{IEEE Transactions on Visualization and Computer Graphics}, 11(3):243\textendash{}253, 2005. \sphinxhref{https://doi.org/10.1109/TVCG.2005.49}{doi:10.1109/TVCG.2005.49}.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}