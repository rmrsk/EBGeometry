

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>DCEL &mdash; EBGeometry 1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/my_theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Signed distance function" href="ImplemSDF.html" />
    <link rel="prev" title="Bounding volume hierarchy" href="ImplemBVH.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> EBGeometry
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="Introduction.html#quickstart">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="Introduction.html#features">Features</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Concepts.html">Signed distance fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="Concepts.html#transformations">Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Concepts.html#unions">Unions</a></li>
<li class="toctree-l1"><a class="reference internal" href="DCEL.html">DCEL mesh structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="BVH.html">Bounding volume hierarchies</a></li>
</ul>
<p class="caption"><span class="caption-text">Implementation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ImplemVec.html">Vector types</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplemBVH.html">Bounding volume hierarchy</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">DCEL</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#classes">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#file-parsers">File parsers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bvh-integration">BVH integration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#construction-methods">Construction methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#code-example">Code example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ImplemSDF.html">Signed distance function</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplemUnion.html">Unions</a></li>
</ul>
<p class="caption"><span class="caption-text">Guided examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Example_Basic.html">Reading mesh files</a></li>
<li class="toctree-l1"><a class="reference internal" href="Example_Union.html">Unions</a></li>
<li class="toctree-l1"><a class="reference internal" href="Example_AMReX.html">Integration with AMReX</a></li>
</ul>
<p class="caption"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="ZZReferences.html">References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EBGeometry</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>DCEL</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/ImplemDCEL.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="dcel">
<span id="chap-implemdcel"></span><h1>DCEL<a class="headerlink" href="#dcel" title="Permalink to this headline">¶</a></h1>
<p>The DCEL functionality exists under the namespace <code class="docutils literal notranslate"><span class="pre">EBGeometry::Dcel</span></code> and contains the following functionality:</p>
<ul class="simple">
<li><p><strong>Fundamental data types</strong> like vertices, half-edges, polygons, and entire surface grids.</p></li>
<li><p><strong>Signed distance functionality</strong> for the above types.</p></li>
<li><p><strong>File parsers for reading files</strong> into DCEL structures.</p></li>
<li><p><strong>BVH functionality</strong> for putting DCEL grids into bounding volume hierarchies.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The DCEL functionality is <em>not</em> restricted to triangles, but supports N-sided polygons.</p>
</div>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<p>The main DCEL functionality (vertices, edges, faces) is provided by the following classes:</p>
<ul class="simple">
<li><p><strong>Vertices</strong> are implemented as a template <code class="docutils literal notranslate"><span class="pre">EBGeometry::Dcel::EdgeT</span></code></p></li>
</ul>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">VertexT</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
</pre></div>
</div>
<p>The DCEL vertex class stores the vertex position, normal vector, and the outgoing half-edge from the vertex.
Note that the class has member functions for computing the vertex pseudonormal, see <a class="reference internal" href="DCEL.html#chap-normaldcel"><span class="std std-ref">Normal vectors</span></a>.</p>
<p>The full API is given in the doxygen documentation <a class="reference external" href="doxygen/html/classDcel_1_1VertexT.html">here</a>.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>Edges</strong> are implemented as a template <code class="docutils literal notranslate"><span class="pre">EBGeometry::Dcel::EdgeT</span></code></p></li>
</ul>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">EdgeT</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
</pre></div>
</div>
<p>The half-edges store a reference to their face, as well as pointers to the previous edge, next edge, pair edge, and starting vertex.
For performance reasons, the edge also stores the length and inverse length of the edge.</p>
<p>The full API is given in the doxygen documentation <a class="reference external" href="doxygen/html/classDcel_1_1EdgeT.html">here</a>.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>Faces</strong> are implemented as a template <code class="docutils literal notranslate"><span class="pre">EBGeometry::Dcel::FaceT</span></code></p></li>
</ul>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">FaceT</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
</pre></div>
</div>
<p>For performance reasons, a polygon face stores all it’s half-edges (to avoid iteration when computing the signed distance).
It also stores:</p>
<ul class="simple">
<li><p>The normal vector.</p></li>
<li><p>A 2D embedding of the polygon face.</p></li>
<li><p>Centroid position.</p></li>
</ul>
<p>The normal vector and 2D embedding of the facet exist because the signed distance computation requires them.
The centroid position exists only because BVH partitioners will use it for partitioning the surface mesh.</p>
<p>The full API is given in the doxygen documentation <a class="reference external" href="doxygen/html/classDcel_1_1FaceT.html">here</a>.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>Mesh</strong> is implemented as a template <code class="docutils literal notranslate"><span class="pre">EBGeometry::Dcel::MeshT</span></code></p></li>
</ul>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">MeshT</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
</pre></div>
</div>
<p>The Mesh stores all the vertices, half-edges, and faces.
For example, to obtain all the facets one can call <code class="docutils literal notranslate"><span class="pre">EBGeometry::Dcel::MeshT&lt;T&gt;::getFaces()</span></code> which will return all the DCEL faces of the surface mesh.
Typically, the mesh is not created by the user but automatically created when reading the mesh from an input file.</p>
<p>The full API is given in the doxygen documentation <a class="reference external" href="doxygen/html/classDcel_1_1MeshT.html">here</a>.</p>
</div></blockquote>
<p>All of the above DCEL classes have member functions of the type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="nf">signedDistance</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a_point</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">T</span> <span class="nf">unsignedDistance2</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a_point</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
</pre></div>
</div>
<p>Thus, they fulfill the template requirements of the primitive type for the BVH implementation, see <a class="reference internal" href="ImplemBVH.html#chap-bvhconstraints"><span class="std std-ref">Template constraints</span></a>.
See <a class="reference internal" href="#chap-bvhintegration"><span class="std std-ref">BVH integration</span></a> for details regarding DCEL integration with BVHs.</p>
</div>
<div class="section" id="file-parsers">
<h2>File parsers<a class="headerlink" href="#file-parsers" title="Permalink to this headline">¶</a></h2>
<p>Routines for parsing surface files from grids into EBGeometry’s DCEL grids are given in the namespace <code class="docutils literal notranslate"><span class="pre">EBGeometry::Dcel::Parser</span></code>.
Currently, this is limited to the following file formats:</p>
<ul>
<li><p><strong>PLY</strong> Only ASCII formats currently supported, <a class="reference external" href="https://en.wikipedia.org/wiki/PLY_(file_format)">https://en.wikipedia.org/wiki/PLY_(file_format)</a>.</p>
<p>When reading a PLY file into the DCEL data structures, it is sufficient to call the following static function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">using</span> <span class="n">Mesh</span> <span class="o">=</span> <span class="n">EBGeometry</span><span class="p">::</span><span class="n">Dcel</span><span class="p">::</span><span class="n">MeshT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Mesh</span><span class="o">&gt;</span> <span class="n">EBGeometry</span><span class="p">::</span><span class="n">Parser</span><span class="p">::</span><span class="n">PLY</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">::</span><span class="n">readASCII</span><span class="p">(</span><span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">a_filename</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Although the parser will do it’s best to read files that contains holes or incomplete faces, success will fluctuate.
Moreover, the signed distance function is not well-defined for such cases.</p>
</div>
<p>Calling the <code class="docutils literal notranslate"><span class="pre">readASCII</span></code> function will read the input file (which is assumed to be a PLY file) and create the DCEL data structures.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the file format of your surface mesh file is not one of the above, consider either providing a new plugin or convert your file (e.g. to PLY) using MeshLab, Blender, etc.</p>
</div>
</div>
<div class="section" id="bvh-integration">
<span id="chap-bvhintegration"></span><h2>BVH integration<a class="headerlink" href="#bvh-integration" title="Permalink to this headline">¶</a></h2>
<p>DCEL functionality can easily be embedded in BVHs.
In this case it is the facets that are embedded in the BVHs, and we require that we can create bounding volumes that contain all the vertices in a facet.
Moreover, partitioning functions that partition a set of polygon faces into <code class="docutils literal notranslate"><span class="pre">K</span></code> new sets of faces are also required.</p>
<div class="section" id="construction-methods">
<h3>Construction methods<a class="headerlink" href="#construction-methods" title="Permalink to this headline">¶</a></h3>
<p>EBGeometry provides some simplistic functions that are needed (see <a class="reference internal" href="ImplemBVH.html#chap-bvhconstruction"><span class="std std-ref">Construction</span></a>) when building BVHs for DCEL geometries .</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The functions are defined in <code class="file docutils literal notranslate"><span class="pre">Source/EBGeometry_DcelBVH.hpp</span></code>.</p>
</div>
<p>For the bounding volume constructor, we provide a function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BV</span><span class="o">&gt;</span>
  <span class="n">BVH</span><span class="o">::</span><span class="n">BVConstructorT</span><span class="o">&lt;</span><span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">BV</span><span class="o">&gt;</span> <span class="n">defaultBVConstructor</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">a_primitive</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">BV</span><span class="p">(</span><span class="n">a_primitive</span><span class="o">-&gt;</span><span class="n">getAllVertexCoordinates</span><span class="p">());</span>
  <span class="p">};</span>  
</pre></div>
</div>
<p>Note the extra template constraint on the bounding volume type <code class="docutils literal notranslate"><span class="pre">BV</span></code>, which must be able to construct a bounding volume from a finite point set (the vertex coordinates).</p>
<p>For the stop function we provide a simple function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">primitivesPerLeafNode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="o">&gt;</span> 
  <span class="n">BVH</span><span class="o">::</span><span class="n">StopFunctionT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">defaultStopFunction</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">BVH</span><span class="o">::</span><span class="n">NodeT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;&amp;</span> <span class="n">a_node</span><span class="p">){</span>
    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">primitives</span> <span class="o">=</span> <span class="n">a_node</span><span class="p">.</span><span class="n">getPrimitives</span><span class="p">();</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">numPrims</span>     <span class="o">=</span> <span class="n">primitives</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    
    <span class="k">return</span> <span class="n">numPrims</span> <span class="o">&lt;=</span> <span class="n">primitivesPerLeafNode</span> <span class="o">||</span> <span class="n">numPrims</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span>
  <span class="p">};</span>
</pre></div>
</div>
<p>Note that this simply terminates the leaf partitioning if there are not enough primitives (polygon faces) available, or there are fewer than a pre-defined number of primitives.</p>
<p>For the partitioning function we include a simple function that partitions the primites along the longest axis:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="o">&gt;</span>
  <span class="n">BVH</span><span class="o">::</span><span class="n">PartitionerT</span><span class="o">&lt;</span><span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">spatialSplitPartitioner</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a_primitives</span><span class="p">){</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">numPrimitives</span> <span class="o">=</span> <span class="n">a_primitives</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    
    <span class="c1">// Compute the coordinate direction with the longest extent. This will be our splitting direction.  </span>
    <span class="k">auto</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">a_primitives</span><span class="p">){</span>
      <span class="n">lo</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">getCentroid</span><span class="p">());</span>
      <span class="n">hi</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">getCentroid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">delta</span>   <span class="o">=</span> <span class="p">(</span><span class="n">hi</span><span class="o">-</span><span class="n">lo</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">splitDir</span> <span class="o">=</span> <span class="n">delta</span><span class="p">.</span><span class="n">maxDir</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

    <span class="c1">// Sort the primitives along the above coordinate direction. </span>
    <span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sortedPrimitives</span><span class="p">(</span><span class="n">a_primitives</span><span class="p">);</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">sortedPrimitives</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sortedPrimitives</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
	      <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">f1</span><span class="p">,</span>
		  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">f2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">f1</span><span class="o">-&gt;</span><span class="n">getCentroid</span><span class="p">(</span><span class="n">splitDir</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">f2</span><span class="o">-&gt;</span><span class="n">getCentroid</span><span class="p">(</span><span class="n">splitDir</span><span class="p">);</span>
	      <span class="p">});</span>


    <span class="c1">// Figure out the indices in the vector where we do the splits. </span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">almostEqualChunkSize</span> <span class="o">=</span> <span class="n">numPrimitives</span> <span class="o">/</span> <span class="n">K</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">remainder</span>                  <span class="o">=</span> <span class="n">numPrimitives</span> <span class="o">%</span> <span class="n">K</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">startIndices</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">endIndices</span><span class="p">;</span>

    <span class="n">startIndices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">endIndices</span>  <span class="p">[</span><span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numPrimitives</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
      <span class="n">startIndices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">startIndices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">almostEqualChunkSize</span><span class="p">;</span>

      <span class="k">if</span><span class="p">(</span><span class="n">remainder</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
	<span class="n">startIndices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">remainder</span><span class="o">--</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
      <span class="n">endIndices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">startIndices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>


    <span class="c1">// Put the primitives in separate lists and return them back to the BVH node. </span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">subVolumePrimitives</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
      <span class="k">typename</span> <span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">first</span> <span class="o">=</span> <span class="n">sortedPrimitives</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">startIndices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">typename</span> <span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">last</span>  <span class="o">=</span> <span class="n">sortedPrimitives</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">endIndices</span>  <span class="p">[</span><span class="n">i</span><span class="p">];</span>
      
      <span class="n">subVolumePrimitives</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Return as we must.</span>
    <span class="k">return</span> <span class="n">subVolumePrimitives</span><span class="p">;</span>
  <span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="code-example">
<h3>Code example<a class="headerlink" href="#code-example" title="Permalink to this headline">¶</a></h3>
<p>Constructing a compact BVH representation of polygon mesh is therefore done as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">T</span>    <span class="o">=</span> <span class="kt">float</span><span class="p">;</span>
<span class="k">using</span> <span class="n">BV</span>   <span class="o">=</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">BoundingVolumes</span><span class="o">::</span><span class="n">AABBT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Vec3</span> <span class="o">=</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Face</span> <span class="o">=</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">Dcel</span><span class="o">::</span><span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

<span class="c1">// Read the mesh from file and put it in a DCEL format.</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">EBGeometry</span><span class="o">::</span><span class="n">Dcel</span><span class="o">::</span><span class="n">Mesh</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">Dcel</span><span class="o">::</span><span class="n">Parser</span><span class="o">::</span><span class="n">Ply</span><span class="p">(</span><span class="s">&quot;MyFile.ply&quot;</span><span class="p">);</span>

<span class="c1">// Make a BVH node and build the BVH.</span>
<span class="k">auto</span> <span class="n">root</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">EBGeometry</span><span class="o">::</span><span class="n">BVH</span><span class="o">::</span><span class="n">NodeT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Face</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">mesh</span><span class="o">-&gt;</span><span class="n">getFaces</span><span class="p">());</span>

<span class="c1">// Build the BVH hierarchy</span>
<span class="n">root</span><span class="o">-&gt;</span><span class="n">topDownSortAndPartitionPrimitives</span><span class="p">(</span><span class="n">EBGeometry</span><span class="o">::</span><span class="n">Dcel</span><span class="o">::</span><span class="n">defaultBVConstructor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">BV</span><span class="o">&gt;</span><span class="p">,</span>
                                        <span class="n">EBGeometry</span><span class="o">::</span><span class="n">Dcel</span><span class="o">::</span><span class="n">spatialSplitPartitioner</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span><span class="p">,</span>
                                        <span class="n">EBGeometry</span><span class="o">::</span><span class="n">Dcel</span><span class="o">::</span><span class="n">defaultStopFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span><span class="p">);</span>

<span class="c1">// Flatten the tree onto a tighter representation. Then delete the old tree.</span>
<span class="k">auto</span> <span class="n">compactBVH</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">flattenTree</span><span class="p">();</span>

<span class="n">root</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ImplemSDF.html" class="btn btn-neutral float-right" title="Signed distance function" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ImplemBVH.html" class="btn btn-neutral float-left" title="Bounding volume hierarchy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, Robert Marskar

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>