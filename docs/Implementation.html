

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Vector types &mdash; EBGeometry 1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/my_theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="&lt;no title&gt;" href="Examples.html" />
    <link rel="prev" title="Bounding volume hierarchies" href="BVH.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> EBGeometry
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="Introduction.html#quickstart">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="Introduction.html#features">Features</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Concepts.html">Signed distance fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="Concepts.html#transformations">Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Concepts.html#unions">Unions</a></li>
<li class="toctree-l1"><a class="reference internal" href="DCEL.html">DCEL mesh structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="BVH.html">Bounding volume hierarchies</a></li>
</ul>
<p class="caption"><span class="caption-text">Implementation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Vector types</a></li>
<li class="toctree-l1"><a class="reference internal" href="#bounding-volume-hierarchy">Bounding volume hierarchy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#template-constraints">Template constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bounding-volumes">Bounding volumes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#construction">Construction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#compact-form">Compact form</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#dcel">DCEL</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#classes">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#file-parsers">File parsers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bvh-integration">BVH integration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#construction-methods">Construction methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#code-example">Code example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#signed-distance-function">Signed distance function</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#transformations">Transformations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#analytic-functions">Analytic functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#unions">Unions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#standard-union">Standard union</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bvh-enabled-union">BVH-enabled union</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Guided examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Example_Basic.html">Reading mesh files</a></li>
<li class="toctree-l1"><a class="reference internal" href="Example_Union.html">Unions</a></li>
<li class="toctree-l1"><a class="reference internal" href="Example_AMReX.html">Integration with AMReX</a></li>
</ul>
<p class="caption"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="ZZReferences.html">References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EBGeometry</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Vector types</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/Implementation.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p id="chap-implementation">Here, we consider the basic EBGeometry API.
EBGeometry is a header-only library, implemented under it’s own namespace <code class="docutils literal notranslate"><span class="pre">EBGeometry</span></code>.
Various major components, like BVHs and DCEL, are implemented under namespaces <code class="docutils literal notranslate"><span class="pre">EBGeometry::BVH</span></code> and <code class="docutils literal notranslate"><span class="pre">EBGeometry::Dcel</span></code>.
Below, we consider a brief introduction to the API and implementation details of EBGeometry.</p>
<div class="section" id="vector-types">
<h1>Vector types<a class="headerlink" href="#vector-types" title="Permalink to this headline">¶</a></h1>
<p>EBGeometry runs it’s own vector types <code class="docutils literal notranslate"><span class="pre">Vec2T</span></code> and <code class="docutils literal notranslate"><span class="pre">Vec3T</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">Vec2T</span></code> is a two-dimensional Cartesian vector.
It is templated as</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">EBGeometry</span> <span class="p">{</span>
   <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
   <span class="k">class</span> <span class="nc">Vec2T</span> <span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
      <span class="n">T</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// First component.</span>
      <span class="n">T</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// Second component.</span>
   <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Most of EBGeometry is written as three-dimensional code, but <code class="docutils literal notranslate"><span class="pre">Vec2T</span></code> is needed for DCEL functionality when determining if a point projects onto the interior or exterior of a planar polygon, see <a class="reference internal" href="DCEL.html#chap-dcel"><span class="std std-ref">DCEL mesh structure</span></a>.
<code class="docutils literal notranslate"><span class="pre">Vec2T</span></code> has “most” common arithmetic operators like the dot product, length, multiplication operators and so on.</p>
<p><code class="docutils literal notranslate"><span class="pre">Vec3T</span></code> is a three-dimensional Cartesian vector type with precision <code class="docutils literal notranslate"><span class="pre">T</span></code>.
It is templated as</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">EBGeometry</span> <span class="p">{</span>
   <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
   <span class="k">class</span> <span class="nc">Vec3T</span> <span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
      <span class="n">T</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="n">x</span><span class="p">;</span>
   <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Like <code class="docutils literal notranslate"><span class="pre">Vec2T</span></code>, <code class="docutils literal notranslate"><span class="pre">Vec3T</span></code> has numerous routines for performing most vector-related operations like addition, subtraction, dot products and so on.</p>
</div>
<div class="section" id="bounding-volume-hierarchy">
<h1>Bounding volume hierarchy<a class="headerlink" href="#bounding-volume-hierarchy" title="Permalink to this headline">¶</a></h1>
<p>The BVH functionality is encapsulated in the namespace <code class="docutils literal notranslate"><span class="pre">EBGeometry::BVH</span></code>.
For the full API, see <a class="reference external" href="doxygen/html/namespaceBVH.html">the doxygen API</a>
There are two types of BVHs supported.</p>
<ul class="simple">
<li><p><strong>Direct BVHs</strong> where the nodes are stored in build order and contain references to their children, and the leaf holds primitives.</p></li>
<li><p><strong>Compact BVHs</strong> where the nodes are stored in depth-first order and contain index offsets to children and primitives.</p></li>
</ul>
<p>The direct BVH is encapsulated by a class</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">NodeT</span><span class="p">;</span>
</pre></div>
</div>
<p>The above template parameters are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code> Floating-point precision.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">P</span></code> Primitive type to be partitioned.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BV</span></code> Bounding volume type.*</p></li>
</ul>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">K</span></code> BVH degree. <code class="docutils literal notranslate"><span class="pre">K=2</span></code> will yield a binary tree, <code class="docutils literal notranslate"><span class="pre">K=3</span></code> yields a tertiary tree and so on.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NodeT</span></code> describes regular and leaf nodes in the BVH, and has member functions for setting primitives, bounding volumes, and so on.
Importantly, <code class="docutils literal notranslate"><span class="pre">NodeT</span></code> is the BVH builder node, i.e. it is the class through which we recursively build the BVH, see <a class="reference internal" href="#chap-bvhconstruction"><span class="std std-ref">Construction</span></a>.
The compact BVH is discussed below in <a class="reference internal" href="#chap-linearbvh"><span class="std std-ref">Compact form</span></a>.</p>
<p>For getting the signed or unsigned distance, <code class="docutils literal notranslate"><span class="pre">NodeT</span></code> has provides the following two member functions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">NodeT</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="kr">inline</span>
    <span class="n">T</span> <span class="n">signedDistance</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec3</span><span class="o">&amp;</span> <span class="n">a_point</span><span class="p">,</span> <span class="k">const</span> <span class="n">Prune</span> <span class="n">a_pruning</span> <span class="o">=</span> <span class="n">Prune</span><span class="o">::</span><span class="n">Ordered2</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>    
</pre></div>
</div>
<div class="section" id="template-constraints">
<span id="chap-bvhconstraints"></span><h2>Template constraints<a class="headerlink" href="#template-constraints" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>The primitive type <code class="docutils literal notranslate"><span class="pre">P</span></code> must have the following functions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">signedDistance(const</span> <span class="pre">Vec3T&lt;T&gt;&amp;</span> <span class="pre">x)</span></code>, which returns the signed distance to the primitive.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">unsignedDistance2(const</span> <span class="pre">Vec3T&lt;T&gt;&amp;</span> <span class="pre">x)</span></code>, which returns the square distance to the primitive.</p></li>
</ul>
<p>The function <code class="docutils literal notranslate"><span class="pre">unsignedDistance2</span></code> exists for performance reasons during the BVH traversal.
Using the square distance during BVH traversal means that the square root and sign does not have to be obtained until the end of the traversal.</p>
</li>
<li><p>The bounding volume type <code class="docutils literal notranslate"><span class="pre">BV</span></code> must have the following functions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">getDistance(const</span> <span class="pre">Vec3T&lt;T&gt;&amp;</span> <span class="pre">x)</span></code> which returns the distance from the point <code class="docutils literal notranslate"><span class="pre">x</span></code> to the bounding volume.
Note that if <code class="docutils literal notranslate"><span class="pre">x</span></code> lies within the bounding volume, the function should return a value of zero.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">getDistance2(const</span> <span class="pre">Vec3T&lt;T&gt;&amp;</span> <span class="pre">x)</span></code> which returns the square distance from the point <code class="docutils literal notranslate"><span class="pre">x</span></code> to the bounding volume.
Again, if <code class="docutils literal notranslate"><span class="pre">x</span></code> lies within the bounding volume, the function should return a value of zero.</p></li>
<li><p>A constructor <code class="docutils literal notranslate"><span class="pre">BV(const</span> <span class="pre">std::vector&lt;BV&gt;&amp;</span> <span class="pre">a_otherBVs)</span></code> that permit creation of a bounding volume that encloses other bounding volumes of the same type.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">K</span></code> should be greater or equal to 2.</p></li>
</ul>
<p>Note that the above constraints apply only to the BVH itself.
Partitioning functions (which are, in principle, supplied by the user) may impose extra constraints.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>EBGeometry’s BVH implementations fulfill their own template requirements on the primitive type <code class="docutils literal notranslate"><span class="pre">P</span></code>.
This means that objects that are themselves described by BVHs (such as triangulations) can be embedded in another BVH, permitting BVH-of-BVH type of scenes.</p>
</div>
</div>
<div class="section" id="bounding-volumes">
<h2>Bounding volumes<a class="headerlink" href="#bounding-volumes" title="Permalink to this headline">¶</a></h2>
<p>EBGeometry supports the following bounding volumes, which are defined in <code class="file docutils literal notranslate"><span class="pre">EBGeometry_BoundingVolumes.hpp`</span></code>:</p>
<ul class="simple">
<li><p><strong>BoundingSphere</strong>, templated as <code class="docutils literal notranslate"><span class="pre">EBGeometry::BoundingVolumes::BoundingSphereT&lt;T&gt;</span></code> and describes a bounding sphere.
Various constructors are available.</p></li>
<li><p><strong>Axis-aligned bounding box</strong>, or AABB for short.
This is templated as <code class="docutils literal notranslate"><span class="pre">EBGeometry::BoundingVolumes::AABBT&lt;T&gt;</span></code>.</p></li>
</ul>
<p>For full API details, see <a class="reference external" href="doxygen/html/namespaceBoundingVolumes.html">the doxygen API</a>.</p>
</div>
<div class="section" id="construction">
<span id="chap-bvhconstruction"></span><h2>Construction<a class="headerlink" href="#construction" title="Permalink to this headline">¶</a></h2>
<p>Constructing a BVH is done by</p>
<ul class="simple">
<li><p>Creating a root node and providing it with the geometric primitives.</p></li>
<li><p>Partitioning the BVH by providing.</p></li>
</ul>
<p>The first step is usually a matter of simply constructing the root node using the following constructor:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="o">&gt;</span>
<span class="n">NodeT</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">a_primitives</span><span class="p">).</span>
</pre></div>
</div>
<p>That is, the constructor takes a list of primitives to be put in the node.
For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">T</span>    <span class="o">=</span> <span class="kt">float</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Node</span> <span class="o">=</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">BVH</span><span class="o">::</span><span class="n">NodeT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">MyPrimitives</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">primitives</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">root</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">(</span><span class="n">primitives</span><span class="p">);</span>
</pre></div>
</div>
<p>The second step is to recursively build the BVH, which is done through the function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">StopFunctionT</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="k">const</span> <span class="n">NodeT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;&amp;</span> <span class="n">a_node</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BV</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">BVConstructorT</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">BV</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">P</span><span class="o">&gt;&amp;</span> <span class="n">a_primitive</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">PartitionerT</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">PrimitiveListT</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">PrimitiveListT</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span> <span class="n">a_primitives</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="o">&gt;</span>
<span class="n">NodeT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;::</span><span class="n">topDownSortAndPartitionPrimitives</span><span class="p">(</span><span class="k">const</span> <span class="n">BVConstructorT</span><span class="o">&lt;</span><span class="n">P</span><span class="p">,</span> <span class="n">BV</span><span class="o">&gt;</span><span class="p">,</span>
                                                      <span class="k">const</span> <span class="n">PartitionerT</span><span class="o">&lt;</span><span class="n">P</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span><span class="p">,</span>
                                                      <span class="k">const</span> <span class="n">StopFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span><span class="p">);</span>
</pre></div>
</div>
<p>Although seemingly complicated, the input arguments are simply polymorphic functions of the type indicated above, and have the following responsibilities:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">StopFunctionT</span></code> simply takes a <code class="docutils literal notranslate"><span class="pre">NodeT</span></code> as input argument and determines if the node should be partitioned further.
A basic implementation which terminates the recursion when the leaf node has reached the minimum number of primitives is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EBGeometry</span><span class="o">::</span><span class="n">BVH</span><span class="o">::</span><span class="n">StopFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">stopFunc</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">NodeT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;&amp;</span> <span class="n">a_node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">a_node</span><span class="p">.</span><span class="n">getNumPrimitives</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This will terminate the partitioning when the node has less than <code class="docutils literal notranslate"><span class="pre">K</span></code> primitives (in which case it <em>can’t</em> be partitioned further).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">BVConstructorT</span></code> takes a single primitive (or strictly speaking a pointer to the primitive) and returns a bounding volume that encloses it.
For example, if the primitives <code class="docutils literal notranslate"><span class="pre">P</span></code> are signed distance function spheres (see <a class="reference internal" href="#chap-analyticsdf"><span class="std std-ref">Analytic functions</span></a>), the BV constructor can be implemented
with AABB bounding volumes as;</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">T</span>      <span class="o">=</span> <span class="kt">float</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Vec3</span>   <span class="o">=</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">AABB</span>   <span class="o">=</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">BoundingVolumes</span><span class="o">::</span><span class="n">AABBT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Sphere</span> <span class="o">=</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">SphereSDF</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">EBGeometry</span><span class="o">::</span><span class="n">BVH</span><span class="o">::</span><span class="n">BVConstructor</span><span class="o">&lt;</span><span class="n">SDF</span><span class="p">,</span> <span class="n">AABB</span><span class="o">&gt;</span> <span class="n">bvConstructor</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">SDF</span><span class="o">&gt;&amp;</span> <span class="n">a_sdf</span><span class="p">){</span>
   <span class="k">const</span> <span class="n">Sphere</span><span class="o">&amp;</span> <span class="n">sph</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Sphere</span><span class="o">&amp;&gt;</span> <span class="p">(</span><span class="o">*</span><span class="n">a_sdf</span><span class="p">);</span>

   <span class="k">const</span> <span class="n">Vec3</span><span class="o">&amp;</span> <span class="n">sphereCenter</span> <span class="o">=</span> <span class="n">sph</span><span class="p">.</span><span class="n">getCenter</span><span class="p">();</span>
   <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span>    <span class="n">sphereRadius</span> <span class="o">=</span> <span class="n">sph</span><span class="p">.</span><span class="n">getRadius</span><span class="p">();</span>

   <span class="k">const</span> <span class="n">Vec3</span>  <span class="n">lo</span> <span class="o">=</span> <span class="n">sphereCenter</span> <span class="o">-</span> <span class="n">r</span><span class="o">*</span><span class="n">Vec3</span><span class="o">::</span><span class="n">one</span><span class="p">();</span>
   <span class="k">const</span> <span class="n">Vec3</span>  <span class="n">hi</span> <span class="o">=</span> <span class="n">sphereCenter</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">Vec3</span><span class="o">::</span><span class="n">one</span><span class="p">();</span>

   <span class="k">return</span> <span class="nf">AABB</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">PartitionerT</span></code> is the partitioner function when splitting a leaf node into <code class="docutils literal notranslate"><span class="pre">K</span></code> new leaves.
The function takes an list of primitives which it partitions into <code class="docutils literal notranslate"><span class="pre">K</span></code> new list of primitives, i.e. it encapsulates <a class="reference internal" href="BVH.html#equation-partition">Eq. 2</a>.
As an example, we include the <em>spatial split</em> partitioner that is provided for integrating BVH and DCEL functionality.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="o">&gt;</span>
  <span class="n">BVH</span><span class="o">::</span><span class="n">PartitionerT</span><span class="o">&lt;</span><span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">spatialSplitPartitioner</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a_primitives</span><span class="p">){</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">numPrimitives</span> <span class="o">=</span> <span class="n">a_primitives</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    
    <span class="c1">// Compute the coordinate direction with the longest extent. This will be our splitting direction.  </span>
    <span class="k">auto</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">a_primitives</span><span class="p">){</span>
      <span class="n">lo</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">getCentroid</span><span class="p">());</span>
      <span class="n">hi</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">getCentroid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">delta</span>   <span class="o">=</span> <span class="p">(</span><span class="n">hi</span><span class="o">-</span><span class="n">lo</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">splitDir</span> <span class="o">=</span> <span class="n">delta</span><span class="p">.</span><span class="n">maxDir</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

    <span class="c1">// Sort the primitives along the above coordinate direction. </span>
    <span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sortedPrimitives</span><span class="p">(</span><span class="n">a_primitives</span><span class="p">);</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">sortedPrimitives</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sortedPrimitives</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
	      <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">f1</span><span class="p">,</span>
		  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">f2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">f1</span><span class="o">-&gt;</span><span class="n">getCentroid</span><span class="p">(</span><span class="n">splitDir</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">f2</span><span class="o">-&gt;</span><span class="n">getCentroid</span><span class="p">(</span><span class="n">splitDir</span><span class="p">);</span>
	      <span class="p">});</span>


    <span class="c1">// Figure out the indices in the vector where we do the splits. </span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">almostEqualChunkSize</span> <span class="o">=</span> <span class="n">numPrimitives</span> <span class="o">/</span> <span class="n">K</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">remainder</span>                  <span class="o">=</span> <span class="n">numPrimitives</span> <span class="o">%</span> <span class="n">K</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">startIndices</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">endIndices</span><span class="p">;</span>

    <span class="n">startIndices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">endIndices</span>  <span class="p">[</span><span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numPrimitives</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
      <span class="n">startIndices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">startIndices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">almostEqualChunkSize</span><span class="p">;</span>

      <span class="k">if</span><span class="p">(</span><span class="n">remainder</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
	<span class="n">startIndices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">remainder</span><span class="o">--</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
      <span class="n">endIndices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">startIndices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>


    <span class="c1">// Put the primitives in separate lists and return them back to the BVH node. </span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">subVolumePrimitives</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
      <span class="k">typename</span> <span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">first</span> <span class="o">=</span> <span class="n">sortedPrimitives</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">startIndices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">typename</span> <span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">last</span>  <span class="o">=</span> <span class="n">sortedPrimitives</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">endIndices</span>  <span class="p">[</span><span class="n">i</span><span class="p">];</span>
      
      <span class="n">subVolumePrimitives</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Return as we must.</span>
    <span class="k">return</span> <span class="n">subVolumePrimitives</span><span class="p">;</span>
  <span class="p">};</span>
</pre></div>
</div>
<p>In the above, we are taking a list of DCEL facets in the input argument (<code class="docutils literal notranslate"><span class="pre">PrimitiveList&lt;T&gt;</span></code> expands to <code class="docutils literal notranslate"><span class="pre">std::vector&lt;std::shared_ptr&lt;const</span> <span class="pre">FaceT&lt;T&gt;</span> <span class="pre">&gt;</span></code>).
We then compute the centroid locations of each facet and figure out along which coordinate axis we partition the objects (called <code class="docutils literal notranslate"><span class="pre">splitDir</span></code> above).
The input primitives are then sorted based on the facet centroid locations in the <code class="docutils literal notranslate"><span class="pre">splitDir</span></code> direction, and they are partitioned into <code class="docutils literal notranslate"><span class="pre">K</span></code> almost-equal chunks.
These partitions are returned and become primitives in the new leaf nodes.</p>
<p>There is also en example of the same type of partitioning for the BVH-accelerated union, see <a class="reference external" href="doxygen/html/classUnionBVH.html">UnionBVH</a></p>
</li>
</ul>
<p>In general, users are free to construct their BVHs in their own way if they choose.
For the most part this will include the construction of their own bounding volumes and/or partitioners.</p>
</div>
<div class="section" id="compact-form">
<span id="chap-linearbvh"></span><h2>Compact form<a class="headerlink" href="#compact-form" title="Permalink to this headline">¶</a></h2>
<p>In addition to the standard BVH node <code class="docutils literal notranslate"><span class="pre">NodeT&lt;T,</span> <span class="pre">P,</span> <span class="pre">BV,</span> <span class="pre">K&gt;</span></code>, EBGeometry provides a more compact formulation of the BVH hierarchy where the nodes are stored in depth-first order.
The “linearized” BVH can be automatically constructed from the standard BVH but not vice versa.</p>
<div class="figure align-center" id="id5">
<a class="reference internal image-reference" href="_images/CompactBVH.png"><img alt="_images/CompactBVH.png" src="_images/CompactBVH.png" style="width: 240px;" /></a>
<p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">Compact BVH representation.
The original BVH is traversed from top-to-bottom along the branches and laid out in linear memory.
Each interior node gets a reference (index offset) to their children nodes.</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
<p>The rationale for reorganizing the BVH in compact form is it’s tighter memory footprint and depth-first ordering which allows more efficient traversal downwards in the BVH tree.
To encapsulate the compact BVH we provide two classes:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">LinearNodeT</span></code> which encapsulates a node, but rather than storing the primitives and pointers to child nodes it stores offsets along the 1D arrays.
Just like <code class="docutils literal notranslate"><span class="pre">NodeT</span></code> the class is templated:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">LinearNodeT</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
  <span class="k">protected</span><span class="o">:</span>

    <span class="cm">/*!</span>
<span class="cm">      @brief Bounding volume. </span>
<span class="cm">    */</span>
    <span class="n">BV</span> <span class="n">m_boundingVolume</span><span class="p">;</span>

    <span class="cm">/*!</span>
<span class="cm">      @brief Offset into primitives array</span>
<span class="cm">    */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">m_primitivesOffset</span><span class="p">;</span>    

    <span class="cm">/*!</span>
<span class="cm">      @brief Number of primitives</span>
<span class="cm">    */</span>
    <span class="kt">int</span> <span class="n">m_numPrimitives</span><span class="p">;</span>

    <span class="cm">/*!</span>
<span class="cm">      @brief Offset to child nodes. </span>
<span class="cm">    */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">m_childOffsets</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">LinearNodeT</span></code> has a smaller memory footprint and should fit in one CPU word in floating-point precision and two CPU words in double point precision.
The performance benefits of further memory alignment have not been investigated.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">LinearNodeT</span></code> only stores offsets to child nodes and primitives, which are assumed to be stored (somewhere) as</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LinearNodeT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">linearNodes</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">P</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">primitives</span><span class="p">;</span>
</pre></div>
</div>
<p>Thus, for a given node we can check if it is a leaf node (<code class="docutils literal notranslate"><span class="pre">m_numPrimitives</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>) and if it is we can get the children through the <code class="docutils literal notranslate"><span class="pre">m_childOffsets</span></code> array.
Primitives can likewise be obtained; they are stored in the primitives array from index <code class="docutils literal notranslate"><span class="pre">m_primitivesOffset</span></code> to <code class="docutils literal notranslate"><span class="pre">m_primitivesOffset</span> <span class="pre">+</span> <span class="pre">m_numPrimities</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">LinearBVH</span></code> which stores the compact BVH <em>and</em> primitives as class members.
That is, <code class="docutils literal notranslate"><span class="pre">LinearBVH</span></code> contains the nodes and primitives as class members.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="o">&gt;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="kr">inline</span>
    <span class="n">LinearBVH</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LinearNode</span><span class="o">&gt;&amp;</span> <span class="n">a_linearNodes</span><span class="p">,</span>
	      <span class="k">const</span> <span class="n">PrimitiveList</span><span class="o">&amp;</span>           <span class="n">a_primitives</span><span class="p">);</span>
  <span class="k">protected</span><span class="o">:</span>

    <span class="cm">/*!</span>
<span class="cm">      @brief List of linearly stored nodes</span>
<span class="cm">    */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LinearNodeT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m_linearNodes</span><span class="p">;</span>

    <span class="cm">/*!</span>
<span class="cm">      @brief Global list of primitives. Note that this is ALL primitives, sorted so that LinearNodeT can interface into it. </span>
<span class="cm">    */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">P</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m_primitives</span><span class="p">;</span>
  <span class="p">};</span>
</pre></div>
</div>
<p>The root node is, of course, found at the front of the <code class="docutils literal notranslate"><span class="pre">m_linearNodes</span></code> vector.
Note that the list of primitives <code class="docutils literal notranslate"><span class="pre">m_primitives</span></code> is stored in the order in which the leaf nodes appear in <code class="docutils literal notranslate"><span class="pre">m_linearNodes</span></code>.</p>
</li>
</ul>
<p>Constructing the compact BVH is simply a matter of letting <code class="docutils literal notranslate"><span class="pre">NodeT</span></code> aggregate the nodes and primitives into arrays, and return a <code class="docutils literal notranslate"><span class="pre">LinearBVH</span></code>.
This is done by calling the <code class="docutils literal notranslate"><span class="pre">NodeT</span></code> member function <code class="docutils literal notranslate"><span class="pre">flattenTree()</span></code>, which returns a pointer to a <code class="docutils literal notranslate"><span class="pre">LinearBVH</span></code>.
For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Assume that we have built the conventional BVH already</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">EBGeometry</span><span class="o">::</span><span class="n">BVH</span><span class="o">::</span><span class="n">NodeT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">builderBVH</span><span class="p">;</span>

<span class="c1">// Flatten the tree.</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">LinearBVH</span><span class="o">&gt;</span> <span class="n">compactBVH</span> <span class="o">=</span> <span class="n">builderBVH</span><span class="p">.</span><span class="n">flattenTree</span><span class="p">();</span>

<span class="c1">// Release the original BVH.</span>
<span class="n">builderBVH</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When calling <code class="docutils literal notranslate"><span class="pre">flattenTree</span></code>, the original BVH tree is <em>not</em> destroyed.
To release the memory, deallocate the original BVH tree.
E.g., the set pointer to the root node to <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> if using a smart pointer.</p>
</div>
<p>Note that the primitives live in <code class="docutils literal notranslate"><span class="pre">LinearBVH</span></code> and not <code class="docutils literal notranslate"><span class="pre">LinearNodeT</span></code>, and the signed distance function is therefore implemented in the <code class="docutils literal notranslate"><span class="pre">LinearBVH</span></code> member functions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">LinearBVH</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="kr">inline</span>
    <span class="n">T</span> <span class="n">signedDistance</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec3</span><span class="o">&amp;</span> <span class="n">a_point</span><span class="p">,</span> <span class="k">const</span> <span class="n">Prune</span> <span class="n">a_pruning</span> <span class="o">=</span> <span class="n">Prune</span><span class="o">::</span><span class="n">Ordered2</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>    
</pre></div>
</div>
<p>Thus, once the compact BVH has been built, we can call the signed distance function as usual:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EBGeometry</span><span class="o">::</span><span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">myPoint</span><span class="p">;</span>

<span class="n">compactBVH</span><span class="o">-&gt;</span><span class="n">signedDistance</span><span class="p">(</span><span class="n">myPoint</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="dcel">
<h1>DCEL<a class="headerlink" href="#dcel" title="Permalink to this headline">¶</a></h1>
<p>The DCEL functionality exists under the namespace <code class="docutils literal notranslate"><span class="pre">EBGeometry::Dcel</span></code> and contains the following functionality:</p>
<ul class="simple">
<li><p><strong>Fundamental data types</strong> like vertices, half-edges, polygons, and entire surface grids.</p></li>
<li><p><strong>Signed distance functionality</strong> for the above types.</p></li>
<li><p><strong>File parsers for reading files</strong> into DCEL structures.</p></li>
<li><p><strong>BVH functionality</strong> for putting DCEL grids into bounding volume hierarchies.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The DCEL functionality is <em>not</em> restricted to triangles, but supports N-sided polygons.</p>
</div>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<p>The main DCEL functionality (vertices, edges, faces) is provided by the following classes:</p>
<ul class="simple">
<li><p><strong>Vertices</strong> are implemented as a template <code class="docutils literal notranslate"><span class="pre">EBGeometry::Dcel::EdgeT</span></code></p></li>
</ul>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">VertexT</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
</pre></div>
</div>
<p>The DCEL vertex class stores the vertex position, normal vector, and the outgoing half-edge from the vertex.
Note that the class has member functions for computing the vertex pseudonormal, see <a class="reference internal" href="DCEL.html#chap-normaldcel"><span class="std std-ref">Normal vectors</span></a>.</p>
<p>The full API is given in the doxygen documentation <a class="reference external" href="doxygen/html/classDcel_1_1VertexT.html">here</a>.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>Edges</strong> are implemented as a template <code class="docutils literal notranslate"><span class="pre">EBGeometry::Dcel::EdgeT</span></code></p></li>
</ul>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">EdgeT</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
</pre></div>
</div>
<p>The half-edges store a reference to their face, as well as pointers to the previous edge, next edge, pair edge, and starting vertex.
For performance reasons, the edge also stores the length and inverse length of the edge.</p>
<p>The full API is given in the doxygen documentation <a class="reference external" href="doxygen/html/classDcel_1_1EdgeT.html">here</a>.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>Faces</strong> are implemented as a template <code class="docutils literal notranslate"><span class="pre">EBGeometry::Dcel::FaceT</span></code></p></li>
</ul>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">FaceT</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
</pre></div>
</div>
<p>For performance reasons, a polygon face stores all it’s half-edges (to avoid iteration when computing the signed distance).
It also stores:</p>
<ul class="simple">
<li><p>The normal vector.</p></li>
<li><p>A 2D embedding of the polygon face.</p></li>
<li><p>Centroid position.</p></li>
</ul>
<p>The normal vector and 2D embedding of the facet exist because the signed distance computation requires them.
The centroid position exists only because BVH partitioners will use it for partitioning the surface mesh.</p>
<p>The full API is given in the doxygen documentation <a class="reference external" href="doxygen/html/classDcel_1_1FaceT.html">here</a>.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>Mesh</strong> is implemented as a template <code class="docutils literal notranslate"><span class="pre">EBGeometry::Dcel::MeshT</span></code></p></li>
</ul>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">MeshT</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
</pre></div>
</div>
<p>The Mesh stores all the vertices, half-edges, and faces.
For example, to obtain all the facets one can call <code class="docutils literal notranslate"><span class="pre">EBGeometry::Dcel::MeshT&lt;T&gt;::getFaces()</span></code> which will return all the DCEL faces of the surface mesh.
Typically, the mesh is not created by the user but automatically created when reading the mesh from an input file.</p>
<p>The full API is given in the doxygen documentation <a class="reference external" href="doxygen/html/classDcel_1_1MeshT.html">here</a>.</p>
</div></blockquote>
<p>All of the above DCEL classes have member functions of the type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="nf">signedDistance</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a_point</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">T</span> <span class="nf">unsignedDistance2</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a_point</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
</pre></div>
</div>
<p>Thus, they fulfill the template requirements of the primitive type for the BVH implementation, see <a class="reference internal" href="#chap-bvhconstraints"><span class="std std-ref">Template constraints</span></a>.
See <a class="reference internal" href="#chap-bvhintegration"><span class="std std-ref">BVH integration</span></a> for details regarding DCEL integration with BVHs.</p>
</div>
<div class="section" id="file-parsers">
<h2>File parsers<a class="headerlink" href="#file-parsers" title="Permalink to this headline">¶</a></h2>
<p>Routines for parsing surface files from grids into EBGeometry’s DCEL grids are given in the namespace <code class="docutils literal notranslate"><span class="pre">EBGeometry::Dcel::Parser</span></code>.
Currently, this is limited to the following file formats:</p>
<ul>
<li><p><strong>PLY</strong> Only ASCII formats currently supported, <a class="reference external" href="https://en.wikipedia.org/wiki/PLY_(file_format)">https://en.wikipedia.org/wiki/PLY_(file_format)</a>.</p>
<p>When reading a PLY file into the DCEL data structures, it is sufficient to call the following static function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">using</span> <span class="n">Mesh</span> <span class="o">=</span> <span class="n">EBGeometry</span><span class="p">::</span><span class="n">Dcel</span><span class="p">::</span><span class="n">MeshT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Mesh</span><span class="o">&gt;</span> <span class="n">EBGeometry</span><span class="p">::</span><span class="n">Parser</span><span class="p">::</span><span class="n">PLY</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">::</span><span class="n">readASCII</span><span class="p">(</span><span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">a_filename</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Although the parser will do it’s best to read files that contains holes or incomplete faces, success will fluctuate.
Moreover, the signed distance function is not well-defined for such cases.</p>
</div>
<p>Calling the <code class="docutils literal notranslate"><span class="pre">readASCII</span></code> function will read the input file (which is assumed to be a PLY file) and create the DCEL data structures.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the file format of your surface mesh file is not one of the above, consider either providing a new plugin or convert your file (e.g. to PLY) using MeshLab, Blender, etc.</p>
</div>
</div>
<div class="section" id="bvh-integration">
<span id="chap-bvhintegration"></span><h2>BVH integration<a class="headerlink" href="#bvh-integration" title="Permalink to this headline">¶</a></h2>
<p>DCEL functionality can easily be embedded in BVHs.
In this case it is the facets that are embedded in the BVHs, and we require that we can create bounding volumes that contain all the vertices in a facet.
Moreover, partitioning functions that partition a set of polygon faces into <code class="docutils literal notranslate"><span class="pre">K</span></code> new sets of faces are also required.</p>
<div class="section" id="construction-methods">
<h3>Construction methods<a class="headerlink" href="#construction-methods" title="Permalink to this headline">¶</a></h3>
<p>EBGeometry provides some simplistic functions that are needed (see <a class="reference internal" href="#chap-bvhconstruction"><span class="std std-ref">Construction</span></a>) when building BVHs for DCEL geometries .</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The functions are defined in <code class="file docutils literal notranslate"><span class="pre">Source/EBGeometry_DcelBVH.hpp</span></code>.</p>
</div>
<p>For the bounding volume constructor, we provide a function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BV</span><span class="o">&gt;</span>
  <span class="n">BVH</span><span class="o">::</span><span class="n">BVConstructorT</span><span class="o">&lt;</span><span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">BV</span><span class="o">&gt;</span> <span class="n">defaultBVConstructor</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">a_primitive</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">BV</span><span class="p">(</span><span class="n">a_primitive</span><span class="o">-&gt;</span><span class="n">getAllVertexCoordinates</span><span class="p">());</span>
  <span class="p">};</span>  
</pre></div>
</div>
<p>Note the extra template constraint on the bounding volume type <code class="docutils literal notranslate"><span class="pre">BV</span></code>, which must be able to construct a bounding volume from a finite point set (the vertex coordinates).</p>
<p>For the stop function we provide a simple function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">primitivesPerLeafNode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="o">&gt;</span> 
  <span class="n">BVH</span><span class="o">::</span><span class="n">StopFunctionT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">defaultStopFunction</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">BVH</span><span class="o">::</span><span class="n">NodeT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;&amp;</span> <span class="n">a_node</span><span class="p">){</span>
    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">primitives</span> <span class="o">=</span> <span class="n">a_node</span><span class="p">.</span><span class="n">getPrimitives</span><span class="p">();</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">numPrims</span>     <span class="o">=</span> <span class="n">primitives</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    
    <span class="k">return</span> <span class="n">numPrims</span> <span class="o">&lt;=</span> <span class="n">primitivesPerLeafNode</span> <span class="o">||</span> <span class="n">numPrims</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span>
  <span class="p">};</span>
</pre></div>
</div>
<p>Note that this simply terminates the leaf partitioning if there are not enough primitives (polygon faces) available, or there are fewer than a pre-defined number of primitives.</p>
<p>For the partitioning function we include a simple function that partitions the primites along the longest axis:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="o">&gt;</span>
  <span class="n">BVH</span><span class="o">::</span><span class="n">PartitionerT</span><span class="o">&lt;</span><span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">spatialSplitPartitioner</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a_primitives</span><span class="p">){</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">numPrimitives</span> <span class="o">=</span> <span class="n">a_primitives</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    
    <span class="c1">// Compute the coordinate direction with the longest extent. This will be our splitting direction.  </span>
    <span class="k">auto</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">a_primitives</span><span class="p">){</span>
      <span class="n">lo</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">getCentroid</span><span class="p">());</span>
      <span class="n">hi</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">getCentroid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">delta</span>   <span class="o">=</span> <span class="p">(</span><span class="n">hi</span><span class="o">-</span><span class="n">lo</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">splitDir</span> <span class="o">=</span> <span class="n">delta</span><span class="p">.</span><span class="n">maxDir</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

    <span class="c1">// Sort the primitives along the above coordinate direction. </span>
    <span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sortedPrimitives</span><span class="p">(</span><span class="n">a_primitives</span><span class="p">);</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">sortedPrimitives</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sortedPrimitives</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
	      <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">f1</span><span class="p">,</span>
		  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">f2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">f1</span><span class="o">-&gt;</span><span class="n">getCentroid</span><span class="p">(</span><span class="n">splitDir</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">f2</span><span class="o">-&gt;</span><span class="n">getCentroid</span><span class="p">(</span><span class="n">splitDir</span><span class="p">);</span>
	      <span class="p">});</span>


    <span class="c1">// Figure out the indices in the vector where we do the splits. </span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">almostEqualChunkSize</span> <span class="o">=</span> <span class="n">numPrimitives</span> <span class="o">/</span> <span class="n">K</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">remainder</span>                  <span class="o">=</span> <span class="n">numPrimitives</span> <span class="o">%</span> <span class="n">K</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">startIndices</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">endIndices</span><span class="p">;</span>

    <span class="n">startIndices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">endIndices</span>  <span class="p">[</span><span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numPrimitives</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
      <span class="n">startIndices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">startIndices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">almostEqualChunkSize</span><span class="p">;</span>

      <span class="k">if</span><span class="p">(</span><span class="n">remainder</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
	<span class="n">startIndices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">remainder</span><span class="o">--</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
      <span class="n">endIndices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">startIndices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>


    <span class="c1">// Put the primitives in separate lists and return them back to the BVH node. </span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">subVolumePrimitives</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
      <span class="k">typename</span> <span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">first</span> <span class="o">=</span> <span class="n">sortedPrimitives</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">startIndices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">typename</span> <span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">last</span>  <span class="o">=</span> <span class="n">sortedPrimitives</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">endIndices</span>  <span class="p">[</span><span class="n">i</span><span class="p">];</span>
      
      <span class="n">subVolumePrimitives</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">PrimitiveList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Return as we must.</span>
    <span class="k">return</span> <span class="n">subVolumePrimitives</span><span class="p">;</span>
  <span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="code-example">
<h3>Code example<a class="headerlink" href="#code-example" title="Permalink to this headline">¶</a></h3>
<p>Constructing a compact BVH representation of polygon mesh is therefore done as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">T</span>    <span class="o">=</span> <span class="kt">float</span><span class="p">;</span>
<span class="k">using</span> <span class="n">BV</span>   <span class="o">=</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">BoundingVolumes</span><span class="o">::</span><span class="n">AABBT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Vec3</span> <span class="o">=</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Face</span> <span class="o">=</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">Dcel</span><span class="o">::</span><span class="n">FaceT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

<span class="c1">// Read the mesh from file and put it in a DCEL format.</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">EBGeometry</span><span class="o">::</span><span class="n">Dcel</span><span class="o">::</span><span class="n">Mesh</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">Dcel</span><span class="o">::</span><span class="n">Parser</span><span class="o">::</span><span class="n">Ply</span><span class="p">(</span><span class="s">&quot;MyFile.ply&quot;</span><span class="p">);</span>

<span class="c1">// Make a BVH node and build the BVH.</span>
<span class="k">auto</span> <span class="n">root</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">EBGeometry</span><span class="o">::</span><span class="n">BVH</span><span class="o">::</span><span class="n">NodeT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Face</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">mesh</span><span class="o">-&gt;</span><span class="n">getFaces</span><span class="p">());</span>

<span class="c1">// Build the BVH hierarchy</span>
<span class="n">root</span><span class="o">-&gt;</span><span class="n">topDownSortAndPartitionPrimitives</span><span class="p">(</span><span class="n">EBGeometry</span><span class="o">::</span><span class="n">Dcel</span><span class="o">::</span><span class="n">defaultBVConstructor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">BV</span><span class="o">&gt;</span><span class="p">,</span>
                                        <span class="n">EBGeometry</span><span class="o">::</span><span class="n">Dcel</span><span class="o">::</span><span class="n">spatialSplitPartitioner</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span><span class="p">,</span>
                                        <span class="n">EBGeometry</span><span class="o">::</span><span class="n">Dcel</span><span class="o">::</span><span class="n">defaultStopFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span><span class="p">);</span>

<span class="c1">// Flatten the tree onto a tighter representation. Then delete the old tree.</span>
<span class="k">auto</span> <span class="n">compactBVH</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">flattenTree</span><span class="p">();</span>

<span class="n">root</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="signed-distance-function">
<h1>Signed distance function<a class="headerlink" href="#signed-distance-function" title="Permalink to this headline">¶</a></h1>
<p>In EBGeometry we have encapsulated the concept of a signed distance function in an abstract class</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SignedDistanceFunction</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="kt">void</span> <span class="n">translate</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a_translation</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">void</span> <span class="nf">rotate</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">a_angle</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a_axis</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="n">T</span> <span class="nf">signedDistance</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a_point</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">protected</span><span class="o">:</span>

   <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">transformPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a_point</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We point out that the BVH and DCEL functionalities are fundamentally also signed distance functions.
The <code class="docutils literal notranslate"><span class="pre">SignedDistanceFunction</span></code> class exists so that we have a common entry point for performing distance field manipulations like rotations and translations.</p>
<p>When implementing the <code class="docutils literal notranslate"><span class="pre">signedDistance</span></code> function, one can transform the input point by first calling <code class="docutils literal notranslate"><span class="pre">transformPoint</span></code>.</p>
<p>For example, in order to rotate a DCEL mesh (without using the BVH accelerator) we can implement the following signed distance function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MySignedDistanceFunction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SignedDistanceFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">T</span> <span class="n">signedDistance</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a_point</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="k">override</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">m_mesh</span><span class="o">-&gt;</span><span class="n">signedDistance</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">transformPoint</span><span class="p">(</span><span class="n">a_point</span><span class="p">));</span>
   <span class="p">}</span>

<span class="k">protected</span><span class="o">:</span>
   <span class="c1">// DCEL mesh object, must be constructed externally and</span>
   <span class="c1">// supplied to MyDistanceFunction (e.g. through the constructor).</span>
   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">EBGeometry</span><span class="o">::</span><span class="n">Dcel</span><span class="o">::</span><span class="n">MeshT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m_mesh</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Alternatively, using a BVH structure:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MySignedDistanceFunction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SignedDistanceFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">T</span> <span class="n">signedDistance</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a_point</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="k">override</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">m_bvh</span><span class="o">-&gt;</span><span class="n">signedDistance</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">transformPoint</span><span class="p">(</span><span class="n">a_point</span><span class="p">));</span>
   <span class="p">}</span>

<span class="k">protected</span><span class="o">:</span>
   <span class="c1">// BVH object, must be constructed externally</span>
   <span class="c1">// and supplied to MyDistanceFunction (e.g. through the constructor).</span>
   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">EBGeometry</span><span class="o">::</span><span class="n">BVH</span><span class="o">::</span><span class="n">LinearBVH</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m_bvh</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="section" id="transformations">
<h2>Transformations<a class="headerlink" href="#transformations" title="Permalink to this headline">¶</a></h2>
<p>The following transformations are possible:</p>
<ul class="simple">
<li><p>Translation, which defines the operation <span class="math notranslate nohighlight">\(\mathbf{x}^\prime = \mathbf{x} - \mathbf{t}\)</span> where <span class="math notranslate nohighlight">\(\mathbf{t}\)</span> is a translation vector.</p></li>
<li><p>Rotation, which defines the operation <span class="math notranslate nohighlight">\(\mathbf{x}^\prime = R\left(\mathbf{x}, \theta, a\right)\)</span> where <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> is rotated an angle <span class="math notranslate nohighlight">\(\theta\)</span> around the coordinate axis <span class="math notranslate nohighlight">\(a\)</span>.</p></li>
</ul>
<p>Transformations are applied sequentially.
The APIs are as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">translate</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a_translation</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>  <span class="c1">// a_translation are Cartesian translations vector</span>
<span class="kt">void</span> <span class="nf">rotate</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">a_angle</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a_axis</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> <span class="c1">// a_angle in degrees, and a_axis being the Cartesian axis</span>
</pre></div>
</div>
<p>E.g. the following code will first translate, then 90 degrees about the <span class="math notranslate nohighlight">\(x\)</span>-axis.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MySignedDistanceFunction</span><span class="o">&lt;</span><span class="nb">float</span><span class="o">&gt;</span> <span class="n">sdf</span><span class="p">;</span>

<span class="n">sdf</span><span class="o">.</span><span class="n">translate</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">});</span>
<span class="n">sdf</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mi">90</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that if the transformations are to be applied, the implementation of <code class="docutils literal notranslate"><span class="pre">signedDistance(...)</span></code> must transform the input point, as shown in the examples above.</p>
</div>
<div class="section" id="analytic-functions">
<span id="chap-analyticsdf"></span><h2>Analytic functions<a class="headerlink" href="#analytic-functions" title="Permalink to this headline">¶</a></h2>
<p>Above, we have shown how users can supply a DCEL or BVH structure to implement <code class="docutils literal notranslate"><span class="pre">SignedDistanceFunction</span></code>.
In addition, the file <code class="file docutils literal notranslate"><span class="pre">Source/EBGeometry_AnalyticSignedDistanceFunctions.hpp</span></code> defines various other analytic shapes such as:</p>
<ul>
<li><p><strong>Sphere</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">EBGeometry</span><span class="o">::</span><span class="nl">SphereSDF</span> <span class="p">:</span> <span class="k">public</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">SignedDistanceFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p><strong>Box</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">EBGeometry</span><span class="o">::</span><span class="nl">BoxSDF</span> <span class="p">:</span> <span class="k">public</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">SignedDistanceFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p><strong>Torus</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">EBGeometry</span><span class="o">::</span><span class="nl">TorusSDF</span> <span class="p">:</span> <span class="k">public</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">SignedDistanceFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p><strong>Cylinder</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">EBGeometry</span><span class="o">::</span><span class="nl">CylinderSDF</span> <span class="p">:</span> <span class="k">public</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">SignedDistanceFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="unions">
<span id="chap-union"></span><h1>Unions<a class="headerlink" href="#unions" title="Permalink to this headline">¶</a></h1>
<p>As discussed in <a class="reference internal" href="Concepts.html#chap-concepts"><span class="std std-ref">Signed distance fields</span></a>, a union of signed distance fields can be created provided that the objects do not touch or overlap.
EBGeometry provides two implementations:</p>
<ul class="simple">
<li><p><strong>Standard union</strong> where one looks through every primitive in the union.</p></li>
<li><p><strong>BVH-enabled union</strong> where bounding volume hierarchies are used to find the closest object.</p></li>
</ul>
<div class="section" id="standard-union">
<h2>Standard union<a class="headerlink" href="#standard-union" title="Permalink to this headline">¶</a></h2>
<p>The standard union is template as</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Union</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SignedDistanceFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

  <span class="k">using</span> <span class="n">SDF</span> <span class="o">=</span> <span class="n">SignedDistanceFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="n">Union</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SDF</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">a_distanceFunctions</span><span class="p">,</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">a_flipSign</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">EBGeometry::Union</span></code> inherits from <code class="docutils literal notranslate"><span class="pre">EBGeometry::SignedDistanceFunction</span></code> and thus provides a <code class="docutils literal notranslate"><span class="pre">signedDistance(...)</span></code> function.
The implementation of the standard union is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">Union</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">signedDistance</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a_point</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">numDistanceFunctions</span> <span class="o">=</span> <span class="n">m_distanceFunctions</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

  <span class="n">T</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">infinity</span><span class="p">();</span>
  
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span> <span class="nl">sdf</span> <span class="p">:</span> <span class="n">m_distanceFunctions</span><span class="p">){</span>
    <span class="k">const</span> <span class="n">T</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">sdf</span><span class="o">-&gt;</span><span class="n">signedDistance</span><span class="p">(</span><span class="n">a_point</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="o">?</span> <span class="nl">cur</span> <span class="p">:</span> <span class="n">ret</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">T</span> <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_flipSign</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">:</span> <span class="mf">1.0</span><span class="p">;</span>  
  
  <span class="k">return</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>That is, it iterates through <em>all</em> the objects in order to find the signed distance.</p>
</div>
<div class="section" id="bvh-enabled-union">
<h2>BVH-enabled union<a class="headerlink" href="#bvh-enabled-union" title="Permalink to this headline">¶</a></h2>
<p>The BVH-enabled union is implemented by <code class="docutils literal notranslate"><span class="pre">EBGeometry::UnionBVH</span></code> as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">UnionBVH</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SignedDistanceFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

  <span class="k">using</span> <span class="n">SDF</span> <span class="o">=</span> <span class="n">SignedDistanceFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">using</span> <span class="n">BVConstructor</span> <span class="o">=</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">BVH</span><span class="o">::</span><span class="n">BVConstructorT</span><span class="o">&lt;</span><span class="n">SDF</span><span class="p">,</span> <span class="n">BV</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="n">UnionBVH</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SDF</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">a_distanceFunctions</span><span class="p">,</span>
	   <span class="k">const</span> <span class="kt">bool</span>                                <span class="n">a_flipSign</span><span class="p">,</span>
	   <span class="k">const</span> <span class="n">BVConstructor</span><span class="o">&amp;</span>                      <span class="n">a_bvConstructor</span><span class="p">);</span>  

  <span class="n">T</span> <span class="nf">signedDistance</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a_point</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="k">override</span><span class="p">;</span>  
  
<span class="k">protected</span><span class="o">:</span>

  <span class="k">using</span> <span class="n">LinearNode</span> <span class="o">=</span> <span class="n">EBGeometry</span><span class="o">::</span><span class="n">BVH</span><span class="o">::</span><span class="n">LinearBVH</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">SDF</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span><span class="p">;</span>  

  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">LinearNode</span><span class="o">&gt;</span> <span class="n">m_rootNode</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>As always, the template parameter <code class="docutils literal notranslate"><span class="pre">T</span></code> indicates the precision, <code class="docutils literal notranslate"><span class="pre">BV</span></code> the bounding volume type and <code class="docutils literal notranslate"><span class="pre">K</span></code> the tree degree.
<code class="docutils literal notranslate"><span class="pre">UnionBVH</span></code> takes a bounding volume constructor in addition to the list of primitives, see <a class="reference internal" href="#chap-bvhconstruction"><span class="std std-ref">Construction</span></a>.</p>
<p>Internally, <code class="docutils literal notranslate"><span class="pre">UnionBVH</span></code> defines its own partitioning function which is identical to the implementation for DCEL meshes (see <a class="reference internal" href="#chap-bvhintegration"><span class="std std-ref">BVH integration</span></a>), with the exception that the partitioning is based on the centroids of the bounding volumes rather than the centroid of the primitives.
After partitioning the primitives, the original BVH tree is flattened onto the compact representation.</p>
<p>The implementation of the signed distance function for the BVH-enabled union is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">UnionBVH</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">BV</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;::</span><span class="n">signedDistance</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a_point</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">T</span> <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_flipSign</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">:</span> <span class="mf">1.0</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">m_rootNode</span><span class="o">-&gt;</span><span class="n">signedDistance</span><span class="p">(</span><span class="n">a_point</span><span class="p">);</span>  
<span class="p">}</span>
</pre></div>
</div>
<p>That is, it relies on pruning from the BVH functionality for finding the signed distance to the closest object.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Examples.html" class="btn btn-neutral float-right" title="&lt;no title&gt;" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="BVH.html" class="btn btn-neutral float-left" title="Bounding volume hierarchies" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, Robert Marskar

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>