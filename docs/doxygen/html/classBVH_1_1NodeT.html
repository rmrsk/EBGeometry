<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EBGeometry: BVH::NodeT&lt; T, P, BV, K &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EBGeometry
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceBVH.html">BVH</a></li><li class="navelem"><a class="el" href="classBVH_1_1NodeT.html">NodeT</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classBVH_1_1NodeT-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BVH::NodeT&lt; T, P, BV, K &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Forward declare the <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality. ">BVH</a> node since it is needed for the polymorphic lambdas.  
 <a href="classBVH_1_1NodeT.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="EBGeometry__BVH_8hpp_source.html">EBGeometry_BVH.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a19cce6e7fbe85eccb4a3718dd69f49b7"><td class="memItemLeft" align="right" valign="top"><a id="a19cce6e7fbe85eccb4a3718dd69f49b7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a19cce6e7fbe85eccb4a3718dd69f49b7">PrimitiveList</a> = <a class="el" href="namespaceBVH.html#aa1e753bda451b85cd5b948722a2ad7c7">PrimitiveListT</a>&lt; P &gt;</td></tr>
<tr class="memdesc:a19cce6e7fbe85eccb4a3718dd69f49b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for cutting down on typing. <br /></td></tr>
<tr class="separator:a19cce6e7fbe85eccb4a3718dd69f49b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbb4308c5c55ee170c5f992df7ae1d0"><td class="memItemLeft" align="right" valign="top"><a id="a6fbb4308c5c55ee170c5f992df7ae1d0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> = <a class="el" href="classVec3T.html">Vec3T</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a6fbb4308c5c55ee170c5f992df7ae1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for cutting down on typing. <br /></td></tr>
<tr class="separator:a6fbb4308c5c55ee170c5f992df7ae1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52d9b56f082002c7f8be91062c40ff8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#ac52d9b56f082002c7f8be91062c40ff8">Node</a> = <a class="el" href="classBVH_1_1NodeT.html">NodeT</a>&lt; T, P, BV, K &gt;</td></tr>
<tr class="memdesc:ac52d9b56f082002c7f8be91062c40ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for cutting down on typing.  <a href="#ac52d9b56f082002c7f8be91062c40ff8">More...</a><br /></td></tr>
<tr class="separator:ac52d9b56f082002c7f8be91062c40ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008f5c2c53adb1f5730d8478b48529b1"><td class="memItemLeft" align="right" valign="top"><a id="a008f5c2c53adb1f5730d8478b48529b1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a008f5c2c53adb1f5730d8478b48529b1">NodePtr</a> = std::shared_ptr&lt; <a class="el" href="classBVH_1_1NodeT.html#ac52d9b56f082002c7f8be91062c40ff8">Node</a> &gt;</td></tr>
<tr class="memdesc:a008f5c2c53adb1f5730d8478b48529b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for cutting down on typing. <br /></td></tr>
<tr class="separator:a008f5c2c53adb1f5730d8478b48529b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe56195affc439febe8aca84db308e3"><td class="memItemLeft" align="right" valign="top"><a id="acbe56195affc439febe8aca84db308e3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#acbe56195affc439febe8aca84db308e3">StopFunction</a> = <a class="el" href="namespaceBVH.html#afef1c5979c34a11d23b756cc09654bf9">StopFunctionT</a>&lt; T, P, BV, K &gt;</td></tr>
<tr class="memdesc:acbe56195affc439febe8aca84db308e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for cutting down on typing. <br /></td></tr>
<tr class="separator:acbe56195affc439febe8aca84db308e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb028655b8b961fa35109af1c14f281"><td class="memItemLeft" align="right" valign="top"><a id="a3bb028655b8b961fa35109af1c14f281"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a3bb028655b8b961fa35109af1c14f281">Partitioner</a> = <a class="el" href="namespaceBVH.html#a7c33d54da9893d506709b2ca96b76f55">PartitionerT</a>&lt; P, K &gt;</td></tr>
<tr class="memdesc:a3bb028655b8b961fa35109af1c14f281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for cutting down on typing. <br /></td></tr>
<tr class="separator:a3bb028655b8b961fa35109af1c14f281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2340f2466ed5b6eebab4bdc72004858e"><td class="memItemLeft" align="right" valign="top"><a id="a2340f2466ed5b6eebab4bdc72004858e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a2340f2466ed5b6eebab4bdc72004858e">BVConstructor</a> = <a class="el" href="namespaceBVH.html#a245702d7eff40cdaedb5dff68c25a88a">BVConstructorT</a>&lt; P, BV &gt;</td></tr>
<tr class="memdesc:a2340f2466ed5b6eebab4bdc72004858e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for cutting down on typing. <br /></td></tr>
<tr class="separator:a2340f2466ed5b6eebab4bdc72004858e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a960d0972bec81cf782b36e57f87da1f1"><td class="memItemLeft" align="right" valign="top"><a id="a960d0972bec81cf782b36e57f87da1f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a960d0972bec81cf782b36e57f87da1f1">NodeT</a> ()</td></tr>
<tr class="memdesc:a960d0972bec81cf782b36e57f87da1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor which sets a regular node without any data (no parent/children and no depth) <br /></td></tr>
<tr class="separator:a960d0972bec81cf782b36e57f87da1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8867e5e1c47d12eff7a468b2e240f16b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a8867e5e1c47d12eff7a468b2e240f16b">NodeT</a> (const <a class="el" href="classBVH_1_1NodeT.html#a008f5c2c53adb1f5730d8478b48529b1">NodePtr</a> &amp;a_parent)</td></tr>
<tr class="memdesc:a8867e5e1c47d12eff7a468b2e240f16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct node from parent.  <a href="#a8867e5e1c47d12eff7a468b2e240f16b">More...</a><br /></td></tr>
<tr class="separator:a8867e5e1c47d12eff7a468b2e240f16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da86ccc8e4a0c556cd67ca59af983dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a6da86ccc8e4a0c556cd67ca59af983dc">NodeT</a> (const std::vector&lt; std::shared_ptr&lt; P &gt; &gt; &amp;a_primitives)</td></tr>
<tr class="memdesc:a6da86ccc8e4a0c556cd67ca59af983dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct node from a set of primitives.  <a href="#a6da86ccc8e4a0c556cd67ca59af983dc">More...</a><br /></td></tr>
<tr class="separator:a6da86ccc8e4a0c556cd67ca59af983dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6312ce04f70c2e1a860ce380298909b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a6312ce04f70c2e1a860ce380298909b6">NodeT</a> (const std::vector&lt; std::shared_ptr&lt; const P &gt; &gt; &amp;a_primitives)</td></tr>
<tr class="memdesc:a6312ce04f70c2e1a860ce380298909b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct node from a set of primitives.  <a href="#a6312ce04f70c2e1a860ce380298909b6">More...</a><br /></td></tr>
<tr class="separator:a6312ce04f70c2e1a860ce380298909b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc328f2381b6babe37496758ea4b583"><td class="memItemLeft" align="right" valign="top"><a id="a5bc328f2381b6babe37496758ea4b583"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a5bc328f2381b6babe37496758ea4b583">~NodeT</a> ()</td></tr>
<tr class="memdesc:a5bc328f2381b6babe37496758ea4b583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor (does nothing) <br /></td></tr>
<tr class="separator:a5bc328f2381b6babe37496758ea4b583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae5a575fa8b236de984fdd41e04c038"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#acae5a575fa8b236de984fdd41e04c038">topDownSortAndPartitionPrimitives</a> (const <a class="el" href="classBVH_1_1NodeT.html#a2340f2466ed5b6eebab4bdc72004858e">BVConstructor</a> &amp;a_bvConstructor, const <a class="el" href="classBVH_1_1NodeT.html#a3bb028655b8b961fa35109af1c14f281">Partitioner</a> &amp;a_partitioner, const <a class="el" href="classBVH_1_1NodeT.html#acbe56195affc439febe8aca84db308e3">StopFunction</a> &amp;a_stopCrit) noexcept</td></tr>
<tr class="memdesc:acae5a575fa8b236de984fdd41e04c038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for using top-down construction of the bounding volume hierarchy.  <a href="#acae5a575fa8b236de984fdd41e04c038">More...</a><br /></td></tr>
<tr class="separator:acae5a575fa8b236de984fdd41e04c038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158041a671c970da921446050e95f474"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a158041a671c970da921446050e95f474">getDepth</a> () const noexcept</td></tr>
<tr class="memdesc:a158041a671c970da921446050e95f474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the depth of the current node.  <a href="#a158041a671c970da921446050e95f474">More...</a><br /></td></tr>
<tr class="separator:a158041a671c970da921446050e95f474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0c1e030162a2dc049acb4debd4d9f2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBVH_1_1NodeT.html#a19cce6e7fbe85eccb4a3718dd69f49b7">PrimitiveList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a2e0c1e030162a2dc049acb4debd4d9f2">getPrimitives</a> () const noexcept</td></tr>
<tr class="memdesc:a2e0c1e030162a2dc049acb4debd4d9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the primitives stored in this node.  <a href="#a2e0c1e030162a2dc049acb4debd4d9f2">More...</a><br /></td></tr>
<tr class="separator:a2e0c1e030162a2dc049acb4debd4d9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cba4dcb065ebfaeea7e4d251b89d04"><td class="memItemLeft" align="right" valign="top"><a id="a02cba4dcb065ebfaeea7e4d251b89d04"></a>
const BV &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a02cba4dcb065ebfaeea7e4d251b89d04">getBoundingVolume</a> () const noexcept</td></tr>
<tr class="memdesc:a02cba4dcb065ebfaeea7e4d251b89d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get bounding volume. <br /></td></tr>
<tr class="separator:a02cba4dcb065ebfaeea7e4d251b89d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7148b18296dce60853b5966c9f1e0d"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#aef7148b18296dce60853b5966c9f1e0d">signedDistance</a> (const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;a_point, const <a class="el" href="namespaceBVH.html#a3ddb7b34ac1deb3baed2f32d9eacbe5b">Prune</a> a_pruning=Prune::Ordered2) const noexcept</td></tr>
<tr class="memdesc:aef7148b18296dce60853b5966c9f1e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which computes the signed distance.  <a href="#aef7148b18296dce60853b5966c9f1e0d">More...</a><br /></td></tr>
<tr class="separator:aef7148b18296dce60853b5966c9f1e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa6e9109897a573a46714278e0a79c6"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a3aa6e9109897a573a46714278e0a79c6">pruneOrdered</a> (const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;a_point) const noexcept</td></tr>
<tr class="memdesc:a3aa6e9109897a573a46714278e0a79c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which computes the signed distance using ordered pruning along the <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality. ">BVH</a> branches.  <a href="#a3aa6e9109897a573a46714278e0a79c6">More...</a><br /></td></tr>
<tr class="separator:a3aa6e9109897a573a46714278e0a79c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7fec40e06e97fcd42ec75169603e8b"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#acb7fec40e06e97fcd42ec75169603e8b">pruneOrdered2</a> (const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;a_point) const noexcept</td></tr>
<tr class="memdesc:acb7fec40e06e97fcd42ec75169603e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which computes the signed distance using ordered pruning along the <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality. ">BVH</a> branches.  <a href="#acb7fec40e06e97fcd42ec75169603e8b">More...</a><br /></td></tr>
<tr class="separator:acb7fec40e06e97fcd42ec75169603e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cfc030a9b7f9b0341e94dc6733b511"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a27cfc030a9b7f9b0341e94dc6733b511">pruneUnordered</a> (const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;a_point) const noexcept</td></tr>
<tr class="memdesc:a27cfc030a9b7f9b0341e94dc6733b511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which computes the signed distance using unordered pruning along the <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality. ">BVH</a> branches.  <a href="#a27cfc030a9b7f9b0341e94dc6733b511">More...</a><br /></td></tr>
<tr class="separator:a27cfc030a9b7f9b0341e94dc6733b511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa2f1f4f4f58296531723e9a6d7d13a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#aafa2f1f4f4f58296531723e9a6d7d13a">pruneUnordered2</a> (const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;a_point) const noexcept</td></tr>
<tr class="memdesc:aafa2f1f4f4f58296531723e9a6d7d13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which computes the signed distance using unordered pruning along the <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality. ">BVH</a> branches.  <a href="#aafa2f1f4f4f58296531723e9a6d7d13a">More...</a><br /></td></tr>
<tr class="separator:aafa2f1f4f4f58296531723e9a6d7d13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926e3990022ab28821d3f51e5fead023"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classBVH_1_1LinearBVH.html">LinearBVH</a>&lt; T, P, BV, K &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a926e3990022ab28821d3f51e5fead023">flattenTree</a> ()</td></tr>
<tr class="memdesc:a926e3990022ab28821d3f51e5fead023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten everything beneath this node into a depth-first sorted <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality. ">BVH</a> hierarchy.  <a href="#a926e3990022ab28821d3f51e5fead023">More...</a><br /></td></tr>
<tr class="separator:a926e3990022ab28821d3f51e5fead023"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a964bd054b57fce2fec50505a65f6bacd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a964bd054b57fce2fec50505a65f6bacd">setNodeType</a> (const <a class="el" href="namespaceBVH.html#a7613f83a60cfae9aba31861110bd9e54">NodeType</a> a_nodeType) noexcept</td></tr>
<tr class="memdesc:a964bd054b57fce2fec50505a65f6bacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set node type to leaf or regular.  <a href="#a964bd054b57fce2fec50505a65f6bacd">More...</a><br /></td></tr>
<tr class="separator:a964bd054b57fce2fec50505a65f6bacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdff7fdbe3694e2aeb788261175077cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#abdff7fdbe3694e2aeb788261175077cc">setDepth</a> (const int a_depth) noexcept</td></tr>
<tr class="memdesc:abdff7fdbe3694e2aeb788261175077cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set node depth.  <a href="#abdff7fdbe3694e2aeb788261175077cc">More...</a><br /></td></tr>
<tr class="separator:abdff7fdbe3694e2aeb788261175077cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8113c8dfa5ab6dc3cf931c5c8fdd6ddb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a8113c8dfa5ab6dc3cf931c5c8fdd6ddb">insertNode</a> (<a class="el" href="classBVH_1_1NodeT.html#a008f5c2c53adb1f5730d8478b48529b1">NodePtr</a> &amp;a_node, const <a class="el" href="classBVH_1_1NodeT.html#a19cce6e7fbe85eccb4a3718dd69f49b7">PrimitiveList</a> &amp;a_primitives) noexcept</td></tr>
<tr class="memdesc:a8113c8dfa5ab6dc3cf931c5c8fdd6ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new node in the tree.  <a href="#a8113c8dfa5ab6dc3cf931c5c8fdd6ddb">More...</a><br /></td></tr>
<tr class="separator:a8113c8dfa5ab6dc3cf931c5c8fdd6ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a7b385ec12897c1ade331ee24d9b74"><td class="memItemLeft" align="right" valign="top"><a id="a75a7b385ec12897c1ade331ee24d9b74"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a75a7b385ec12897c1ade331ee24d9b74">insertNodes</a> (const std::array&lt; <a class="el" href="classBVH_1_1NodeT.html#a19cce6e7fbe85eccb4a3718dd69f49b7">PrimitiveList</a>, K &gt; &amp;a_primitives) noexcept</td></tr>
<tr class="memdesc:a75a7b385ec12897c1ade331ee24d9b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert nodes with primitives. <br /></td></tr>
<tr class="separator:a75a7b385ec12897c1ade331ee24d9b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9c409918d61b0d0ad3dd6e2b692443"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a8f9c409918d61b0d0ad3dd6e2b692443">setToRegularNode</a> () noexcept</td></tr>
<tr class="memdesc:a8f9c409918d61b0d0ad3dd6e2b692443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to regular node.  <a href="#a8f9c409918d61b0d0ad3dd6e2b692443">More...</a><br /></td></tr>
<tr class="separator:a8f9c409918d61b0d0ad3dd6e2b692443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9c3d3a83b3c1895c8f89b2bbd62e81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a2c9c3d3a83b3c1895c8f89b2bbd62e81">setPrimitives</a> (const <a class="el" href="classBVH_1_1NodeT.html#a19cce6e7fbe85eccb4a3718dd69f49b7">PrimitiveList</a> &amp;a_primitives) noexcept</td></tr>
<tr class="memdesc:a2c9c3d3a83b3c1895c8f89b2bbd62e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set primitives in this node.  <a href="#a2c9c3d3a83b3c1895c8f89b2bbd62e81">More...</a><br /></td></tr>
<tr class="separator:a2c9c3d3a83b3c1895c8f89b2bbd62e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da9f78078b0a579868d026bd61a2947"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a8da9f78078b0a579868d026bd61a2947">getDistanceToBoundingVolume</a> (const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;a_point) const noexcept</td></tr>
<tr class="memdesc:a8da9f78078b0a579868d026bd61a2947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distance from a 3D point to the bounding volume.  <a href="#a8da9f78078b0a579868d026bd61a2947">More...</a><br /></td></tr>
<tr class="separator:a8da9f78078b0a579868d026bd61a2947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06708a2711fd354a3c382da664cfe154"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a06708a2711fd354a3c382da664cfe154">getDistanceToBoundingVolume2</a> (const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;a_point) const noexcept</td></tr>
<tr class="memdesc:a06708a2711fd354a3c382da664cfe154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unsigned square from a 3D point to the bounding volume.  <a href="#a06708a2711fd354a3c382da664cfe154">More...</a><br /></td></tr>
<tr class="separator:a06708a2711fd354a3c382da664cfe154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dc7040d57f0a69984548eb4804244b"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a61dc7040d57f0a69984548eb4804244b">getDistanceToPrimitives</a> (const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;a_point) const noexcept</td></tr>
<tr class="memdesc:a61dc7040d57f0a69984548eb4804244b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the shortest distance to the primitives in this node.  <a href="#a61dc7040d57f0a69984548eb4804244b">More...</a><br /></td></tr>
<tr class="separator:a61dc7040d57f0a69984548eb4804244b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9e3a8bfa35f604298634da102a0ce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceBVH.html#a7613f83a60cfae9aba31861110bd9e54">NodeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a7b9e3a8bfa35f604298634da102a0ce4">getNodeType</a> () const noexcept</td></tr>
<tr class="memdesc:a7b9e3a8bfa35f604298634da102a0ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node type.  <a href="#a7b9e3a8bfa35f604298634da102a0ce4">More...</a><br /></td></tr>
<tr class="separator:a7b9e3a8bfa35f604298634da102a0ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce9d9c6bd4ab3d613bef232353774f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBVH_1_1NodeT.html#a19cce6e7fbe85eccb4a3718dd69f49b7">PrimitiveList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#adce9d9c6bd4ab3d613bef232353774f3">getPrimitives</a> () noexcept</td></tr>
<tr class="memdesc:adce9d9c6bd4ab3d613bef232353774f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of primitives in this node.  <a href="#adce9d9c6bd4ab3d613bef232353774f3">More...</a><br /></td></tr>
<tr class="separator:adce9d9c6bd4ab3d613bef232353774f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92db0ab2d61c76469600478fddd04edc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a92db0ab2d61c76469600478fddd04edc">setParent</a> (const <a class="el" href="classBVH_1_1NodeT.html#a008f5c2c53adb1f5730d8478b48529b1">NodePtr</a> &amp;a_parent) noexcept</td></tr>
<tr class="memdesc:a92db0ab2d61c76469600478fddd04edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parent node.  <a href="#a92db0ab2d61c76469600478fddd04edc">More...</a><br /></td></tr>
<tr class="separator:a92db0ab2d61c76469600478fddd04edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a3be457d66d2673f717f203e60fc08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#ac4a3be457d66d2673f717f203e60fc08">pruneOrdered</a> (T &amp;a_closest, const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;a_point) const noexcept</td></tr>
<tr class="memdesc:ac4a3be457d66d2673f717f203e60fc08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation function for pruneOrdered (it requires a different signature).  <a href="#ac4a3be457d66d2673f717f203e60fc08">More...</a><br /></td></tr>
<tr class="separator:ac4a3be457d66d2673f717f203e60fc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2887ad51251739359602dde8db6a5998"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a2887ad51251739359602dde8db6a5998">pruneOrdered2</a> (T &amp;a_minDist2, std::shared_ptr&lt; const P &gt; &amp;a_closest, const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;a_point) const noexcept</td></tr>
<tr class="memdesc:a2887ad51251739359602dde8db6a5998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation function for pruneOrdered2 (it requires a different signature).  <a href="#a2887ad51251739359602dde8db6a5998">More...</a><br /></td></tr>
<tr class="separator:a2887ad51251739359602dde8db6a5998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad252aa451ca983750dfa0c24344253b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#ad252aa451ca983750dfa0c24344253b2">pruneUnordered</a> (T &amp;a_closest, const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;a_point) const noexcept</td></tr>
<tr class="memdesc:ad252aa451ca983750dfa0c24344253b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation function for pruneUnordered (it requires a different signature).  <a href="#ad252aa451ca983750dfa0c24344253b2">More...</a><br /></td></tr>
<tr class="separator:ad252aa451ca983750dfa0c24344253b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1079cba9ac1f114ad2cbc6cdea2eae49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a1079cba9ac1f114ad2cbc6cdea2eae49">pruneUnordered2</a> (T &amp;a_minDist2, std::shared_ptr&lt; const P &gt; &amp;a_closest, const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;a_point) const noexcept</td></tr>
<tr class="memdesc:a1079cba9ac1f114ad2cbc6cdea2eae49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation function for pruneUnordered2 (it requires a different signature).  <a href="#a1079cba9ac1f114ad2cbc6cdea2eae49">More...</a><br /></td></tr>
<tr class="separator:a1079cba9ac1f114ad2cbc6cdea2eae49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f014426b00ad7989af328fa369bca8"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a14f014426b00ad7989af328fa369bca8">flattenTree</a> (std::vector&lt; <a class="el" href="classBVH_1_1LinearNodeT.html">LinearNodeT</a>&lt; T, P, BV, K &gt; &gt; &amp;a_linearNodes, std::vector&lt; std::shared_ptr&lt; const P &gt; &gt; &amp;a_sortedPrimitives, unsigned long &amp;a_offset) const noexcept</td></tr>
<tr class="memdesc:a14f014426b00ad7989af328fa369bca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten tree method.  <a href="#a14f014426b00ad7989af328fa369bca8">More...</a><br /></td></tr>
<tr class="separator:a14f014426b00ad7989af328fa369bca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7f8720f2ab03ee9e81de114c479cb2e5"><td class="memItemLeft" align="right" valign="top"><a id="a7f8720f2ab03ee9e81de114c479cb2e5"></a>
BV&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a7f8720f2ab03ee9e81de114c479cb2e5">m_boundingVolume</a></td></tr>
<tr class="memdesc:a7f8720f2ab03ee9e81de114c479cb2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounding volume object. <br /></td></tr>
<tr class="separator:a7f8720f2ab03ee9e81de114c479cb2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8922fc8cfca32763a7fcb85d9a9508"><td class="memItemLeft" align="right" valign="top"><a id="a1e8922fc8cfca32763a7fcb85d9a9508"></a>
<a class="el" href="namespaceBVH.html#a7613f83a60cfae9aba31861110bd9e54">NodeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a1e8922fc8cfca32763a7fcb85d9a9508">m_nodeType</a></td></tr>
<tr class="memdesc:a1e8922fc8cfca32763a7fcb85d9a9508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node type (leaf or regular) <br /></td></tr>
<tr class="separator:a1e8922fc8cfca32763a7fcb85d9a9508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b924aa0aa13630167f69a7b19038e7e"><td class="memItemLeft" align="right" valign="top"><a id="a8b924aa0aa13630167f69a7b19038e7e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a8b924aa0aa13630167f69a7b19038e7e">m_depth</a></td></tr>
<tr class="memdesc:a8b924aa0aa13630167f69a7b19038e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node depth. <br /></td></tr>
<tr class="separator:a8b924aa0aa13630167f69a7b19038e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdc79254bc8b9d227a70e1ad15ff35e"><td class="memItemLeft" align="right" valign="top"><a id="abcdc79254bc8b9d227a70e1ad15ff35e"></a>
<a class="el" href="classBVH_1_1NodeT.html#a19cce6e7fbe85eccb4a3718dd69f49b7">PrimitiveList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#abcdc79254bc8b9d227a70e1ad15ff35e">m_primitives</a></td></tr>
<tr class="memdesc:abcdc79254bc8b9d227a70e1ad15ff35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitives list. This will be empty for regular nodes. <br /></td></tr>
<tr class="separator:abcdc79254bc8b9d227a70e1ad15ff35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35da0576176a01c9c441f0f2b899ca33"><td class="memItemLeft" align="right" valign="top"><a id="a35da0576176a01c9c441f0f2b899ca33"></a>
std::array&lt; <a class="el" href="classBVH_1_1NodeT.html#a008f5c2c53adb1f5730d8478b48529b1">NodePtr</a>, K &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#a35da0576176a01c9c441f0f2b899ca33">m_children</a></td></tr>
<tr class="memdesc:a35da0576176a01c9c441f0f2b899ca33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Children nodes. <br /></td></tr>
<tr class="separator:a35da0576176a01c9c441f0f2b899ca33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7f5d4808d0662f2ee0ae07a4bcddca"><td class="memItemLeft" align="right" valign="top"><a id="abf7f5d4808d0662f2ee0ae07a4bcddca"></a>
<a class="el" href="classBVH_1_1NodeT.html#a008f5c2c53adb1f5730d8478b48529b1">NodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBVH_1_1NodeT.html#abf7f5d4808d0662f2ee0ae07a4bcddca">m_parent</a></td></tr>
<tr class="memdesc:abf7f5d4808d0662f2ee0ae07a4bcddca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to parent node. <br /></td></tr>
<tr class="separator:abf7f5d4808d0662f2ee0ae07a4bcddca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class P, class BV, int K&gt;<br />
class BVH::NodeT&lt; T, P, BV, K &gt;</h3>

<p>Forward declare the <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality. ">BVH</a> node since it is needed for the polymorphic lambdas. </p>
<p>Class which encapsulates a node in a bounding volume hierarchy.</p>
<p>T is the precision used in the <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality. ">BVH</a> computations, P is the enclosing primitive and BV is the bounding volume used in the <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality. ">BVH</a>.</p>
<p>T is the precision for Vec3, P is the primitive type you want to enclose, BV is the bounding volume you use for it. </p><dl class="section note"><dt>Note</dt><dd>P MUST supply function signedDistance(...) and unsignedDistance2(Vec3). BV must supply a function getDistance (had this been C++20, we would have use concepts to enforce this). </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac52d9b56f082002c7f8be91062c40ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52d9b56f082002c7f8be91062c40ff8">&#9670;&nbsp;</a></span>Node</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class P, class BV, int K&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::<a class="el" href="classBVH_1_1NodeT.html#ac52d9b56f082002c7f8be91062c40ff8">Node</a> =  <a class="el" href="classBVH_1_1NodeT.html">NodeT</a>&lt;T, P, BV, K&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for cutting down on typing. </p>
<p>In the below, 'Node' is a class which uses precision T for computations and encloses primitives P using a bounding volume BV. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8867e5e1c47d12eff7a468b2e240f16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8867e5e1c47d12eff7a468b2e240f16b">&#9670;&nbsp;</a></span>NodeT() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::<a class="el" href="classBVH_1_1NodeT.html">NodeT</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a008f5c2c53adb1f5730d8478b48529b1">NodePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>a_parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct node from parent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_parent</td><td>Parent node.</td></tr>
  </table>
  </dd>
</dl>
<p>This sets the node's parent to be a_parent and the node's depth to be the parent's depth + 1. </p><dl class="section note"><dt>Note</dt><dd>This node becomes a leaf node. </dd></dl>

</div>
</div>
<a id="a6da86ccc8e4a0c556cd67ca59af983dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da86ccc8e4a0c556cd67ca59af983dc">&#9670;&nbsp;</a></span>NodeT() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::<a class="el" href="classBVH_1_1NodeT.html">NodeT</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; P &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_primitives</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct node from a set of primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_primitives</td><td>Input primitives.</td></tr>
  </table>
  </dd>
</dl>
<p>This sets the node's parent to be a_parent and the node's depth to be the parent's depth + 1. </p><dl class="section note"><dt>Note</dt><dd>This node becomes a leaf node with depth=0 and which contains the input primitives. </dd></dl>

</div>
</div>
<a id="a6312ce04f70c2e1a860ce380298909b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6312ce04f70c2e1a860ce380298909b6">&#9670;&nbsp;</a></span>NodeT() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::<a class="el" href="classBVH_1_1NodeT.html">NodeT</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const P &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_primitives</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct node from a set of primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_primitives</td><td>Input primitives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This node becomes a leaf node with depth=0 and which contains the input primitives. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a926e3990022ab28821d3f51e5fead023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926e3990022ab28821d3f51e5fead023">&#9670;&nbsp;</a></span>flattenTree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classBVH_1_1LinearBVH.html">LinearBVH</a>&lt; T, P, BV, K &gt; &gt; <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::flattenTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flatten everything beneath this node into a depth-first sorted <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality. ">BVH</a> hierarchy. </p>
<p>This will compute the flattening of the standard <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality. ">BVH</a> tree and return a pointer to the root node. </p>

</div>
</div>
<a id="a14f014426b00ad7989af328fa369bca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f014426b00ad7989af328fa369bca8">&#9670;&nbsp;</a></span>flattenTree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::flattenTree </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classBVH_1_1LinearNodeT.html">LinearNodeT</a>&lt; T, P, BV, K &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_linearNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; const P &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_sortedPrimitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>a_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flatten tree method. </p>
<p>This function will flatten everything beneath the current node and linearize all the nodes and primitives beneath it to a_linearNodes and a_sortedPrimitives. This function is called recursively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_linearNodes</td><td><a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality. ">BVH</a> nodes, linearized onto a vector. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_sortedPrimitives</td><td>Sorted primitives (in leaf node order). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_offset</td><td>Supporting integer for figuring out where in the tree we are. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When called from the root node, a_linearNodes and a_sortedPrimitives should be empty and a_offset=0UL. </dd></dl>

</div>
</div>
<a id="a158041a671c970da921446050e95f474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158041a671c970da921446050e95f474">&#9670;&nbsp;</a></span>getDepth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::getDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the depth of the current node. </p>
<dl class="section return"><dt>Returns</dt><dd>Depth of current node </dd></dl>

</div>
</div>
<a id="a8da9f78078b0a579868d026bd61a2947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da9f78078b0a579868d026bd61a2947">&#9670;&nbsp;</a></span>getDistanceToBoundingVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::getDistanceToBoundingVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>a_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the distance from a 3D point to the bounding volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_point</td><td>3D point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns distance to bounding volume. A zero distance implies that the input point is inside the bounding volume. </dd></dl>

</div>
</div>
<a id="a06708a2711fd354a3c382da664cfe154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06708a2711fd354a3c382da664cfe154">&#9670;&nbsp;</a></span>getDistanceToBoundingVolume2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::getDistanceToBoundingVolume2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>a_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the unsigned square from a 3D point to the bounding volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_point</td><td>3D point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns squared distance to bounding volume. A zero distance implies that the input point is inside the bounding volume. </dd></dl>

</div>
</div>
<a id="a61dc7040d57f0a69984548eb4804244b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61dc7040d57f0a69984548eb4804244b">&#9670;&nbsp;</a></span>getDistanceToPrimitives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::getDistanceToPrimitives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>a_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the shortest distance to the primitives in this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_point</td><td>3D point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the signed distance to the primitives. </dd></dl>

</div>
</div>
<a id="a7b9e3a8bfa35f604298634da102a0ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9e3a8bfa35f604298634da102a0ce4">&#9670;&nbsp;</a></span>getNodeType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceBVH.html#a7613f83a60cfae9aba31861110bd9e54">NodeType</a> <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::getNodeType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the node type. </p>
<dl class="section return"><dt>Returns</dt><dd>Node type </dd></dl>

</div>
</div>
<a id="a2e0c1e030162a2dc049acb4debd4d9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0c1e030162a2dc049acb4debd4d9f2">&#9670;&nbsp;</a></span>getPrimitives() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceBVH.html#aa1e753bda451b85cd5b948722a2ad7c7">PrimitiveListT</a>&lt; P &gt; &amp; <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::getPrimitives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the primitives stored in this node. </p>
<dl class="section return"><dt>Returns</dt><dd>List of primitives. </dd></dl>

</div>
</div>
<a id="adce9d9c6bd4ab3d613bef232353774f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce9d9c6bd4ab3d613bef232353774f3">&#9670;&nbsp;</a></span>getPrimitives() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceBVH.html#aa1e753bda451b85cd5b948722a2ad7c7">PrimitiveListT</a>&lt; P &gt; &amp; <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::getPrimitives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the list of primitives in this node. </p>
<dl class="section return"><dt>Returns</dt><dd>Primitives list </dd></dl>

</div>
</div>
<a id="a8113c8dfa5ab6dc3cf931c5c8fdd6ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8113c8dfa5ab6dc3cf931c5c8fdd6ddb">&#9670;&nbsp;</a></span>insertNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::insertNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBVH_1_1NodeT.html#a008f5c2c53adb1f5730d8478b48529b1">NodePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>a_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a19cce6e7fbe85eccb4a3718dd69f49b7">PrimitiveList</a> &amp;&#160;</td>
          <td class="paramname"><em>a_primitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new node in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_node</td><td>Node to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_primitives</td><td>Primitives provided to a_node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3aa6e9109897a573a46714278e0a79c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa6e9109897a573a46714278e0a79c6">&#9670;&nbsp;</a></span>pruneOrdered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::pruneOrdered </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>a_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which computes the signed distance using ordered pruning along the <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality. ">BVH</a> branches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_point</td><td>3D point in space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signed distance to the input point</dd></dl>
<p>This routine computes the distance to a_point using ordered pruning. We begin at the top (root node of the tree) and descend downwards. This routine first descends along the sub-branch with the shortest distance to its bounding volume. Once we hit leaf node we update the shortest distance 'd' found so far. As we investigate more branches, they can be pruned if the distance 'd' is shorter than the distance to the node's bounding volume. </p>

</div>
</div>
<a id="ac4a3be457d66d2673f717f203e60fc08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a3be457d66d2673f717f203e60fc08">&#9670;&nbsp;</a></span>pruneOrdered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::pruneOrdered </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a_closest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>a_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation function for pruneOrdered (it requires a different signature). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_closest</td><td>Shortest distance to primitives so far. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_point</td><td>Input 3D point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb7fec40e06e97fcd42ec75169603e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7fec40e06e97fcd42ec75169603e8b">&#9670;&nbsp;</a></span>pruneOrdered2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::pruneOrdered2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>a_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which computes the signed distance using ordered pruning along the <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality. ">BVH</a> branches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_point</td><td>3D point in space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signed distance to the input point</dd></dl>
<p>This routine computes the distance to a_point using ordered pruning. We begin at the top (root node of the tree) and descend downwards. This routine first descends along the sub-branch with the shortest distance to its bounding volume. Once we hit leaf node we update the shortest distance 'd' found so far. As we investigate more branches, they can be pruned if the distance 'd' is shorter than the distance to the node's bounding volume. </p><dl class="section note"><dt>Note</dt><dd>The difference between this and pruneOrdered(a_point) only consist of the fact that this routine uses the unsigned square distance to prune branches and primitives. This is more efficient than pruneOrdered(a_point) because it does e.g. not involve an extra square root for computing the distance. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the signed distance from a_point to the primitives. </dd></dl>

</div>
</div>
<a id="a2887ad51251739359602dde8db6a5998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2887ad51251739359602dde8db6a5998">&#9670;&nbsp;</a></span>pruneOrdered2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::pruneOrdered2 </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a_minDist2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_closest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>a_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation function for pruneOrdered2 (it requires a different signature). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_minDist2</td><td>Shortest square distance so far. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_closest</td><td>Closest primitive so far. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_point</td><td>Input 3D point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27cfc030a9b7f9b0341e94dc6733b511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27cfc030a9b7f9b0341e94dc6733b511">&#9670;&nbsp;</a></span>pruneUnordered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::pruneUnordered </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>a_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which computes the signed distance using unordered pruning along the <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality. ">BVH</a> branches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_point</td><td>3D point in space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signed distance to the input point</dd></dl>
<p>This routine computes the distance to a_point using unordered pruning. We begin at the top (root node of the tree) and descend downwards. This routine visits nodes in the order they were created. Once we hit leaf node we update the shortest distance 'd' found so far. As we investigate more branches, they can be pruned if the distance 'd' is shorter than the distance to the node's bounding volume. </p><dl class="section note"><dt>Note</dt><dd>The difference between this and pruneOrdered(a_point) is that this routine always does the nodes in the order they were created. In almost all cases this is more inefficient than pruneOrdered(a_point). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the signed distance from a_point to the primitives. </dd></dl>

</div>
</div>
<a id="ad252aa451ca983750dfa0c24344253b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad252aa451ca983750dfa0c24344253b2">&#9670;&nbsp;</a></span>pruneUnordered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::pruneUnordered </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a_closest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>a_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation function for pruneUnordered (it requires a different signature). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_closest</td><td>Shortest distance to primitives so far. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_point</td><td>Input 3D point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafa2f1f4f4f58296531723e9a6d7d13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa2f1f4f4f58296531723e9a6d7d13a">&#9670;&nbsp;</a></span>pruneUnordered2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::pruneUnordered2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>a_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which computes the signed distance using unordered pruning along the <a class="el" href="namespaceBVH.html" title="Namespace for various bounding volume heirarchy (BVH) functionality. ">BVH</a> branches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_point</td><td>3D point in space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signed distance to the input point</dd></dl>
<p>This routine computes the distance to a_point using unordered pruning. We begin at the top (root node of the tree) and descend downwards. This routine visits nodes in the order they were created. Once we hit leaf node we update the shortest distance 'd' found so far. As we investigate more branches, they can be pruned if the distance 'd' is shorter than the distance to the node's bounding volume. The only difference between this routine and pruneUnordered(a_point) is that this routine prunes based on the unsigned square distance first, and only computes the signed distance at the end. </p><dl class="section note"><dt>Note</dt><dd>The difference between this and pruneOrdered2(a_point) is that this routine always does nodes in the order they were created. In almost all cases this is more inefficient than pruneOrdered2(a_point). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the signed distance from a_point to the primitives. </dd></dl>

</div>
</div>
<a id="a1079cba9ac1f114ad2cbc6cdea2eae49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1079cba9ac1f114ad2cbc6cdea2eae49">&#9670;&nbsp;</a></span>pruneUnordered2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::pruneUnordered2 </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a_minDist2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_closest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>a_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation function for pruneUnordered2 (it requires a different signature). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_minDist2</td><td>Shortest square distance so far. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_closest</td><td>Closest primitive so far. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_point</td><td>Input 3D point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdff7fdbe3694e2aeb788261175077cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdff7fdbe3694e2aeb788261175077cc">&#9670;&nbsp;</a></span>setDepth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::setDepth </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_depth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set node depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depth</td><td>Node depth </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a964bd054b57fce2fec50505a65f6bacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964bd054b57fce2fec50505a65f6bacd">&#9670;&nbsp;</a></span>setNodeType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::setNodeType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceBVH.html#a7613f83a60cfae9aba31861110bd9e54">NodeType</a>&#160;</td>
          <td class="paramname"><em>a_nodeType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set node type to leaf or regular. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nodeType</td><td>Node type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92db0ab2d61c76469600478fddd04edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92db0ab2d61c76469600478fddd04edc">&#9670;&nbsp;</a></span>setParent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::setParent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a008f5c2c53adb1f5730d8478b48529b1">NodePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>a_parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set parent node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_parent</td><td>Parent node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c9c3d3a83b3c1895c8f89b2bbd62e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9c3d3a83b3c1895c8f89b2bbd62e81">&#9670;&nbsp;</a></span>setPrimitives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::setPrimitives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a19cce6e7fbe85eccb4a3718dd69f49b7">PrimitiveList</a> &amp;&#160;</td>
          <td class="paramname"><em>a_primitives</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set primitives in this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_primitives</td><td>Primitives </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f9c409918d61b0d0ad3dd6e2b692443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9c409918d61b0d0ad3dd6e2b692443">&#9670;&nbsp;</a></span>setToRegularNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::setToRegularNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set to regular node. </p>
<dl class="section note"><dt>Note</dt><dd>This sets m_nodeType to regular and clears the primitives list </dd></dl>

</div>
</div>
<a id="aef7148b18296dce60853b5966c9f1e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7148b18296dce60853b5966c9f1e0d">&#9670;&nbsp;</a></span>signedDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::signedDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a6fbb4308c5c55ee170c5f992df7ae1d0">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>a_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceBVH.html#a3ddb7b34ac1deb3baed2f32d9eacbe5b">Prune</a>&#160;</td>
          <td class="paramname"><em>a_pruning</em> = <code>Prune::Ordered2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which computes the signed distance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_point</td><td>3D point in space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_pruning</td><td>Pruning algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signed distance to the input point</dd></dl>
<p>This will select amongs the various implementations. </p>

</div>
</div>
<a id="acae5a575fa8b236de984fdd41e04c038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae5a575fa8b236de984fdd41e04c038">&#9670;&nbsp;</a></span>topDownSortAndPartitionPrimitives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class BV , int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBVH_1_1NodeT.html">BVH::NodeT</a>&lt; T, P, BV, K &gt;::topDownSortAndPartitionPrimitives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a2340f2466ed5b6eebab4bdc72004858e">BVConstructor</a> &amp;&#160;</td>
          <td class="paramname"><em>a_bvConstructor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#a3bb028655b8b961fa35109af1c14f281">Partitioner</a> &amp;&#160;</td>
          <td class="paramname"><em>a_partitioner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBVH_1_1NodeT.html#acbe56195affc439febe8aca84db308e3">StopFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>a_stopCrit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function for using top-down construction of the bounding volume hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_bvConstructor</td><td>Polymorphic function which builds a bounding volume from a set of primitives. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_partitioner</td><td>Partitioning function. This is a polymorphic function which divides a set of primitives into two lists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_stopCrit</td><td>Termination function which tells us when to stop the recursion.</td></tr>
  </table>
  </dd>
</dl>
<p>The rules for terminating the hierarchy construction, how to partition sets of primitives, and how to enclose them by bounding volumes are given in the input arguments (a_stopFunc, a_partFunc, a_bvFunc) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/<a class="el" href="EBGeometry__BVH_8hpp_source.html">EBGeometry_BVH.hpp</a></li>
<li>Source/<a class="el" href="EBGeometry__BVHImplem_8hpp_source.html">EBGeometry_BVHImplem.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
