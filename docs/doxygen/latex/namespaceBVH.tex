\hypertarget{namespaceBVH}{}\section{B\+VH Namespace Reference}
\label{namespaceBVH}\index{B\+VH@{B\+VH}}


Namespace for various bounding volume heirarchy (\hyperlink{namespaceBVH}{B\+VH}) functionality.  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classBVH_1_1LinearBVH}{Linear\+B\+VH}
\begin{DoxyCompactList}\small\item\em Forward declare linear \hyperlink{namespaceBVH}{B\+VH} class. \end{DoxyCompactList}\item 
class \hyperlink{classBVH_1_1LinearNodeT}{Linear\+NodeT}
\begin{DoxyCompactList}\small\item\em Forward declare linear node class. \end{DoxyCompactList}\item 
class \hyperlink{classBVH_1_1NodeT}{NodeT}
\begin{DoxyCompactList}\small\item\em Forward declare the \hyperlink{namespaceBVH}{B\+VH} node since it is needed for the polymorphic lambdas. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class P $>$ }\\using \hyperlink{namespaceBVH_aa1e753bda451b85cd5b948722a2ad7c7}{Primitive\+ListT} = std\+::vector$<$ std\+::shared\+\_\+ptr$<$ const P $>$ $>$
\begin{DoxyCompactList}\small\item\em Alias to cut down on typing. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T , class P , class BV , int K$>$ }\\using \hyperlink{namespaceBVH_afef1c5979c34a11d23b756cc09654bf9}{Stop\+FunctionT} = std\+::function$<$ bool(const \hyperlink{classBVH_1_1NodeT}{NodeT}$<$ T, P, BV, K $>$ \&a\+\_\+node)$>$
\begin{DoxyCompactList}\small\item\em Stop function for deciding when a \hyperlink{namespaceBVH}{B\+VH} node can\textquotesingle{}t be divided into sub-\/volumes. \end{DoxyCompactList}\item 
{\footnotesize template$<$class P , int K$>$ }\\using \hyperlink{namespaceBVH_a7c33d54da9893d506709b2ca96b76f55}{PartitionerT} = std\+::function$<$ std\+::array$<$ \hyperlink{namespaceBVH_aa1e753bda451b85cd5b948722a2ad7c7}{Primitive\+ListT}$<$ P $>$, K $>$(const \hyperlink{namespaceBVH_aa1e753bda451b85cd5b948722a2ad7c7}{Primitive\+ListT}$<$ P $>$ \&a\+\_\+primitives)$>$
\begin{DoxyCompactList}\small\item\em Polymorphic partitioner for splitting a list of primitives into K new lists of primitives. \end{DoxyCompactList}\item 
{\footnotesize template$<$class P , class BV $>$ }\\using \hyperlink{namespaceBVH_a245702d7eff40cdaedb5dff68c25a88a}{B\+V\+ConstructorT} = std\+::function$<$ BV(const std\+::shared\+\_\+ptr$<$ const P $>$ \&a\+\_\+primitive)$>$
\begin{DoxyCompactList}\small\item\em Constructor method for creating bounding volumes from a list of primitives. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{namespaceBVH_a3ddb7b34ac1deb3baed2f32d9eacbe5b}{Prune} \{ {\bfseries Stack}, 
{\bfseries Ordered}, 
{\bfseries Unordered}
 \}\begin{DoxyCompactList}\small\item\em Typename for identifying algorithms various algorithms during tree traversel. \end{DoxyCompactList}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Namespace for various bounding volume heirarchy (\hyperlink{namespaceBVH}{B\+VH}) functionality. 

\subsection{Typedef Documentation}
\mbox{\Hypertarget{namespaceBVH_a245702d7eff40cdaedb5dff68c25a88a}\label{namespaceBVH_a245702d7eff40cdaedb5dff68c25a88a}} 
\index{B\+VH@{B\+VH}!B\+V\+ConstructorT@{B\+V\+ConstructorT}}
\index{B\+V\+ConstructorT@{B\+V\+ConstructorT}!B\+VH@{B\+VH}}
\subsubsection{\texorpdfstring{B\+V\+ConstructorT}{BVConstructorT}}
{\footnotesize\ttfamily template$<$class P , class BV $>$ \\
using \hyperlink{namespaceBVH_a245702d7eff40cdaedb5dff68c25a88a}{B\+V\+H\+::\+B\+V\+ConstructorT} = typedef std\+::function$<$BV(const std\+::shared\+\_\+ptr$<$const P$>$\& a\+\_\+primitive)$>$}



Constructor method for creating bounding volumes from a list of primitives. 

P is the primitive type bound in the \hyperlink{namespaceBVH}{B\+VH} and BV is the bounding volume type. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em a\+\_\+primitives} & List of primitives. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a new bounding volumes which is guaranteed to enclose all the input primitives. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceBVH_a7c33d54da9893d506709b2ca96b76f55}\label{namespaceBVH_a7c33d54da9893d506709b2ca96b76f55}} 
\index{B\+VH@{B\+VH}!PartitionerT@{PartitionerT}}
\index{PartitionerT@{PartitionerT}!B\+VH@{B\+VH}}
\subsubsection{\texorpdfstring{PartitionerT}{PartitionerT}}
{\footnotesize\ttfamily template$<$class P , int K$>$ \\
using \hyperlink{namespaceBVH_a7c33d54da9893d506709b2ca96b76f55}{B\+V\+H\+::\+PartitionerT} = typedef std\+::function$<$std\+::array$<$\hyperlink{namespaceBVH_aa1e753bda451b85cd5b948722a2ad7c7}{Primitive\+ListT}$<$P$>$, K$>$(const \hyperlink{namespaceBVH_aa1e753bda451b85cd5b948722a2ad7c7}{Primitive\+ListT}$<$P$>$\& a\+\_\+primitives)$>$}



Polymorphic partitioner for splitting a list of primitives into K new lists of primitives. 

P is the primitive type bound in the \hyperlink{namespaceBVH}{B\+VH} and K is the \hyperlink{namespaceBVH}{B\+VH} degree. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em a\+\_\+primitives} & List of primitives to be subdivided into sub-\/bounding volumes. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a list (std\+::array) of new primitives which make up the new bounding volumes. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceBVH_aa1e753bda451b85cd5b948722a2ad7c7}\label{namespaceBVH_aa1e753bda451b85cd5b948722a2ad7c7}} 
\index{B\+VH@{B\+VH}!Primitive\+ListT@{Primitive\+ListT}}
\index{Primitive\+ListT@{Primitive\+ListT}!B\+VH@{B\+VH}}
\subsubsection{\texorpdfstring{Primitive\+ListT}{PrimitiveListT}}
{\footnotesize\ttfamily template$<$class P $>$ \\
using \hyperlink{namespaceBVH_aa1e753bda451b85cd5b948722a2ad7c7}{B\+V\+H\+::\+Primitive\+ListT} = typedef std\+::vector$<$std\+::shared\+\_\+ptr$<$const P$>$ $>$}



Alias to cut down on typing. 

P is the primitive bounded by the \hyperlink{namespaceBVH}{B\+VH}. \mbox{\Hypertarget{namespaceBVH_afef1c5979c34a11d23b756cc09654bf9}\label{namespaceBVH_afef1c5979c34a11d23b756cc09654bf9}} 
\index{B\+VH@{B\+VH}!Stop\+FunctionT@{Stop\+FunctionT}}
\index{Stop\+FunctionT@{Stop\+FunctionT}!B\+VH@{B\+VH}}
\subsubsection{\texorpdfstring{Stop\+FunctionT}{StopFunctionT}}
{\footnotesize\ttfamily template$<$class T , class P , class BV , int K$>$ \\
using \hyperlink{namespaceBVH_afef1c5979c34a11d23b756cc09654bf9}{B\+V\+H\+::\+Stop\+FunctionT} = typedef std\+::function$<$bool(const \hyperlink{classBVH_1_1NodeT}{NodeT}$<$T, P, BV, K$>$\& a\+\_\+node)$>$}



Stop function for deciding when a \hyperlink{namespaceBVH}{B\+VH} node can\textquotesingle{}t be divided into sub-\/volumes. 

T is the precision used in the \hyperlink{namespaceBVH}{B\+VH} computations, P is the enclosing primitive and BV is the bounding volume used in the \hyperlink{namespaceBVH}{B\+VH}. K is the tree degree. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em a\+\_\+node} & \hyperlink{namespaceBVH}{B\+VH} node \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the node can\textquotesingle{}t be divided into subvolumes and false otherwise. 
\end{DoxyReturn}


\subsection{Enumeration Type Documentation}
\mbox{\Hypertarget{namespaceBVH_a3ddb7b34ac1deb3baed2f32d9eacbe5b}\label{namespaceBVH_a3ddb7b34ac1deb3baed2f32d9eacbe5b}} 
\index{B\+VH@{B\+VH}!Prune@{Prune}}
\index{Prune@{Prune}!B\+VH@{B\+VH}}
\subsubsection{\texorpdfstring{Prune}{Prune}}
{\footnotesize\ttfamily enum \hyperlink{namespaceBVH_a3ddb7b34ac1deb3baed2f32d9eacbe5b}{B\+V\+H\+::\+Prune}\hspace{0.3cm}{\ttfamily [strong]}}



Typename for identifying algorithms various algorithms during tree traversel. 

Stack =$>$ Use stack/priority queue (ordered traversal). Ordered =$>$ Use recursive ordered traversal. Unordered =$>$ Use recursive unordered traversal. 