<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BVH &mdash; EBGeometry  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="_static/my_theme.css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Octree" href="ImplemOctree.html" />
    <link rel="prev" title="DCEL" href="ImplemDCEL.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            EBGeometry
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="Introduction.html#quickstart">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="Introduction.html#third-party-examples">Third-party examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Basic concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Concepts.html">Geometry representations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Concepts.html#dcel">DCEL</a></li>
<li class="toctree-l1"><a class="reference internal" href="Concepts.html#bounding-volume-hierarchies">Bounding volume hierarchies</a></li>
<li class="toctree-l1"><a class="reference internal" href="Concepts.html#octree">Octree</a></li>
<li class="toctree-l1"><a class="reference internal" href="Concepts.html#constructive-solid-geometry">Constructive solid geometry</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Implementation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Implementation.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplemVec.html">Vector types</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplemCSG.html">Geometry representation</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplemDCEL.html">DCEL</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">BVH</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#bounding-volumes">Bounding volumes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#construction">Construction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#top-down-construction">Top-down construction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bottom-up-construction">Bottom-up construction</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#compact-form">Compact form</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tree-traversal">Tree traversal</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#node-visit">Node visit</a></li>
<li class="toctree-l3"><a class="reference internal" href="#traversal-pattern">Traversal pattern</a></li>
<li class="toctree-l3"><a class="reference internal" href="#update-rule">Update rule</a></li>
<li class="toctree-l3"><a class="reference internal" href="#meta-data">Meta-data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#traversal-algorithm">Traversal algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#traversal-examples">Traversal examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#signed-distance">Signed distance</a></li>
<li class="toctree-l4"><a class="reference internal" href="#csg-union">CSG Union</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ImplemOctree.html">Octree</a></li>
<li class="toctree-l1"><a class="reference internal" href="Parsers.html">Reading data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Examples.html">EBGeometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="Examples.html#amrex">AMReX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Examples.html#chombo3">Chombo3</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="ZZReferences.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EBGeometry</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">BVH</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/ImplemBVH.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="bvh">
<span id="chap-implembvh"></span><h1>BVH<a class="headerlink" href="#bvh" title="Permalink to this heading">ÔÉÅ</a></h1>
<p>The BVH functionality is encapsulated in the namespace <code class="docutils literal notranslate"><span class="pre">EBGeometry::BVH</span></code>.
For the full API, see <a class="reference external" href="doxygen/html/namespaceBVH.html">the doxygen API</a>.
There are two types of BVHs supported.</p>
<ul class="simple">
<li><p><strong>Full BVHs</strong> where the nodes are stored in build order and contain references to their children.</p></li>
<li><p><strong>Compact BVHs</strong> where the nodes are stored in depth-first order and contain index offsets to children and primitives.</p></li>
</ul>
<p>The full BVH is encapsulated by a class</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BV</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">NodeT</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The above template parameters are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code> Floating-point precision.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">P</span></code> Primitive type to be partitioned.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BV</span></code> Bounding volume type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">K</span></code> BVH degree. <code class="docutils literal notranslate"><span class="pre">K=2</span></code> will yield a binary tree, <code class="docutils literal notranslate"><span class="pre">K=3</span></code> yields a tertiary tree and so on.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">NodeT</span></code> describes regular and leaf nodes in the BVH, and has member functions for setting primitives, bounding volumes, and so on.
Importantly, <code class="docutils literal notranslate"><span class="pre">NodeT</span></code> is the BVH builder node, i.e. it is the class through which we recursively build the BVH, see <a class="reference internal" href="#chap-bvhconstruction"><span class="std std-ref">Construction</span></a>.
The compact BVH is discussed below in <a class="reference internal" href="#chap-linearbvh"><span class="std std-ref">Compact form</span></a>.</p>
<section id="bounding-volumes">
<h2>Bounding volumes<a class="headerlink" href="#bounding-volumes" title="Permalink to this heading">ÔÉÅ</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">EBGeometry</span></code> supports the following bounding volumes, which are defined in <code class="file docutils literal notranslate"><span class="pre">EBGeometry_BoundingVolumes.hpp</span></code>:</p>
<ul class="simple">
<li><p><strong>BoundingSphere</strong>, templated as <code class="docutils literal notranslate"><span class="pre">EBGeometry::BoundingVolumes::BoundingSphereT&lt;T&gt;</span></code> and describes a bounding sphere.
Various constructors are available.</p></li>
<li><p><strong>Axis-aligned bounding box</strong>, which is templated as <code class="docutils literal notranslate"><span class="pre">EBGeometry::BoundingVolumes::AABBT&lt;T&gt;</span></code>.</p></li>
</ul>
<p>For full API details, see <a class="reference external" href="doxygen/html/namespaceBoundingVolumes.html">the doxygen API</a>.
Other types of bounding volumes can in principle be added, with the only requirement being that they conform to the same interface as the <code class="docutils literal notranslate"><span class="pre">AABB</span></code> and <code class="docutils literal notranslate"><span class="pre">BoundingSphere</span></code> volumes.</p>
</section>
<section id="construction">
<span id="chap-bvhconstruction"></span><h2>Construction<a class="headerlink" href="#construction" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>Constructing a BVH is done by:</p>
<ol class="arabic simple">
<li><p>Creating a root node and providing it with the geometric primitives and their bounding volumes.</p></li>
<li><p>Partitioning the BVH by providing a partitioning function.</p></li>
</ol>
<p>The first step is usually a matter of simply constructing the root node using the full constructor, which takes a list of primitives and their associated bounding volumes.
The second step is to recursively build the BVH.
We currently support top-down and bottom-up construction (using space-filling curves).</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The default construction methods performs the hierarchical subdivision by only considering the <em>bounding volumes</em>.
Consequently, the build process is identical regardless of what type of primitives (e.g., triangles or analytic spheres) are contained in the BVH.</p>
</div>
<section id="top-down-construction">
<h3>Top-down construction<a class="headerlink" href="#top-down-construction" title="Permalink to this heading">ÔÉÅ</a></h3>
<p>Top-down construction is done through the function <code class="docutils literal notranslate"><span class="pre">topDownSortAndPartition()</span></code>, <a class="reference external" href="doxygen/html/doxygen/html/classBVH_1_1NodeT.html">see the doxygen API for the BVH implementation</a>.</p>
<p>The optional input arguments to <code class="docutils literal notranslate"><span class="pre">topDownSortAndPartition</span></code> are polymorphic functions of type indicated above, and have the following responsibilities:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PartitionerT</span></code> is the partitioner function when splitting a leaf node into <code class="docutils literal notranslate"><span class="pre">K</span></code> new leaves.
The function takes a list of primitives which it partitions into <code class="docutils literal notranslate"><span class="pre">K</span></code> new lists of primitives.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">StopFunctionT</span></code> simply takes a <code class="docutils literal notranslate"><span class="pre">NodeT</span></code> as input argument and determines if the node should be partitioned further.</p></li>
</ul>
<p>Default arguments for these are provided, bubt users are free to partition their BVHs in their own way should they choose.</p>
</section>
<section id="bottom-up-construction">
<h3>Bottom-up construction<a class="headerlink" href="#bottom-up-construction" title="Permalink to this heading">ÔÉÅ</a></h3>
<p>The bottom-up construction uses a space-filling curve (e.g., a Morton curve) for first building the leaf nodes.
This construction is done such that each leaf node contains approximately the number of primitives, and all leaf nodes exist on the same level.
To use bottom-up construction, one may use the member function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="cm">/*!</span>
<span class="cm">      @brief Function for doing bottom-up construction using a specified space-filling curve.</span>
<span class="cm">      @details The template parameter is the space-filling curve type. This function will partition the BVH</span>
<span class="cm">      by first sorting the bounding volume centroids along the space-filling curve. The tree is then constructed</span>
<span class="cm">      by placing at least K primitives in each leaf, and the leaves are then merged upwards until we reach the</span>
<span class="cm">      root node.</span>
<span class="cm">      @note S must have an encode and decode function which returns an SFC index. See the SFC namespace for</span>
<span class="cm">      examples for Morton and Nested indices. </span>
<span class="cm">    */</span><span class="w"></span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">S</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="w">    </span><span class="n">bottomUpSortAndPartition</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The template argument is the space-filling curve that the user wants to apply.
Currently, we support Morton codes and nested indices.
For Morton curves, one would e.g. call <code class="docutils literal notranslate"><span class="pre">bottomUpSortAndPartition&lt;SFC::Morton&gt;</span></code> while for nested indices (which are not recommended) the signature is likewise <code class="docutils literal notranslate"><span class="pre">bottomUpSortAndPartition&lt;SFC::Nested</span></code>.</p>
<p>Build times for SFC-based bottom-up construction are generally speaking faster than top-down construction, but tends to produce worse trees such that traversal becomes slower.</p>
</section>
</section>
<section id="compact-form">
<span id="chap-linearbvh"></span><h2>Compact form<a class="headerlink" href="#compact-form" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>In addition to the standard BVH node <code class="docutils literal notranslate"><span class="pre">NodeT&lt;T,</span> <span class="pre">P,</span> <span class="pre">BV,</span> <span class="pre">K&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">EBGeometry</span></code> provides a more compact formulation of the BVH hierarchy where the nodes are stored in depth-first order.
The ‚Äúlinearized‚Äù BVH can be automatically constructed from the standard BVH but not vice versa.</p>
<figure class="align-center" id="id1">
<a class="reference internal image-reference" href="_images/CompactBVH.png"><img alt="_images/CompactBVH.png" src="_images/CompactBVH.png" style="width: 240px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 6 </span><span class="caption-text">Compact BVH representation.
The original BVH is traversed from top-to-bottom along the branches and laid out in linear memory.
Each interior node gets a reference (index offset) to their children nodes.</span><a class="headerlink" href="#id1" title="Permalink to this image">ÔÉÅ</a></p>
</figcaption>
</figure>
<p>The rationale for reorganizing the BVH in compact form is it‚Äôs tighter memory footprint and depth-first ordering which occasionally allows a more efficient traversal downwards in the BVH tree, particularly if the geometric primitives are sorted in the same order.
To encapsulate the compact BVH we provide two classes:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">LinearNodeT</span></code> which encapsulates a node, but rather than storing the primitives and pointers to child nodes it stores offsets along the 1D arrays.
Just like <code class="docutils literal notranslate"><span class="pre">NodeT</span></code> the class is templated:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BV</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">LinearNodeT</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">LinearNodeT</span></code> has a smaller memory footprint and should fit in one CPU word in floating-point precision and two CPU words in double point precision.
The performance benefits of further memory alignment have not been investigated.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">LinearNodeT</span></code> only stores offsets to child nodes and primitives, which are assumed to be stored (somewhere) as</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">LinearNodeT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">BV</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">linearNodes</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">primitives</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Thus, for a given node we can check if it is a leaf node (<code class="docutils literal notranslate"><span class="pre">m_numPrimitives</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>) and if it is we can get the children through the <code class="docutils literal notranslate"><span class="pre">m_childOffsets</span></code> array.
Primitives can likewise be obtained; they are stored in the primitives array from index <code class="docutils literal notranslate"><span class="pre">m_primitivesOffset</span></code> to <code class="docutils literal notranslate"><span class="pre">m_primitivesOffset</span> <span class="pre">+</span> <span class="pre">m_numPrimities</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">LinearBVH</span></code> which stores the compact BVH <em>and</em> primitives as class members.
That is, <code class="docutils literal notranslate"><span class="pre">LinearBVH</span></code> contains the nodes and primitives as class members.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BV</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">LinearBVH</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>

<span class="k">protected</span><span class="o">:</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">LinearNodeT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">BV</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">m_linearNodes</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">m_primitives</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>The root node is, of course, found at the front of the <code class="docutils literal notranslate"><span class="pre">m_linearNodes</span></code> vector.
Note that the list of primitives <code class="docutils literal notranslate"><span class="pre">m_primitives</span></code> is stored in the order in which the leaf nodes appear in <code class="docutils literal notranslate"><span class="pre">m_linearNodes</span></code>.</p>
</li>
</ul>
<p>Constructing the compact BVH is simply a matter of letting <code class="docutils literal notranslate"><span class="pre">NodeT</span></code> aggregate the nodes and primitives into arrays, and return a <code class="docutils literal notranslate"><span class="pre">LinearBVH</span></code>.
This is done by calling the <code class="docutils literal notranslate"><span class="pre">NodeT</span></code> member function <code class="docutils literal notranslate"><span class="pre">flattenTree()</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BV</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">NodeT</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>

<span class="w">  </span><span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">LinearBVH</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">BV</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;&gt;</span><span class="w"></span>
<span class="w">  </span><span class="n">flattenTree</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>which returns a pointer to a <code class="docutils literal notranslate"><span class="pre">LinearBVH</span></code>.
For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Assume that we have built the conventional BVH already</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">EBGeometry</span><span class="o">::</span><span class="n">BVH</span><span class="o">::</span><span class="n">NodeT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">BV</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">builderBVH</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Flatten the tree.</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">LinearBVH</span><span class="o">&gt;</span><span class="w"> </span><span class="n">compactBVH</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builderBVH</span><span class="o">-&gt;</span><span class="n">flattenTree</span><span class="p">();</span><span class="w"></span>

<span class="c1">// Release the original BVH.</span>
<span class="n">builderBVH</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When calling <code class="docutils literal notranslate"><span class="pre">flattenTree</span></code>, the original BVH tree is <em>not</em> destroyed.
To release the memory, deallocate the original BVH tree.
E.g., the set pointer to the root node to <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> or ensure correct scoping.</p>
</div>
</section>
<section id="tree-traversal">
<h2>Tree traversal<a class="headerlink" href="#tree-traversal" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>Both <code class="docutils literal notranslate"><span class="pre">NodeT</span></code> (full BVH) and <code class="docutils literal notranslate"><span class="pre">LinearBVH</span></code> (flattened BVH) include routines for traversing the BVH with user-specified criteria.
For both BVH representations, tree traversal is done using a routine</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="o">&gt;</span><span class="w"></span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="n">traverse</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">BVH</span><span class="o">::</span><span class="n">Updater</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w">                    </span><span class="n">a_updater</span><span class="p">,</span><span class="w"></span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="n">BVH</span><span class="o">::</span><span class="n">Visiter</span><span class="o">&lt;</span><span class="n">LinearNode</span><span class="p">,</span><span class="w"> </span><span class="n">Meta</span><span class="o">&gt;&amp;</span><span class="w">     </span><span class="n">a_visiter</span><span class="p">,</span><span class="w"></span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="n">BVH</span><span class="o">::</span><span class="n">Sorter</span><span class="o">&lt;</span><span class="n">LinearNode</span><span class="p">,</span><span class="w"> </span><span class="n">Meta</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;&amp;</span><span class="w">   </span><span class="n">a_sorter</span><span class="p">,</span><span class="w"></span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="n">BVH</span><span class="o">::</span><span class="n">MetaUpdater</span><span class="o">&lt;</span><span class="n">LinearNode</span><span class="p">,</span><span class="w"> </span><span class="n">Meta</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_metaUpdater</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The BVH trees use a stack-based traversal pattern based on visit-sort rules supplied by the user.</p>
<section id="node-visit">
<h3>Node visit<a class="headerlink" href="#node-visit" title="Permalink to this heading">ÔÉÅ</a></h3>
<p>Here, <code class="docutils literal notranslate"><span class="pre">a_visiter</span></code> is a lambda function for determining if the node/subtree should be investigated or pruned from the traversal.
This function has a signature</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">NodeType</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Visiter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">NodeType</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Meta</span><span class="w"> </span><span class="n">a_meta</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">NodeType</span></code> is the type of node (which is different for full/flat BVHs), and the <code class="docutils literal notranslate"><span class="pre">Meta</span></code> template parameter is discussed below.
If this function returns true, the node will be visisted and if the function returns false then the node will be pruned from the tree traversal. Typically, the <code class="docutils literal notranslate"><span class="pre">Meta</span></code> parameter will contain the necessary information that determines whether or not to visit the subtree.</p>
</section>
<section id="traversal-pattern">
<h3>Traversal pattern<a class="headerlink" href="#traversal-pattern" title="Permalink to this heading">ÔÉÅ</a></h3>
<p>If a subtree is visited in the traversal, there is a question of which of the child nodes to visit first.
The <code class="docutils literal notranslate"><span class="pre">a_sorter</span></code> argument determines the order by letting the user sort the nodes based on order of importance.
Note that a correct visitation pattern can yield large performance benefits.
The user is given the option to sort the child nodes based on what he/she thinks is a good order, which is done by supplying a lambda which sorts the children.
This function has the signature:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">NodeType</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Sorter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">NodeType</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Meta</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_children</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Sorting the child nodes is completely optional.
The user can leave this function empty if it does not matter which subtrees are visited first.</p>
</section>
<section id="update-rule">
<h3>Update rule<a class="headerlink" href="#update-rule" title="Permalink to this heading">ÔÉÅ</a></h3>
<p>If a leaf node is visited in the traversal, distance or other types of queries to the geometric primitive(s) in the nodes are usually made.
These are done by a user-supplied update-rule:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Updater</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PrimitiveListT</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_primitives</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Typically, the <code class="docutils literal notranslate"><span class="pre">Updater</span></code> will modify parameters that appear in a local scope outside of the tree traversal (e.g. updating the minimum distance to a DCEL mesh).</p>
</section>
<section id="meta-data">
<h3>Meta-data<a class="headerlink" href="#meta-data" title="Permalink to this heading">ÔÉÅ</a></h3>
<p>During the traversal, it might be necessary to compute meta-data that is helpful during the traversal, and this meta-data is attached to each node that is queried.
This meta-data is usually, but not necessarily, equal to the distance to the nodes‚Äô bounding volumes.
The signature for meta-data construction is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">NodeType</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">MetaUpdater</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">Meta</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">NodeType</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_node</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The biggest difference between <code class="docutils literal notranslate"><span class="pre">Updater</span></code> and <code class="docutils literal notranslate"><span class="pre">MetaUpdater</span></code> is that <code class="docutils literal notranslate"><span class="pre">Updater</span></code> is <em>only</em> called on leaf nodes whereas <code class="docutils literal notranslate"><span class="pre">MetaUpdater</span></code> is also called for internal nodes.
One typical example for DCEL meshes is that <code class="docutils literal notranslate"><span class="pre">Updater</span></code> computes the distance from an input point to the triangles in a leaf node, whereas <code class="docutils literal notranslate"><span class="pre">MetaUpdater</span></code> computes the distance from the input point to the bounding volumes of a child nodes.
This information is then used in <code class="docutils literal notranslate"><span class="pre">Sorter</span></code> in order to determine a preferred child visit pattern when descending along subtrees.</p>
</section>
<section id="traversal-algorithm">
<h3>Traversal algorithm<a class="headerlink" href="#traversal-algorithm" title="Permalink to this heading">ÔÉÅ</a></h3>
<p>The code-block below shows the implementation of the BVH traversal.
The implementation uses a non-recursive queue-based formulation when descending along subtrees.
Observe that each entry in the stack contains both the node itself <em>and</em> any meta-data we want to attach to the node.
If the traversal decides to visit a node, it immediately computes the specified meta-data of the node, and the user can then sort the children based on that data.</p>
<div class="literal-block-wrapper docutils container" id="id2">
<div class="code-block-caption"><span class="caption-number">Listing 1 </span><span class="caption-text">Tree traversal algorithm for the BVH tree.</span><a class="headerlink" href="#id2" title="Permalink to this code">ÔÉÅ</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BV</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="w">  </span><span class="n">NodeT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">BV</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;::</span><span class="n">traverse</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">BVH</span><span class="o">::</span><span class="n">Updater</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w">              </span><span class="n">a_updater</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="k">const</span><span class="w"> </span><span class="n">BVH</span><span class="o">::</span><span class="n">Visiter</span><span class="o">&lt;</span><span class="n">Node</span><span class="p">,</span><span class="w"> </span><span class="n">Meta</span><span class="o">&gt;&amp;</span><span class="w">     </span><span class="n">a_visiter</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="k">const</span><span class="w"> </span><span class="n">BVH</span><span class="o">::</span><span class="n">Sorter</span><span class="o">&lt;</span><span class="n">Node</span><span class="p">,</span><span class="w"> </span><span class="n">Meta</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;&amp;</span><span class="w">   </span><span class="n">a_sorter</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="k">const</span><span class="w"> </span><span class="n">BVH</span><span class="o">::</span><span class="n">MetaUpdater</span><span class="o">&lt;</span><span class="n">Node</span><span class="p">,</span><span class="w"> </span><span class="n">Meta</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_metaUpdater</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Meta</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span><span class="w"> </span><span class="n">children</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Meta</span><span class="o">&gt;&gt;</span><span class="w">    </span><span class="n">q</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">shared_from_this</span><span class="p">(),</span><span class="w"> </span><span class="n">a_metaUpdater</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">first</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">meta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">second</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_visiter</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">meta</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">isLeaf</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">a_updater</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">getPrimitives</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">K</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">children</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">first</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">()[</span><span class="n">k</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="n">children</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_metaUpdater</span><span class="p">(</span><span class="o">*</span><span class="n">children</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">first</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>

<span class="w">          </span><span class="c1">// User-based visit pattern.</span>
<span class="w">          </span><span class="n">a_sorter</span><span class="p">(</span><span class="n">children</span><span class="p">);</span><span class="w"></span>

<span class="w">          </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">children</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</section>
<section id="traversal-examples">
<h3>Traversal examples<a class="headerlink" href="#traversal-examples" title="Permalink to this heading">ÔÉÅ</a></h3>
<p>Below, we consider two examples for BVH traversal.
The examples show how we compute the signed distance from a DCEL mesh, and how to perform a <em>smooth</em> CSG union where the search for the two closest objects is done by BVH traversal.</p>
<section id="signed-distance">
<h4>Signed distance<a class="headerlink" href="#signed-distance" title="Permalink to this heading">ÔÉÅ</a></h4>
<p>The DCEL mesh distance fields use a traversal pattern based on</p>
<ul class="simple">
<li><p>Only visit bounding volumes that are closer than the minimum distance computed (so far).</p></li>
<li><p>When visiting a subtree, investigate the closest bounding volume first.</p></li>
<li><p>When visiting a leaf node, check if the primitives are closer than the minimum distance computed so far.</p></li>
</ul>
<p>These rules are given below.</p>
<div class="literal-block-wrapper docutils container" id="id3">
<div class="code-block-caption"><span class="caption-number">Listing 2 </span><span class="caption-text">Tree traversal criterion for computing the signed distance to a DCEL mesh using the BVH accelerator.
See <code class="file docutils literal notranslate"><span class="pre">Source/EBGeometry_MeshDistanceFunctionsImplem.hpp</span></code> for details.</span><a class="headerlink" href="#id3" title="Permalink to this code">ÔÉÅ</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BV</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"></span>
<span class="n">FastMeshSDF</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Meta</span><span class="p">,</span><span class="w"> </span><span class="n">BV</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;::</span><span class="n">signedDistance</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_point</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">minDist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">infinity</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">BVH</span><span class="o">::</span><span class="n">Updater</span><span class="o">&lt;</span><span class="n">Face</span><span class="o">&gt;</span><span class="w"> </span><span class="n">updater</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">minDist</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="o">&amp;</span><span class="n">a_point</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Face</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">faces</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">faces</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">curDist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">signedDistance</span><span class="p">(</span><span class="n">a_point</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="n">minDist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">curDist</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">minDist</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">curDist</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">minDist</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="n">BVH</span><span class="o">::</span><span class="n">Visiter</span><span class="o">&lt;</span><span class="n">Node</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">visiter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">minDist</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a_point</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">Node</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_bvDist</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a_bvDist</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">minDist</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="n">BVH</span><span class="o">::</span><span class="n">Sorter</span><span class="o">&lt;</span><span class="n">Node</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sorter</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="o">&amp;</span><span class="n">a_point</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_leaves</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">a_leaves</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">a_leaves</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="p">[</span><span class="o">&amp;</span><span class="n">a_point</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">n2</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">n1</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">n2</span><span class="p">.</span><span class="n">second</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="n">BVH</span><span class="o">::</span><span class="n">MetaUpdater</span><span class="o">&lt;</span><span class="n">Node</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">metaUpdater</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">a_point</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">Node</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_node</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a_node</span><span class="p">.</span><span class="n">getDistanceToBoundingVolume</span><span class="p">(</span><span class="n">a_point</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Traverse the tree.</span>
<span class="w">  </span><span class="n">m_bvh</span><span class="o">-&gt;</span><span class="n">traverse</span><span class="p">(</span><span class="n">updater</span><span class="p">,</span><span class="w"> </span><span class="n">visiter</span><span class="p">,</span><span class="w"> </span><span class="n">sorter</span><span class="p">,</span><span class="w"> </span><span class="n">metaUpdater</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">minDist</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</div>
</section>
<section id="csg-union">
<h4>CSG Union<a class="headerlink" href="#csg-union" title="Permalink to this heading">ÔÉÅ</a></h4>
<p>Combinations of implicit functions in <code class="docutils literal notranslate"><span class="pre">EBGeometry</span></code> into aggregate objects can be done by means of CSG unions.
One such union is known as the <em>smooth union</em>, in which the transition between two objects is gradual rather than abrupt.
Below, we show the traversal code for this union, where we traverse through the tree and obtains the distance to the <em>two</em> closest objects rather than a single one.</p>
<div class="literal-block-wrapper docutils container" id="id4">
<div class="code-block-caption"><span class="caption-number">Listing 3 </span><span class="caption-text">Tree traversal when computing the smooth CSG union.
See <code class="file docutils literal notranslate"><span class="pre">Source/EBGeometry_CSGImplem.hpp</span></code> for details.</span><a class="headerlink" href="#id4" title="Permalink to this code">ÔÉÅ</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BV</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"></span>
<span class="n">FastSmoothUnionIF</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">BV</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vec3T</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_point</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// For the smoothed CSG union we use a smooth min operator on the two closest</span>
<span class="w">  </span><span class="c1">// primitives.</span>

<span class="w">  </span><span class="c1">// Closest and next closest primitives.</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">infinity</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">infinity</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">BVH</span><span class="o">::</span><span class="n">Updater</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">updater</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a_point</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">a_implicitFunctions</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">implicitFunction</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a_implicitFunctions</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">implicitFunction</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">(</span><span class="n">a_point</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="n">BVH</span><span class="o">::</span><span class="n">Visiter</span><span class="o">&lt;</span><span class="n">Node</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">visiter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">Node</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_node</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_bvDist</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a_bvDist</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">a_bvDist</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">a_bvDist</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="n">BVH</span><span class="o">::</span><span class="n">Sorter</span><span class="o">&lt;</span><span class="n">Node</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sorter</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="o">&amp;</span><span class="n">a_point</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_leaves</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">a_leaves</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">a_leaves</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="p">[</span><span class="o">&amp;</span><span class="n">a_point</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">n2</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">n1</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">n2</span><span class="p">.</span><span class="n">second</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="n">BVH</span><span class="o">::</span><span class="n">MetaUpdater</span><span class="o">&lt;</span><span class="n">Node</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">metaUpdater</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">a_point</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">Node</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_node</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a_node</span><span class="p">.</span><span class="n">getDistanceToBoundingVolume</span><span class="p">(</span><span class="n">a_point</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">m_bvh</span><span class="o">-&gt;</span><span class="n">traverse</span><span class="p">(</span><span class="n">updater</span><span class="p">,</span><span class="w"> </span><span class="n">visiter</span><span class="p">,</span><span class="w"> </span><span class="n">sorter</span><span class="p">,</span><span class="w"> </span><span class="n">metaUpdater</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">m_smoothMin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">m_smoothLen</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ImplemDCEL.html" class="btn btn-neutral float-left" title="DCEL" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ImplemOctree.html" class="btn btn-neutral float-right" title="Octree" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Robert Marskar.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>